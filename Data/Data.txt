# दो नंबर जोड़ने के लिए एक पायथन प्रोग्राम लिखें
num1 = 1.5
num2 = 6.3
sum = num1 + num2
print(f'Sum: {sum}')


# उपयोगकर्ता द्वारा प्रदान की गई दो संख्याओं को जोड़ने और योग वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def add_two_numbers(num1, num2):
    sum = num1 + num2
    return sum


# तीन संख्याओं में से सबसे बड़ी संख्या को खोजने और प्रिंट करने के लिए एक प्रोग्राम लिखें

num1 = 10
num2 = 12
num3 = 14
if (num1 >= num2) and (num1 >= num3):
   largest = num1
elif (num2 >= num1) and (num2 >= num3):
   largest = num2
else:
   largest = num3
print(f'largest:{largest}')


# तीन संख्याओं में से सबसे छोटी संख्या को खोजने और प्रिंट करने के लिए एक प्रोग्राम लिखें
num1 = 10
num2 = 12
num3 = 14
if (num1 <= num2) and (num1 <= num3):
   smallest = num1
elif (num2 <= num1) and (num2 <= num3):
   smallest = num2
else:
   smallest = num3
print(f'smallest:{smallest}')


# दी गई दो सूचियों को एक में मर्ज करने के लिए एक पायथन फ़ंक्शन लिखें
def merge_lists(l1, l2):
    return l1 + l2


# कोई संख्या अभाज्य है या नहीं, यह जाँचने के लिए एक प्रोग्राम लिखिए
num = 337

if num > 1:
   for i in range(2, num//2 + 1):
       if (num % i) == 0:
           print(num,"is not a prime number")
           print(f"{i} times {num//i} is {num}")
           break
   else:
       print(f"{num} is a prime number")

else:
   print(f"{num} is not a prime number")


# एक पायथन फ़ंक्शन लिखें जो किसी दिए गए नंबर के कारकों को प्रिंट करता है
def print_factors(x):
   print(f"The factors of {x} are:")
   for i in range(1, x + 1):
       if x % i == 0:
           print(i)

# किसी संख्या का भाज्य ज्ञात करने के लिए प्रोग्राम लिखिए
num = 13
factorial = 1

if num < 0:
   print("No factorials for negative numbers!")

elif num == 0:
   print("The factorial of 0 is 1")

else:
   for i in range(1,num + 1):
       factorial = factorial*i
   print(f"The factorial of {num} is {factorial}")


# कोई संख्या ऋणात्मक, सकारात्मक या शून्य है या नहीं, यह प्रिंट करने के लिए एक पायथन फ़ंक्शन लिखें
def check_pnz(num):
    if num > 0:
       print("Positive number")

    elif num == 0:
       print("Zero")

    else:
       print("Negative number")


# किसी दी गई संख्या की गुणन तालिका को प्रिंट करने के लिए एक प्रोग्राम लिखें

num = 9
for i in range(1, 11):
   print(f"{num} x {i} = {num*i}")


# दिए गए शब्दों की संख्या के लिए 2 की घात प्रिंट करने के लिए एक पायथन फ़ंक्शन लिखें
def two_power(terms):
    result = list(map(lambda x: 2 ** x, range(terms)))

    print(f"The total terms are: {terms}")
    for i in range(terms):
       print(f"2^{i} = {result[i]}")


# दी गई संख्या से विभाजित होने वाली सूची में संख्याओं को फ़िल्टर करने के लिए एक प्रोग्राम लिखें
my_list = [11, 45, 74, 89, 132, 239, 721, 21]

num = 3
result = list(filter(lambda x: (x % num == 0), my_list))

print(f"Numbers divisible by {num} are {result}")


# एक पायथन फ़ंक्शन लिखें जो n प्राकृतिक संख्याओं का योग लौटाता है
def sum_natural(num):
    if num < 0:
       print("Please enter a positive number!")
    else:
       sum = 0
       while(num > 0):
           sum += num
           num -= 1
       return num

# किसी सूची में पहले और अंतिम तत्वों की अदला-बदली करने के लिए एक प्रोग्राम लिखिए
my_list = [1, 2, 3, 4, 5, 6]
my_list[0], my_list[-1] = my_list[-1], my_list[0]


# एक वृत्त का क्षेत्रफल ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें, जिसकी त्रिज्या दी गई है
def findArea(r): 
    PI = 3.142
    return PI * (r*r)


# पहले n प्राकृत संख्याओं के वर्गों के योग को प्रिंट करने के लिए एक प्रोग्राम लिखिए
n = 21
sum_n = 0
for i in range(1, n+1):
    sum_n += i**2
print(sum_n)


# सूची की लंबाई को प्रिंट करने के लिए एक प्रोग्राम लिखें
my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]

print(len(my_list))


# किसी दिए गए टपल की लंबाई को प्रिंट करने के लिए एक पायथन फंक्शन लिखें
my_tuple = (1, 2, 3, 4, 5, 6, 7, 8)

print(len(my_tuple))


# किसी दी गई सूची के तत्वों को एक पंक्ति में एक तत्व को प्रिंट करने के लिए एक पायथन फ़ंक्शन लिखें
def custom_print(l):
    for _ in l:
        print(_)


# एक सूची से सभी विषम संख्याओं को हटाने और शेष सूची को वापस करने के लिए एक पायथन फ़ंक्शन लिखें

def remove_odd(my_list):
    result = list(filter(lambda x: (x % 2 == 0), my_list))
    return result


# एक सूची से सभी सम संख्याओं को हटाने और शेष सूची को वापस करने के लिए एक पायथन फ़ंक्शन लिखें

def remove_even(my_list):
    result = list(filter(lambda x: (x % 2 != 0), my_list))
    return result


# एक ऐसा फ़ंक्शन लिखें जो दो सूचियों को इनपुट के रूप में लेता है और संबंधित तत्वों की एक ज़िपित सूची देता है

def zip_list(list1, list2):
    return list(zip(list1, list2))


# किसी दी गई फ़ाइल की सामग्री को प्रिंट करने के लिए एक प्रोग्राम लिखें
file_name = 'temp.txt'
with open(file_name, 'r') as f:
    print(f.read())


# एक ऐसा फंक्शन लिखिए जो दो इनपुट नंबरों का LCM देता है
def lcm(a, b):
    if a>b:
        min_ = a
    else:
        min_ = b
    while True:
        if min_%a==0 and min_%b==0:
            break
        min_+=1
    return min_


# सूची में अद्वितीय तत्वों को प्रिंट करने के लिए एक प्रोग्राम लिखें
my_list = [1, 2, 4, 5, 2, 3, 1, 5, 4, 7, 8, 2, 4, 5, 2, 7, 3]

print(set(my_list))


# एक फ़ंक्शन लिखें जो किसी दी गई संख्या के अंकों का योग लौटाता है
def digisum(num):
    sum_=0
    while num > 0:
        dig = num % 10
        sum_+=dig
        num//=10
    return sum_


# कोई संख्या पैलिंड्रोम है या नहीं, यह जांचने और प्रिंट करने के लिए एक प्रोग्राम लिखें

num = 12321
temp = num
rev = 0
while num > 0:
    dig = num % 10
    rev = rev*10 + dig
    num//=10
if temp==rev :
    print("The number is a palindrome!")
else:
    print("The number isn't a palindrome!")


# एक फ़ंक्शन लिखें जो किसी दिए गए मान को n बार प्रिंट करता है
def print_n(val, n):
    for _ in range(n):
        print(val)


# वर्ग का क्षेत्रफल ज्ञात करने के लिए एक फंक्शन लिखिए
def square_area(a):
    return a*a


# वर्ग का परिमाप ज्ञात करने के लिए एक फलन लिखिए
def square_perimeter(a):
    return 4*a

# आयत का क्षेत्रफल ज्ञात करने के लिए एक फंक्शन लिखिए
def rectangle_area(l, b):
    return l*b

# एक आयत का पर्मिटर ज्ञात करने के लिए एक फंक्शन लिखिए
def rectangle_perimeter(l, b):
    return 2*(l+b)

# एक वृत्त का क्षेत्रफल ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें, जिसकी त्रिज्या दी गई है
def findArea(r): 
    PI = 3.142
    return PI * (r*r)

# बिजली बिल की गणना करने और वापस करने के लिए एक फंक्शन लिखें। उपयोग की गई इकाइयाँ दी गई हैं। कीमत प्रति यूनिट तय है और 750 यूनिट के बाद बढ़ जाती है।

def calc_elect_bill(units):
    if units > 0:
        if units <= 750:
            return 5*units
        else:
            return 5*(750) + 7*(units-750)

    else:
        return -1


# संख्या दिए जाने पर, सप्ताह का दिन वापस करने के लिए एक फ़ंक्शन लिखें
def give_day(n):
    day_dict = {1: 'Sunday', 2: 'Monday', 3: 'Tuesday', 4: 'Wednesday', 5: 'Thursday', 6: 'Friday', 7: 'Saturday'}
    return day_dict[n]


# एक सिलेंडर के आयतन की गणना और प्रिंट करने के लिए एक प्रोग्राम लिखें
r = 3
h = 5
pi = 3.14
volume = pi*(r**2)*h
print(volume)


# इनपुट संख्याओं के औसत की गणना करने और वापस करने के लिए एक फ़ंक्शन लिखें

def calc_avg(*args):
    if len(args) > 0:
        return sum(args)/len(args)
    return None


# p, r, t दिया हुआ, चक्रवृद्धि ब्याज की गणना करने के लिए एक फ़ंक्शन लिखें
def comp_int(p, r, t):
    amount = p * (1 + (r/100))**t
    interest = amount - p
    return interest


# साधारण ब्याज की गणना के लिए एक फलन लिखिए, दिया हुआ p, r, t
def simp_int(p, r, t):
    interest = (p*r*t)/100
    return interest


# दिए गए स्ट्रिंग को प्रिंट करने के लिए एक प्रोग्राम लिखें, जिसमें सभी स्वरों को '_' से बदल दिया जाए

st = "Where is this going? Could you please help me understand!"
vowels = "AEIOUaeiou"

for v in vowels:
    st = st.replace(v, '_')

print(st)


# कोई संख्या पूर्ण है या नहीं, यह जाँचने के लिए एक फलन लिखिए
def is_perfect(n):
    sum_ = 0
    for i in range(1, n//2 + 1):
        if n%i == 0:
            sum_+=i
    if sum_ == n:
        return True
    return False

# एक ऐसा फ़ंक्शन लिखें जो इनपुट सूची से सकारात्मक और नकारात्मक संख्याओं की अलग-अलग सूचियां देता है
def seperate_pn(l):
    pos_list = []
    neg_list = []
    for _ in l:
        if _<0:
            neg_list.append(_)
        else:
            pos_list.append(_)
    return pos_list, neg_list


# एक त्रिभुज का क्षेत्रफल ज्ञात करने और प्रिंट करने के लिए एक प्रोग्राम लिखिए, जिसकी ऊँचाई और चौड़ाई दी गई हो।

h = 12
w = 11
area = 0.5*h*w
print(area)


# दिए गए u, v और t त्वरण को खोजने के लिए एक फ़ंक्शन लिखें

def acc(u, v, t):
    return (v-u)/t

# दो संख्याओं को गुणा करने के लिए लैम्ब्डा फ़ंक्शन लिखें

multiply = lambda a, b: a*b

# दो संख्याओं को जोड़ने के लिए लैम्ब्डा फंक्शन लिखें
add = lambda a, b: a+b

# एक लैम्ब्डा फ़ंक्शन लिखें जो सही देता है यदि इनपुट संख्या अन्यथा गलत है

even = lambda a: True if a%2 == 0 else False

# एक लैम्ब्डा फ़ंक्शन लिखें, चरित्र ग्रोम को इसका एसीआई मान देने के लिए

ascii = lambda a: chr(a)

# एक लैम्ब्डा फ़ंक्शन लिखें जो किसी संख्या में अंकों की संख्या देता है

dig_cnt = lambda a: len(str(a))

# यह जाँचने के लिए एक प्रोग्राम लिखें कि त्रिभुज मान्य है या नहीं, यह तीनों कोण दिए गए हैं

def is_valid_triangle_angle(a, b c):
    if a+b+c == 180:
        return True
    return False

# यह जांचने के लिए एक प्रोग्राम लिखें कि त्रिभुज मान्य है या नहीं, यह देखते हुए कि यह तीनों भुजाओं की लंबाई है

def is_valid_triangle_length(a, b c):
    if a>0 and b>0 and c>0:
        if a+b > c and a+c > b and b+c > a:
            return True
    return False

# एक लैम्ब्डा फ़ंक्शन लिखें जो एक बयान में शब्द संख्या देता है।

count_word = lambda s: len(s.split(' '))


# किसी संख्या के अंकों को उल्टे क्रम में निकालने और प्रिंट करने के लिए एक प्रोग्राम लिखें। संख्या उपयोगकर्ता से इनपुट है।

num = int(input("Enter a number with multiple digit: "))
n=0
while num>0:
    a = num%10
    num = num - a
    num = num/10
    print(int(a),end="")
    n = n + 1

# एक फ़ंक्शन लिखें जो height (m) और weight (kg) लेता है, BMI की गणना करता है और टिप्पणियों को प्रिंट करता है

def bmi(height: "Meters", weight: "Kgs"):
    bmi = weight/(height**2) 
    print("Your BMI is: {0} and you are ".format(bmi), end='')
    if ( bmi < 16):
       print("severely underweight.")
    elif ( bmi >= 16 and bmi < 18.5):
       print("underweight.")
    elif ( bmi >= 18.5 and bmi < 25):
       print("healthy.")
    elif ( bmi >= 25 and bmi < 30):
       print("overweight.")
    elif ( bmi >=30):
       print("severely overweight.") 

# एक प्रोग्राम लिखें जो सभी वर्णों को एक स्ट्रिंग में प्रिंट करता है और अन्य सभी वर्णों को छोड़ देता है

string = "$john.snow#@Got.bad_ending/com"
for ch in string:
    if (ch>='A' and ch<='Z') or (ch>='a' and ch<='z'):
        print(ch, end='')
    else:
        pass

# एक ऐसा फंक्शन लिखिए जो टॉवर ऑफ हनोई प्रॉब्लम में डिस्क की संख्या लेता है और आवश्यक कदमों की न्यूनतम संख्या लौटाता है

def hanoi(x):
    if x == 1:
        return 1
    else:
        return 2*hanoi(x-1) + 1

# सेंटीमीटर को इंच में बदलने के लिए लैम्ब्डा फ़ंक्शन लिखें

cm_to_inch = lambda x: x/2.54

# दो सूचियों के मिलन को खोजने के लिए लैम्ब्डा फ़ंक्शन लिखें

union = lambda a, b: list(set(a)|set(b))

# दो सूचियों के प्रतिच्छेदन को खोजने के लिए लैम्ब्डा फ़ंक्शन लिखें

intersection = lambda a, b: list(set(a)&set(b))

# एक प्रोग्राम लिखें जो दो संख्याओं के वर्ग को जोड़ता है और इसे प्रिंट करता है

a = 32
b = 21

result = a**2 + b**2
print(result)

# इनपुट स्ट्रिंग्स को सम्‍मिलित करने के लिए एक पायथन फ़ंक्शन लिखें और सेपरेटर के लिए एक विकल्प भी है
def con_str(*args, sep = ' '):
  return sep.join(args)

# एक श्रेणी में सभी सम संख्याओं को प्रिंट करने के लिए एक प्रोग्राम लिखें

r1, r2 = 1, 28

for _ in range(r1, r2+1):
  if _%2 == 0:
    print(_)

# डिक्शनरी आइटम को सॉर्ट करने के लिए एक पायथन प्रोग्राम लिखें
dict1 = {'car': [7, 6, 3],  
             'bike': [2, 10, 3],  
             'truck': [19, 4]}

print(f"The original dictionary is : {str(dict1)}") 

res = dict() 
for key in sorted(dict1): 
    res[key] = sorted(dict1[key])

print(f"The sorted dictionary : {str(res)}")

# दिनांक और समय प्रदर्शित करने के लिए एक प्रोग्राम लिखें
import datetime
now = datetime.datetime.now()
time= now.strftime("%Y-%m-%d %H:%M:%S")
print(f"Current date and time : {time}")

# निरपेक्ष मूल्य वापस करने के लिए एक प्रोग्राम लिखें
num = -10
print(f'Absolute of {num} is {abs(num)}')

# सूची की लंबाई जांचने के लिए एक पायथन प्रोग्राम लिखें
sample_list = ['a','b','c']
print(f'length of sample_list is {len(sample_list)}')

# दो तिथियों के बीच दिनों की संख्या की गणना करने के लिए एक पायथन प्रोग्राम लिखें।
from datetime import date
f_date = date(2019, 4, 15) # YYYY/MM/DD
l_date = date(2020, 4, 15) # YYYY/MM/DD
delta = l_date - f_date
print(f'No of days between {f_date} and {l_date} is:{delta.days}')

# Python ऑब्जेक्ट को JSON स्ट्रिंग्स में बदलने के लिए Python प्रोग्राम लिखें।
import json
python_dict =  {"name": "David", "age": 6, "class":"I"}
json_dict = json.dumps(python_dict, sort_keys=True, indent=4)
print(f"json dict : {json_dict}")

# सूची से सबसे बड़ी संख्या प्राप्त करने के लिए एक पायथन प्रोग्राम लिखें
def max_num_in_list(list):
    max = list[0]
    for a in list:
        max = a if a > max else max
    return max
print(f'max_num_in_list [1, 10, -8, 0], Ans:{max_num_in_list([1, 10, -8, 0])}')

# सूची से डुप्लीकेट हटाने के लिए एक पायथन प्रोग्राम लिखें
a = [10,20,30,20,10,50,60,40,80,50,40]

dup_items = set()
uniq_items = []
for x in a:
    if x not in dup_items:
        uniq_items.append(x)
        dup_items.add(x)

print(f'dup_items:{dup_items}')

# उथली सूची को समतल करने के लिए एक पायथन प्रोग्राम लिखें
import itertools
original_list = [[2,4,3],[1,5,6], [9], [7,9,0], [1,2,3,4]]
new_merged_list = list(itertools.chain(*original_list))
print(f'merged list/flatten:{new_merged_list}')

# एकाधिक सूची बनाने के लिए एक पायथन प्रोग्राम लिखें

obj = {}
for i in range(1, 11):
    obj[str(i)] = []
print(f'create multiple list:{obj}')

# दो शब्दकोशों को मर्ज करने के लिए एक पायथन प्रोग्राम लिखें

d1 = {'a': 100, 'b': 200}
d2 = {'x': 300, 'y': 200}
d = d1.copy()
d.update(d2)
print(f'merge two dictionaries:{d}')

# एक शब्दकोश में सभी वस्तुओं को जोड़ने के लिए एक पायथन प्रोग्राम लिखें

my_dict = {'data1':100,'data2':-54,'data3':247}
print(f'Sum all the items in a dictionary:{sum(my_dict.values())}')

# एक शब्दकोश में अधिकतम और न्यूनतम मान प्राप्त करने के लिए एक पायथन प्रोग्राम लिखें

my_dict = {'x':500, 'y':5874, 'z': 560}

key_max = max(my_dict.keys(), key=(lambda k: my_dict[k]))
key_min = min(my_dict.keys(), key=(lambda k: my_dict[k]))

print('Maximum Value in a dictionary: ',my_dict[key_max])
print('Minimum Value in a dictionary: ',my_dict[key_min])

# एक शर्त के लिए कुछ नहीं करने के लिए एक पायथन प्रोग्राम लिखें

if 1 + 1 == 2:
    pass # Nothing

# enumerate पद्धति का उपयोग करने के लिए एक पायथन प्रोग्राम लिखें

for count, value in enumerate(obj):
    print(count, value)

# अनुपलब्ध शब्दकोश कुंजी के लिए सेटडेफॉल्ट का उपयोग करने के लिए एक पायथन प्रोग्राम लिखें
a_dict = {'a':1}
a_dict.setdefault('b',2)
print(f'After appending with new value:{a_dict}')

# नक्शों का उपयोग करने के लिए एक पायथन प्रोग्राम लिखें

def square(number):
    return number ** 2

numbers = [1, 2, 3, 4, 5]

squared = map(square, numbers)

print(f'mapped numbers:{list(squared)}')

# मॉड्यूलो ऑपरेटर का उपयोग करने के लिए एक पायथन प्रोग्राम लिखें

print(f'modulo 15 % 4: Sol->{15 % 4}')

# संलग्न और वैश्विक दायरे की व्याख्या करने के लिए एक पायथन प्रोग्राम लिखें

x = 'global'

def f():
    x = 'enclosing'
    def g():
        print(x)
    g()
    return x
obj1 = f()
print('explain global scope:',obj1)

# स्थानीय और वैश्विक दायरे का विस्तार करने के लिए एक पायथन प्रोग्राम लिखें

def f1():
    x = 'enclosing'
    def g():
        x = 'local'
        return x
    x=g()
    return x
obj2 = f1()
print('explain local scope:',obj2)

# मैचिंग के लिए रेगुलर एक्सप्रेशन का उपयोग करने के लिए एक पायथन प्रोग्राम लिखें
import re
print('Find the characters in the given string:',re.findall(r'[a-z]+', '123FOO456', flags=re.IGNORECASE))

# मैचिंग के लिए रेगुलर एक्सप्रेशन का उपयोग करने के लिए एक पायथन प्रोग्राम लिखें
s = 'foo123bar'
m = re.findall('123', s)
print('find the number position:',m)

# लोअर स्ट्रिंग को अपरकेस में बदलने के लिए एक पायथन प्रोग्राम लिखें
a = 'string'
print(f'convert lowercase to uppercase:{a.upper()}')

# अपरकेस स्ट्रिंग को लोअर में बदलने के लिए एक पायथन प्रोग्राम लिखें
a = 'STRING'
print(f'convert lowercase to uppercase:{a.lower()}')

# स्क्वायर रूट खोजने के लिए एक पायथन प्रोग्राम लिखें
num = 8 

num_sqrt = num ** 0.5
print('The square root of %0.3f is %0.3f'%(num ,num_sqrt))

# किलोमीटर को मील में बदलने के लिए एक पायथन प्रोग्राम लिखें
kilometers = 10.0

conv_fac = 0.621371

miles = kilometers * conv_fac
print('%0.2f kilometers is equal to %0.2f miles' %(kilometers,miles))

# सेल्सियस को फ़ारेनहाइट में बदलने के लिए एक पायथन प्रोग्राम लिखें
celsius = 37.5
fahrenheit = (celsius * 1.8) + 32
print('%0.1f degree Celsius is equal to %0.1f degree Fahrenheit' %(celsius,fahrenheit))

# एक संख्या सकारात्मक, नकारात्मक या 0 है या नहीं, यह जांचने के लिए एक पायथन प्रोग्राम लिखें
num = 10
if num > 0:
   print("Positive number")
elif num == 0:
   print("Zero")
else:
   print("Negative number")

# पायथन प्रोग्राम यह जांचने के लिए कि कोई संख्या विषम या सम है या नहीं
num = 100
if (num % 2) == 0:
   print("{0} is Even".format(num))
else:
   print("{0} is Odd".format(num))

# गुणन तालिका प्रदर्शित करने के लिए पायथन प्रोग्राम
num = 12
for i in range(1, 11):
   print(num, 'x', i, '=', num*i)

# पासा पलटने के लिए एक प्रोग्राम लिखें
import random
min = 1
max = 6

print("Rolling the dices...and the values are",random.randint(min, max))
print("Rolling the dices...and the values are",random.randint(min, max))

# औसत की गणना करने के लिए एक पायथन प्रोग्राम लिखें
list1 = [1,3,4,5]
average = (sum(list1)) / len(list1)
print(f"the average score is:  {average} ")

# रिवर्स लिस्ट प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
print(f'reverese the given list elements:{list1[::-1]}')

# थ्रेड बनाने के लिए एक पायथन प्रोग्राम लिखें
import threading
from threading import Thread
import time

def print_time( threadName, delay):
    count = 0
    while count < 5:
        time.sleep(delay)
        count += 1
        print("%s: %s" % ( threadName, time.ctime(time.time()) ))


# 1000 से कम संख्या की जाँच करने के लिए एक पायथन प्रोग्राम लिखें
def near_thousand(n):
      return ((abs(1000 - n) <= 100) or (abs(2000 - n) <= 100))
print('near to 1000',near_thousand(1000))
print('near to 1300',near_thousand(1300))

# तत्वों की सूची के लिए निचले मामले को ऊपरी में बदलने के लिए एक पायथन प्रोग्राम लिखें

x = ['ab', 'cd']
for i in x:
    print(i.upper())

# संख्या पूरी तरह से विभाजित होने पर तोड़ने के लिए एक पायथन प्रोग्राम लिखें
i = 1
while True:
    if i%3 == 0:
        break
    print(i)
 
    i+= 1

# दी गई सूची में नाम मौजूद होने की जांच करने के लिए एक पायथन प्रोग्राम लिखें
names1 = ['Amir', 'Bala', 'Chales']
for n in names1:
    name = n.lower()
    if 'amir' == name:
        print('Yes name exists:',name)
    else:
        print('No')

# मैट्रिक्स को आउटपुट के रूप में प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
matrix = [[1, 2, 3, 4],
       [4, 5, 6, 7],
       [8, 9, 10, 11],
       [12, 13, 14, 15]]
 
for i in range(0, 4):
    print(matrix[i][1], end = " ")

# लगने वाले समय की गणना करने के लिए एक पायथन प्रोग्राम लिखें

from time import localtime

activities = {8: 'Sleeping',
              9: 'Commuting',
              17: 'Working',
              18: 'Commuting',
              20: 'Eating',
              22: 'Resting' }

time_now = localtime()
hour = time_now.tm_hour

for activity_time in sorted(activities.keys()):
    if hour < activity_time:
        print (activities[activity_time])
        break
else:
    print ('Unknown, AFK or sleeping!')


# पाठ फ़ाइल में कुंजी खोजने के लिए एक पायथन प्रोग्राम लिखें
fname = 'sample.txt'
l='keyword' # Enter letter to be searched
k = 0
 
with open(fname, 'r') as f:
    for line in f:
        words = line.split()
        for i in words:
            if(i==l):
                k=k+1
print("Occurrences of the letter:",k)

# सूची की समझ की व्याख्या करने और वैकल्पिक मूल्यों को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
t = (1, 2, 4, 3, 8, 9)
print([t[i] for i in range(0, len(t), 2)])

# टुपल वैल्यू को सॉर्ट करने के लिए एक पायथन प्रोग्राम लिखें
a=(2,3,1,5)
tuple_sorted = sorted(a)
print(tuple(tuple_sorted))

# एकाधिक दो सूची मानों के लिए एक पायथन प्रोग्राम लिखें
l1=[1,2,3]
l2=[4,5,6]
print('multiply two list values:',[x*y for x in l1 for y in l2])

# किसी दी गई सूची 'एल' से केवल ऋणात्मक पूर्णांकों को चुनने के लिए सूची समझ लिखें।
l1=[1,2,3,-4,-8]

print('negative integers:', [x for x in l1 if x<0])

# सभी सूची तत्वों को अपरकेस में बदलने के लिए एक पायथन प्रोग्राम लिखें
s=["pune", "mumbai", "delhi"]
print([(w.upper(), len(w)) for w in s])

# अजगर ज़िप विधि को समझाने के लिए एक अजगर कार्यक्रम लिखें
l1=[2,4,6]
l2=[-2,-4,-6]
for i in zip(l1, l2):
	print(i)

# अजगर ज़िप विधि का उपयोग करके दो सूची जोड़ने के लिए एक अजगर कार्यक्रम लिखें

l1=[10, 20, 30]
l2=[-10, -20, -30]
l3=[x+y for x, y in zip(l1, l2)]
print('added two list:',l3)

# संख्या और उसके घन के लिए एक सूची समझ लिखें
l=[1, 2, 3, 4, 5, 6, 7, 8, 9]
print([x**3 for x in l])

# पंक्तियों को कॉलम और वीवी में प्रिंट करने के लिए एक सूची समझ लिखें

l=[[1 ,2, 3], [4, 5, 6], [7, 8, 9]]
print([[row[i] for row in l] for i in range(3)])

# कॉलम में पंक्तियों को प्रिंट करने के लिए एक सूची समझ लिखें और इसके विपरीत

def unpack(a,b,c,d):
    print(a+d)
x = [1,2,3,4]
unpack(*x)

# पायथन लैम्ब्डा फ़ंक्शन का उपयोग करने के लिए एक पायथन प्रोग्राम लिखें
lamb = lambda x: x ** 3
print(lamb(5))

# एक स्ट्रिंग n बार गुणा करने के लिए एक पायथन प्रोग्राम लिखें
a = 'python'
print(a*5)

# दो संख्याओं की जाँच करने के लिए एक अजगर लिखें जो इससे अधिक या बराबर या उससे कम हैं
def maximum(x, y):
    if x > y:
        return x
    elif x == y:
        return 'The numbers are equal'
    else:
        return y
 
print(maximum(2, 3))

# ज़िप करने के लिए एक अजगर लिखें और मूल रूप में शब्दकोश तत्वों के रूप में प्रिंट करें

a={"a":1,"b":2,"c":3}
b=dict(zip(a.values(),a.keys()))
print(b)


# शब्दकोश तत्व को हटाने के लिए एक पायथन प्रोग्राम लिखें
a={1:5,2:3,3:4}
a.pop(3)
print(a)

# दो डिक्शनरी बराबर हैं या नहीं, यह जांचने के लिए एक पायथन प्रोग्राम लिखें
d1 = {"john":40, "peter":45}
d2 = {"john":466, "peter":45}
d1 == d2

# सूची के रूप में केवल शब्दकोश कुंजी मुद्रित करने के लिए एक पायथन प्रोग्राम लिखें

d = {"john":40, "peter":45}
print(list(d.keys()))

# दो सूचियाँ समान हैं या नहीं, यह जाँचने के लिए एक पायथन प्रोग्राम लिखें

a=[1, 4, 3, 5, 2]
b=[3, 1, 5, 2, 4]
print(a==b)

# अद्वितीय तत्वों के सेट का योग करने के लिए एक पायथन प्रोग्राम लिखें

a={5,6,7}
print(sum(a,5))

# ट्राई कैच कोड को लागू करने के लिए एक पायथन प्रोग्राम लिखें

try:
    s={5,6}
    s*3
except Exception as e:
    print(e)


# अद्वितीय तत्वों की लंबाई गिनने के लिए एक पायथन प्रोग्राम लिखें

nums = set([1,1,2,3,3,3,4,4])
print(len(nums))

# अजगर में विभाजित करने के लिए एक अजगर कार्यक्रम लिखें

print('abcdefcdghcd'.split('cd', 2))

# स्ट्रिंग में शीर्षक जोड़ने के लिए एक पायथन प्रोग्राम लिखें
print('ab cd-ef'.title())

# स्ट्रिंग की समान लंबाई को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
print('ab'.zfill(5))

# स्ट्रिंग प्रतिस्थापन का उपयोग करने के लिए एक पायथन प्रोग्राम लिखें
print('abcdef12'.replace('cd', '12'))

# स्ट्रिंग istitle की जांच के लिए एक पायथन प्रोग्राम लिखें
str1 = 'Hello!2@#World'
if str1.istitle():
    print('Yes string is title')

# स्ट्रिंग पर lstrip करने के लिए एक अजगर प्रोग्राम लिखें

print('xyyzxxyxyy'.lstrip('xyy'))

# पहचानकर्ता/कीवर्ड की जांच के लिए एक पायथन प्रोग्राम लिखें
print('for'.isidentifier())

# जांचने के लिए एक पायथन प्रोग्राम लिखें एक संख्या/int है
print('11'.isnumeric())

# जांचने के लिए एक पायथन प्रोग्राम लिखें कि एक चर प्रिंट करने योग्य है
print('1@ a'.isprintable())

# यह जांचने के लिए एक पायथन प्रोग्राम लिखें कि इसमें कोई स्थान है या नहीं
print(''''''.isspace())

# जांचने के लिए एक पायथन प्रोग्राम लिखें एक शीर्षक है
print('HelloWorld'.istitle())

# जांचने के लिए एक पायथन प्रोग्राम लिखें कि सभी अंक/इंट हैं
print('ab,12'.isalnum())

# जांचने के लिए एक पायथन प्रोग्राम लिखें कि सभी अल्फ़ान्यूमेरिक हैं
print('ab'.isalpha())

# यह जांचने के लिए एक पायथन प्रोग्राम लिखें कि सभी अंक हैं
print('0xa'.isdigit())

# एफ स्ट्रिंग का उपयोग करने के लिए एक पायथन प्रोग्राम लिखें
var1 = 'python language'
print(f'f-string is an good feature in {var1}')

# एक शब्दकोश को पुनरावृति करने और जोड़ने के लिए एक अजगर कार्यक्रम लिखें

D=dict(p='san', q='foundry')
print('{p}{q}'.format(**D))

# रिक्त स्थान को 1 में बदलने के लिए एक पायथन प्रोग्राम लिखें
a='1 0 0 1'
print(a.replace(' ', '1'))

# जनरेटर को समझाने के लिए एक पायथन प्रोग्राम लिखें
def f11(x):
    yield x+1
g=f11(8)
print(next(g))

# रिक्त स्थान को 1 में बदलने के लिए एक पायथन प्रोग्राम लिखें
def f12(x):
    yield x+1
    print("test")
    yield x+2
g=f12(9)
print(next(g))

# वर्तमान कार्यशील निर्देशिका को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
import os
print(os.getcwd())

# एक स्ट्रिंग के एएससीआई मान को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
print([ord(ch) for ch in 'abc'])

# सूची में विस्तार/सूची में संलग्न करने के लिए एक पायथन प्रोग्राम लिखें
a=[13,56,17]
a.append([87])
a.extend([45,67])
print(a)

# रिक्त स्थान को 1 में बदलने के लिए एक पायथन प्रोग्राम लिखें
my_string = 'balaji'
k = [print(i) for i in my_string if i not in "aeiou"]
print('Not a vowel',k)

# संख्या की एक श्रेणी जोड़ने और वर्ग करने के लिए एक पायथन प्रोग्राम लिखें
x = [i**+1 for i in range(3)]; print(x)

# सूची व्यापक के साथ दो सूची को गुणा करने के लिए एक पायथन प्रोग्राम लिखें
l1=[1,2,3]
l2=[4,5,6]
print([x*y for x in l1 for y in l2])

# किसी दी गई सूची में केवल अंक या केवल apha charac को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
l=["good", "oh!", "excellent!", "#450"]
print([n for n in l if n.isalpha() or n.isdigit()])

# आज की तारीख को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
tday=datetime.date.today()
print(tday)

# टुपल अपरिवर्तनीय हैं यह जांचने के लिए एक पायथन प्रोग्राम लिखें
a=(1,2,3)
try:
    a = a+1
except Exception as e:
    print(e)

# व्यापक सूची का उपयोग करके भाज्य योग की गणना करने के लिए एक पायथन प्रोग्राम लिखें
import functools 
n =5
print(functools.reduce(lambda x, y: x * y, range(1, n+1)))

# प्रत्येक वर्ण के लेन को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))
    
# लैम्ब्डा फ़ंक्शन का उपयोग करके विधि के प्रत्येक कॉल पर वृद्धि करने के लिए एक पायथन प्रोग्राम लिखें
def make_incrementor(n):
    return lambda x: x + n
f = make_incrementor(42)
f(0)
print(f(1))

# सूची व्यापक का उपयोग करके सॉर्ट करने के लिए एक पायथन प्रोग्राम लिखें
pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
pairs.sort(key=lambda pair: pair[1])
print(pairs)

# सरणी/सूची के पहले तत्व को डेल करने के लिए एक पायथन प्रोग्राम लिखें
a = [-1, 1, 66.25, 333, 333, 1234.5]
del a[0]
print(a)

# किसी दिए गए शब्द के पहले अक्षर को बदलने के लिए एक पायथन प्रोग्राम लिखें
word = "goal"
word = "f" + word[1:]
print(word)

# दिए गए वाक्यांश में एक स्ट्रिंग खोजने के लिए एक पायथन प्रोग्राम लिखें
phrase = "the surprise is in here somewhere"
print(phrase.find("surprise"))

# एफ-स्ट्रिंग के उपयोग की व्याख्या करने के लिए एक पायथन प्रोग्राम लिखें
n = 3
m = 4
print(f"{n} times {m} is {n*m}")


# तीन संख्याओं को गुणा करने के लिए एक पायथन प्रोग्राम लिखें
num1 = 1.5
num2 = 6.3
num3 = -2.3
product = num1 * num2 * num3
print(f'Product: {product}')


# एक पायथन फ़ंक्शन लिखें जो दो नंबर दिए जाने पर, पहली संख्या को दूसरी संख्या से विभाजित करेगा और भागफल और शेषफल लौटाएगा
def divide_first_number_by_second(num1, num2):
    return (num1 // num2), (num1 % num2)


# दी गई सूची में सबसे बड़ी और सबसे छोटी संख्या वापस करने के लिए एक पायथन फ़ंक्शन लिखें और सूची खाली होने पर कुछ नहीं लौटाएं
def largest_and_smallest(list_of_nums):
    if list_of_nums:
        return max(list_of_nums), min(list_of_nums)
    else:
        return


# nth फ़ाइबोनैचि संख्या को प्रिंट करने के लिए एक पुनरावर्ती पायथन फ़ंक्शन लिखें, जहाँ n को तर्क के रूप में प्रदान किया गया है
def fibonacci_recursive(n):
   if n <= 1:
       return n
   else:
       return (recur_fibo(n-1) + recur_fibo(n-2))


# एक पायथन फ़ंक्शन लिखें जो दिए गए इनपुट फ़ाइल पथ को पढ़ेगा और इसकी सामग्री को प्रिंट करेगा
def read_and_print_file(filepath):
    with open(filepath, "r") as infile:
        print( infile.read() )


# एक पायथन प्रोग्राम लिखें जो लूप के लिए उपयोग करके पहले n पॉजिटिव पूर्णांक को प्रिंट करेगा
n = 62
for num in range(n):
    print(num)


# एक पायथन फ़ंक्शन लिखें जो आरोही क्रम में क्रमबद्ध इनपुट सूची देता है
def sort_ascending(list_to_be_sorted):
    return sorted(list_to_be_sorted)


# एक पायथन फ़ंक्शन लिखें जो अवरोही क्रम में क्रमबद्ध इनपुट सूची देता है
def sort_descending(list_to_be_sorted):
    return sorted(list_to_be_sorted, reverse=True)


# एक पायथन फ़ंक्शन लिखें जो पहले n प्राकृतिक संख्याओं का योग लौटाएगा, जहाँ n इनपुट है
def sum_first_n(n):
    return ( n * (n+1) ) // 2


# एक पुनरावर्ती पायथन फ़ंक्शन लिखें जो पहले n प्राकृतिक संख्याओं का योग लौटाएगा, जहाँ n इनपुट है
def sum_first_n_recursive(n):
    if n == 0:
        return 0
    return sum_first_n_recursive(n-1) + n


# एक पायथन फ़ंक्शन लिखें जो शब्दकोशों की एक सूची को फ़िल्टर करेगा जहां एक निर्दिष्ट कुंजी दिए गए मान के बराबर है, list_of_dictionaries, key और value इस फ़ंक्शन के इनपुट हैं।
def filter_with_key_value(list_of_dicts, key, value):
    return list( filter( lambda x: x.get(key) == value, list_of_dicts ) )


# एक पुनरावर्ती पायथन फ़ंक्शन लिखें जो इनपुट के रूप में या तो एक सूची या टपल लेता है और इसके तत्वों के क्रम को उलट देता है
def reverse(seq):
    SeqType = type(seq)
    emptySeq = SeqType()
    if seq == emptySeq:
        return emptySeq
    restrev = reverse(seq[1:])
    first = seq[0:1]
    result = restrev + first
    return result


# एक पायथन फ़ंक्शन लिखें जो किसी दिए गए इनपुट नंबर का वर्ग लौटाता है
def square(x):
    return x**2


# एक पायथन फ़ंक्शन लिखें जो दी गई सूची या टपल या स्ट्रिंग पर चयन सॉर्ट करता है और नया क्रमबद्ध अनुक्रम देता है
def selection_sort(list_to_be_sorted):
    sorted_list = list_to_be_sorted[:]
    for i in range(len(sorted_list)):
        new_min = sorted_list[i]
        new_min_old_place = i
        for j in range(i+1, len(sorted_list)):
            if new_min > sorted_list[j]:
                new_min = sorted_list[j]
                new_min_old_place = j
        old_val = sorted_list[i]
        sorted_list[i] = new_min
        sorted_list[new_min_old_place] = old_val
    return sorted_list


# एक पायथन प्रोग्राम लिखें जो उपयोगकर्ता इनपुट मांगता है और दिए गए इनपुट को प्रिंट करता है
a = input("User Input")
print(a)


# दिए गए माध्य और मानक विचलन द्वारा दी गई सूची में सभी संख्याओं को शिफ्ट और स्केल करने के लिए एक पायथन फ़ंक्शन लिखें
def shift_and_scale(list_of_nums, mean, std):
    return [ (x-mean) / std for x in list_of_nums ]


# एक पायथन फ़ंक्शन लिखें जो अनुक्रमों की एक सूची लेता है और सूची से प्रत्येक संबंधित तत्व को एक टुपल में ज़िप करता है और ऐसे टुपल्स की सूची देता है
def zip_(list_of_seq):
    return list(zip(*list_of_seq))


# एक पायथन प्रोग्राम लिखें जो उपयोगकर्ता को 1 और 5 के बीच की संख्या का अनुमान लगाने और 3 अनुमानों के भीतर अनुमान लगाने के लिए कहता है
print("Please guess a number between 1 and 5 and I will guess within 3 chances!")
guess1 = input("Is it <= 3? enter y/n \n")
if guess1 == "y":
    guess2 = input("Is it <= 2? enter y/n \n")
    if guess2 == "y":
        guess3 = input("Is it 1? enter y/n \n")
        if guess3 == "y":
            print("Yay! found the number, its 1")
        else:
            print("Yay! found the number, its 2")
    else:
        print("Yay! found the number, its 3")
else:
    guess2 = input("Is it 4? enter y/n \n")
    if guess2 == "y":
        print("Yay! found the number, its 4")
    else:
        print("Yay! found the number, its 5")


# अजगर प्रोग्राम लिखें जो पहले में दूसरे को जोड़कर दो शब्दकोशों को मिला देगा
a = {"a": 1, "b": 3}
b = {"c": 1, "d": 3}
a.update(b)


# एक पायथन फ़ंक्शन लिखें जो दिए गए स्ट्रिंग को उलट देगा
def reverse_string(str_to_be_reversed):
    return str_to_be_reversed[::-1]


# एक पायथन प्रोग्राम लिखें जो "हैलो वर्ल्ड" प्रिंट करेगा
print("Hello World")


# एक पायथन प्रोग्राम लिखें जो परिवर्तनीय मानों को स्वैप करेगा
a = 10
b = 15
a, b = b, a


# एक पायथन प्रोग्राम लिखें जो एक शब्दकोश पर पुनरावृति करता है और इसकी कुंजियों और मूल्यों को प्रिंट करता है
a = {"a":1, "b":2, "c":3, "d":4}
for k, v in a.items():
    print(k, v)


# एक पायथन फ़ंक्शन लिखें जो किसी दिए गए वर्ण के ASCII मान को प्रिंट करेगा
def print_ascii(char):
    print(ord(char))


# एक पायथन फ़ंक्शन लिखें जो दो संख्याओं में लेता है और उनका एचसीएफ देता है
def hcf(num1, num2):
    smaller = num1 if num1 < num2 else num2
    for i in range(1, smaller+1):
        if (num1 % i == 0) and (num2 % i == 0):
            hcf = i
    return hcf


# एक अजगर फ़ंक्शन लिखें जो दो संख्याओं में लेता है और उनका LCM लौटाता है
def lcm(num1, num2):
    bigger = num1 if num1 > num2 else num2
    while True:
        if (bigger % num1 == 0) and (bigger % num2 == 0):
            break
        bigger += 1
    return bigger


# n तक प्राकृतिक संख्याओं के योग की गणना करने के लिए एक पुनरावर्ती पायथन फ़ंक्शन लिखें, जहाँ n एक तर्क है
def recursive_sum(n):
    if n <= 1:
        return n
    else:
        return n + recursive_sum(n-1)


# एक पायथन फ़ंक्शन लिखें जो किसी सूची के अंतिम तत्व को हटा देता है और सूची और हटाए गए तत्व को वापस कर देता है
def delete_last_element(list_to_be_processed):
    deleted_element = list_to_be_processed.pop()
    return list_to_be_processed, deleted_element


# एक पायथन फ़ंक्शन लिखें जो एक सूची लेता है और एक सूची देता है जिसमें इनपुट सूची के तत्वों के वर्ग होते हैं
def square_list_elements(list_to_be_squared):
    return list( map(lambda x: x**2, list_to_be_squared) )


# एक पायथन फ़ंक्शन लिखें जो किसी दिए गए नंबर की वर्गमूल पाता है, यदि वर्गमूल एक पूर्णांक है, तो संदेश देता है "Error - the square root is not an integer"
def find_integer_square_roots(num):write a python function that finds square roots of a given number, if the square root is an integer, else returns the message "Error - the square root is not an integer"
    found = False
    for k in range(1, (num//2)+1):
        if ((k**2)==num):
            found = True
            break
    if not found:
        return "Error - the square root is not an integer"
    return -k, k


# एक पायथन प्रोग्राम लिखें जो थोड़ी देर के लूप का उपयोग करके दी गई संख्या से कम या उसके बराबर प्राकृतिक संख्या को प्रिंट करता है
input_num = 27
while input_num:
    print(input_num)
    input_num -= 1


# एक पायथन फ़ंक्शन लिखें जो दो नंबर लेता है। फ़ंक्शन पहली संख्या को दूसरी संख्या से विभाजित करता है और उत्तर देता है। यदि दूसरी संख्या 0 है, तो फ़ंक्शन कोई नहीं देता है
def divide(num1, num2):
    if num2 == 0:
        return
    else:
        return num1 / num2


# फॉर लूप के साथ else का एक पायथन प्रोग्राम लिखें
seq = "abcde"
for k in seq:
    if k == "f":
        break
else:
    print("f Not Found!")


# एक पुनरावर्ती पायथन फ़ंक्शन लिखें जो दी गई सूची या टपल या स्ट्रिंग पर मर्ज सॉर्ट करता है और नए क्रमबद्ध अनुक्रम को वापस करता है
def sort_and_merge(l1, l2):
    new_list = []
    i = 0
    j = 0
    l1_len = len(l1)
    l2_len = len(l2)
    while (i <= l1_len-1) and (j <= l2_len-1):
        if l1[i] < l2[j]:
            new_list.append(l1[i])
            i +=1
        else:
            new_list.append(l2[j])
            j +=1
    if i <= (l1_len-1):
        new_list += l1[i:]
    if j <= (l2_len-1):
        new_list += l2[j:]
    return new_list

def recursive_merge_sort(list_to_be_sorted):
    final_list = []
    first = 0
    last = len(list_to_be_sorted)
    if last <= 1:
        final_list.extend( list_to_be_sorted )
    else:
        mid = last // 2
        l1 = recursive_merge_sort( list_to_be_sorted[:mid] )
        l2 = recursive_merge_sort( list_to_be_sorted[mid:] )
        final_list.extend( sort_and_merge( l1, l2 ) )
    return final_list

# किसी सूची में संख्याओं का माध्य वापस करने के लिए एक फ़ंक्शन लिखें
def cal_mean(num_list:list)->float:
    if num_list:
        return sum(num_list)/len(num_list)
    else:
        return None

# किसी सूची में संख्याओं का माध्य लौटाने के लिए एक फ़ंक्शन लिखें
def cal_median(num_list:list)->float:
    if num_list:
        if len(num_list)%2 != 0:
            return sorted(num_list)[int(len(num_list)/2) - 1]
        else:
            return (sorted(num_list)[int(len(num_list)/2) - 1] + sorted(num_list)[int(len(num_list)/2)])/2
    else:
        return None

# हेरोस सूत्र द्वारा त्रिभुज का क्षेत्रफल लौटाने के लिए एक फंक्शन लिखिए
def cal_triangle_area(a:float,b:float,c:float)->float:
    if a or b or c:
        s = (a+b+c)/2
        if s>a and s>b and s>c:
            area = (s*(s-a)*(s-b)*(s-c))**(1/2)
            return round(area,2)
        else:
            return None
    return None

# एक समबाहु त्रिभुज का क्षेत्रफल वापस करने के लिए एक फ़ंक्शन लिखें
def cal_eq_triangle_area(a:float)->float:
    if a:
        return (3**(1/2))*(a**2)/4
    else:
        return None

# समकोण त्रिभुज का क्षेत्रफल लौटाने के लिए एक फंक्शन लिखिए

def cal_rt_triangle_area(base:float,height:float)->float:
    if base and height:
        return (base*height)/2
    else:
        return None

# उत्पत्ति से किसी बिंदु की कार्टिसियन दूरी वापस करने के लिए एक फ़ंक्शन लिखें
def cal_dist_from_orign(x:float,y:float)->float:
    return (x**2+y**2)**(1/2)

# दो बिंदुओं के बीच कार्टिसियन दूरी वापस करने के लिए एक फ़ंक्शन लिखें
def cal_cart_distance(x1:float,y1:float,x2:float,y2:float)->float:
    return ((x1-x2)**2+(y1-y2)**2)**(1/2)

# द्विघात समीकरण ax**2 + bx + c = 0 के प्रकार की जड़ें वापस करने के लिए एक फ़ंक्शन लिखें
def root_type(a:float,b:float,c:float):
    if b**2-4*a*c >= 0:
        return 'real'
    else:
        return 'imaginary'

# द्विघात समीकरण ax**2 + bx + c = 0 की जड़ों का योग वापस करने के लिए एक फ़ंक्शन लिखें
def sum_of_roots(a:float,c:float):
    if a:
        return c/a
    else:
        return None

# द्विघात समीकरण ax**2 + bx + c = 0 के मूलों का गुणनफल लौटाने के लिए एक फ़ंक्शन लिखें
def prod_of_roots(a:float,b:float):
    if a:
        return -b/a
    else:
        return None

# एक द्विघात समीकरण की जड़ों के वास्तविक को वापस करने के लिए एक फ़ंक्शन लिखें अन्यथा कोई नहीं ax**2 + bx + c = 0 लौटाएं
def roots_of_qad_eq(a:float,b:float,c:float):
    d = b**2-4*a*c
    if d >= 0:
        return (-b+(d)**(1/2))/2*a,(-b-(d)**(1/2))/2*a
    else:
        return None

# लागत मूल्य और विक्रय मूल्य के आधार पर लाभ या हानि वापस करने के लिए एक फ़ंक्शन लिखें
def find_profit_or_loss(cp,sp):
    if cp > sp:
        return 'loss', cp-sp
    elif cp < sp:
        return 'profit', sp-cp
    else:
        return 'no profit or loss', 0

# एक आयत का क्षेत्रफल वापस करने के लिए एक फंक्शन लिखें
def cal_area_rect(length, breadth):
    return length*breadth

# एक वर्ग का क्षेत्रफल वापस करने के लिए एक फ़ंक्शन लिखें
def cal_area_square(side):
    return side**2

# विकर्ण q1 और q2 वाले समचतुर्भुज का क्षेत्रफल वापस करने के लिए एक फ़ंक्शन लिखें
def cal_area_rhombus(q1,q2):
    return (q1*q2)/2

# आधार आधार b और समानांतर भुजाओं के बीच ऊँचाई h वाले समलंब का क्षेत्रफल लौटाने के लिए एक फलन लिखिए
def cal_area_trapezium(a,b,h):
    return h*(a+b)/2

# त्रिज्या r के एक वृत्त का क्षेत्रफल वापस करने के लिए एक फ़ंक्शन लिखें
def cal_area_circle(r):
    pi = 3.14
    return pi*r**2

# एक वृत्त की परिधि वापस करने के लिए एक फ़ंक्शन लिखें
def cal_circumference(r):
    pi = 3.14
    return 2*pi*r

# आयत की परिधि वापस करने के लिए एक फ़ंक्शन लिखें
def cal_perimeter_rect(length, bredth):
    return 2*(length+bredth)

# त्रिकोण की परिधि वापस करने के लिए एक फ़ंक्शन लिखें
def cal_perimeter_triangle(s1,s2,s3):
    return s1+s2+s3

# एक वर्ग की परिधि वापस करने के लिए एक फ़ंक्शन लिखें
def cal_perimeter_square(side):
    return 4*side

# एक समबाहु त्रिभुज की परिधि वापस करने के लिए एक फ़ंक्शन लिखें
def cal_perimeter_eq_triangle(a):
    return 3*a

# समद्विबाहु त्रिभुज की परिधि वापस करने के लिए एक फ़ंक्शन लिखें
def cal_perimeter_iso_triangle(s1,s2):
    return 2*s1+s2

# दीर्घवृत्त का क्षेत्रफल लौटाने के लिए एक फंक्शन लिखिए
def cal_area_ellipse(minor, major):
    pi = 3.14
    return pi*(minor*major)

# एक सिलेंडर के पार्श्व सतह क्षेत्र को वापस करने के लिए एक फ़ंक्शन लिखें
def cal_cylinder_lat_surf_area(height,radius):
    pi=3.14
    return 2*pi*radius*height

# एक शंकु के वक्र पृष्ठीय क्षेत्रफल को लौटाने के लिए एक फ़ंक्शन लिखिए
def cal_cone_curved_surf_area(slant_height,radius):
    pi=3.14
    return pi*radius*slant_height

# भुजा a वाले घन का कुल पृष्ठीय क्षेत्रफल लौटाने के लिए एक फ़ंक्शन लिखिए
def cal_surface_area_cube(a):
    return 6*(a**2)

# लम्बाई l, चौड़ाई b और ऊँचाई h वाले घनाभ का कुल पृष्ठीय क्षेत्रफल प्राप्त करने के लिए एक फ़ंक्शन लिखिए
def cal_surface_area_cuboid(l,b,h):
    return 2*(l*b+b*h+h*l)

# एक गोले का पृष्ठीय क्षेत्रफल लौटाने के लिए एक फ़ंक्शन लिखिए
def cal_area_sphere(radius):
    pi = 3.14
    return 4*pi*(radius**2)

# अर्ध-गोले का पृष्ठीय क्षेत्रफल लौटाने के लिए एक फ़ंक्शन लिखिए
def cal_area_hemisphere(radius):
    pi = 3.14
    return 2*pi*(radius**2)

# एक सिलेंडर के कुल सतह क्षेत्र को वापस करने के लिए एक फ़ंक्शन लिखें
def cal_cylinder_surf_area(height,radius):
    pi=3.14
    return 2*pi*radius**2*+2*pi*radius*height

# शंकु के पार्श्व सतह क्षेत्र को वापस करने के लिए एक फ़ंक्शन लिखें
def cal_cone_lateral_surf_area(height,radius):
    pi=3.14
    return pi*radius*(((height**2)+(radius**2))**(1/2))

# एक सिलेंडर का आयतन वापस करने के लिए एक फ़ंक्शन लिखें
def cal_cylinder_volume(height, radius):
    pi=3.14
    return pi*(radius**2)*height

# शंकु का आयतन वापस करने के लिए एक फ़ंक्शन लिखें
def cal_cone_volume(height,radius):
    pi=3.14
    return pi*(radius**2)*height/3

# हेमी गोले का आयतन वापस करने के लिए एक फ़ंक्शन लिखें
def cal_hemisphere_volume(radius:float)->float:
    pi=3.14
    return (2/3)*pi*(radius**3)

# एक गोले का आयतन वापस करने के लिए एक फंक्शन लिखें
def cal_sphere_volume(radius:float)->float:
    pi=3.14
    return (4/3)*pi*(radius**3)

# घनाभ का आयतन वापस करने के लिए एक फ़ंक्शन लिखें
def cal_cuboid_volume(length:float, breadth:float, height:float)->float:
    return length*breadth*height

# क्यूब का आयतन वापस करने के लिए एक फंक्शन लिखें
def cal_cube_volume(side:float)->float:
    return side**3

# दिए गए समय में तय की गई दूरी के आधार पर गतिमान वस्तु की गति वापस करने के लिए एक फ़ंक्शन लिखें
def cal_speed(distance:float,time:float)->float:
    return distance/time

# गतिमान वस्तु द्वारा तय की गई दूरी को खर्च और दिए गए समय के आधार पर वापस करने के लिए एक फ़ंक्शन लिखें
def cal_distance(time:float,speed:float)->float:
    return time*speed

# दिए गए समय में तय की गई दूरी के आधार पर चलती हुई वस्तु द्वारा दिए गए समय को वापस करने के लिए एक फ़ंक्शन लिखें
def cal_time(distance:float,speed:float)->float:
    return distance/speed

# टोक़ को वापस करने के लिए एक फ़ंक्शन लिखें जब एक बल force को कोण theta पर लागू किया जाता है और रोटेशन के अक्ष के लिए लगाए गए बल की दूरी r होती है
def cal_torque(force:float,theta:float,r:float)->float:
    import math
    return force*r*math.sin(theta)

# रेडियन इकाई में तय की गई अधिक दूरी और लिए गए समय के आधार पर कोणीय वेग वापस करने के लिए एक फ़ंक्शन लिखें
def cal_angular_velocity(angular_dist:float,time:float)->float:
    return angular_dist/time

# लेंस की फोकल लंबाई की गणना करने के लिए एक फ़ंक्शन लिखें, लेंस से वस्तु की दूरी और छवि की दूरी खरीदें
def cal_focal_length_of_lense(u:float,v:float)->float:
    return (u*v)/(u+v)

# द्रव्यमान m1 और m2 की दो वस्तुओं के बीच गुरुत्वाकर्षण बल और उनके बीच r की दूरी की गणना करने के लिए एक फ़ंक्शन लिखें
def cal_gforce(mass1:float,mass2:float, distance:float)->float:
    g = 6.674*(10)**(-11)
    return (g*mass1*mass2)/(distance**2)

# उस धारा में धारा की गणना करने के लिए एक फ़ंक्शन लिखें जहां प्रतिरोध R है और वोल्टेज V है
def cal_current(resistance:float, voltage:float)->float:
    return voltage/resistance

# किसी दी गई सूची में समानांतर में कैपेसिटर की कुल समाई की गणना करने के लिए एक फ़ंक्शन लिखें
def cal_total_cap_in_parallel(cap_list:list)->float:
    return sum(cap_list)

# दी गई सूची में समानांतर में प्रतिरोधों के कुल प्रतिरोध की गणना करने के लिए एक फ़ंक्शन लिखें
def cal_total_res_in_parallel(res_list:list)->float:
    return sum([1/r for r in res_list])

# किसी दी गई सूची में श्रृंखला में प्रतिरोधों के कुल प्रतिरोध की गणना करने के लिए एक फ़ंक्शन लिखें
def cal_total_res_in_series(res_list:list)->float:
    return sum(res_list)

# द्रव्यमान M और त्रिज्या R की एक अंगूठी की जड़ता के क्षण की गणना करने के लिए एक फ़ंक्शन लिखें
def cal_mi_ring(mass:float,radius:float)->float:
    return mass*(radius**2)


# द्रव्यमान M और त्रिज्या R के गोले की जड़ता के क्षण की गणना करने के लिए एक फ़ंक्शन लिखें
def cal_mi_sphere(mass:float,radius:float)->float:
    return (7/5)*mass*(radius**2)


# आदर्श गैस समीकरण के आधार पर आदर्श गैस के दबाव P की गणना करने के लिए एक फ़ंक्शन लिखें - आयतन V और तापमान T दिए गए हैं
def find_pressure_of_ideal_gas(volume:float, temp:float,n:float)->float:
    r = 8.3145 # gas constant R
    return (n*r*temp)/volume

# दिए गए आदर्श गैस समीकरण दाब P तथा तापमान T के आधार पर आदर्श गैस के आयतन V की गणना करने के लिए एक फ़ंक्शन लिखिए
def find_volume_of_ideal_gas(pressure:float, temp:float,n:float)->float:
    r = 8.3145 # gas constant R
    return (n*r*temp)/pressure

# दिए गए आदर्श गैस समीकरण दाब P और आयतन V के आधार पर आदर्श गैस के तापमान T की गणना करने के लिए एक फ़ंक्शन लिखें

def find_temp_of_ideal_gas(pressure:float, volume:float,n:float)->float:
    r = 8.3145 # gas constant R
    return (pressure*volume)/n*r

# किसी वस्तु के प्रारंभिक वेग u, समय t और त्वरण a के साथ वेग की गणना करने के लिए एक फ़ंक्शन लिखें
def cal_final_velocity(initial_velocity:float,accelration:float,time:float)->float:
    return initial_velocity + accelration*time

# किसी वस्तु के प्रारंभिक वेग u, समय t और त्वरण a के साथ विस्थापन की गणना करने के लिए एक फ़ंक्शन लिखें
def cal_displacement(initial_velocity:float,accelration:float,time:float)->float:
    return initial_velocity*time + .5*accelration*(time)**2

# प्रारंभिक मात्रा और आधा जीवन के आधार पर शेष रेडियोधर्मी तत्व की मात्रा की गणना करने के लिए एक फ़ंक्शन लिखें
def cal_half_life(initail_quatity:float, time_elapsed:float, half_life:float)->float:
    return initail_quatity*((1/2)**(time_elapsed/half_life))

# छूट प्रतिशत के आधार पर नए विक्रय मूल्य की गणना करने के लिए एक फ़ंक्शन लिखें
def cal_sp_after_discount(sp:float,discount:float)->float:
    return sp*(1 - discount/100)

# वर्ष y में मूलधन p, दर r और समय के लिए साधारण ब्याज की गणना करने के लिए एक फ़ंक्शन लिखें
def get_si(p:float, r:float, t:float)->float:
    return (p*r*t)/100

# वर्ष y में मूलधन p, दर r और समय के लिए चक्रवृद्धि ब्याज की गणना करने के लिए एक फ़ंक्शन लिखें
def get_ci(p:float, r:float, t:float, n:float)->float:
    return round(p*((1+(r/(n*100)))**(n*t)) - p,2)

# द्रव्यमान m को kg में ऊर्जा में परिवर्तित करने पर निर्मुक्त ऊर्जा की गणना करने के लिए एक फ़ंक्शन लिखिए
def cal_energy_by_mass(mass:float)->float:
    c = 300000
    return mass * (c**2)

# द्रव्यमान m और वेग v की वस्तु की गतिज ऊर्जा की गणना करने के लिए एक फ़ंक्शन लिखें
def cal_ke(mass:float,velocity:float)->float:
    return (mass*(velocity)**2)/2

# ऊँचाई h पर m द्रव्यमान की वस्तु की स्थितिज ऊर्जा की गणना करने के लिए एक फलन लिखिए
def cal_pe(mass:float,height:float)->float:
    g = 9.8
    return (mass*g*height)

# d दूरी पर q1 और q2 आवेश वाले दो आवेशित कणों के बीच इलेक्ट्रोस्टैटिक बल की गणना करने के लिए एक फ़ंक्शन लिखें
def cal_electrostatic_force(q1,q2,d):
    k = 9*(10**9)
    return (k*q1*q2)/(d**2)

# दिए गए द्रव्यमान और आयतन के घनत्व की गणना करने के लिए एक फ़ंक्शन लिखें
def cal_density(mass,volume):
    return (mass/volume)

# तापमान सेल्सियस c को फ़ारेनहाइट f या फ़ारेनहाइट को सेल्सियस में बदलने के लिए एक फ़ंक्शन लिखें
 def temp_converter(temp,temp_given_in = 'f'):
    # Return the converted temprature
    if temp_given_in.lower() == 'f': # Convert to C
        return (temp - 32) * (5/9)
    else: # Convert to F
        return (temp * 9/5) + 32



# पायथन कोड शब्दकोशों को मर्ज करने के लिए
def merge1():
    test_list1 = [{"a": 1, "b": 4}, {"c": 10, "d": 15},
                  {"f": "gfg"}]
    test_list2 = [{"e": 6}, {"f": 3, "fg": 10, "h": 1},
                  {"i": 10}]
    print("The original list 1 is : " + str(test_list1))
    print("The original list 2 is : " + str(test_list2))
    for idx in range(0, len(test_list1)):
        id_keys = list(test_list1[idx].keys())
        for key in test_list2[idx]:

            if key not in id_keys:
                test_list1[idx][key] = test_list2[idx][key]

    print("The Merged Dictionary list : " + str(test_list1))



# मैट्रिक्स के लंबवत संयोजन के लिए पायथन प्रोग्राम
def vertical_concatenation():
    test_list = [["this","is"], ["program", "for"], ["vertical","concatenation"]]
    print("The original list : " + str(test_list))
    res = []
    N = 0
    while N != len(test_list):
        temp = ''
        for idx in test_list:
            try: temp = temp + idx[N]
            except IndexError: pass
        res.append(temp)
        N = N + 1
    res = [ele for ele in res if ele]
    print("List after column Concatenation : " + str(res))
vertical_concatenation()


# मैट्रिक्स का Kth कॉलम प्राप्त करने के लिए पायथन कोड

def kth_column(test_list=[[4, 5, 6], [8, 1, 10], [7, 12, 5]],k=2):

    print("The original list is : " + str(test_list))
    K =k
    res = list(zip(*test_list)[K])
    print("The Kth column of matrix is : " + str(res))


# पुनरावर्तन का उपयोग करके सभी संभावित उपसरणियों को प्रिंट करने के लिए पायथन कोड

def printSubArrays(arr, start, end):
    if end == len(arr):
        return
    elif start > end:
        return printSubArrays(arr, 0, end + 1)
    else:
        print(arr[start:end + 1])
        return printSubArrays(arr, start + 1, end)

arr = [1, 2, 3]
printSubArrays(arr, 0, 0)

# पुनरावर्तन का उपयोग करके नेस्टेड सूची का योग खोजने के लिए पायथन प्रोग्राम
total = 0
def sum_nestedlist(l):
    global total
    for j in range(len(l)):
        if type(l[j]) == list:

            sum_nestedlist(l[j])
        else:
            total += l[j]

sum_nestedlist([[1, 2, 3], [4, [5, 6]], 7])
print(total)

# पायथन प्रोग्राम रिकर्सन का उपयोग करके संख्या की शक्ति खोजने के लिए
def power(N, P):
    if (P == 0 or P == 1):
        return N
    else:
        return (N * power(N, P - 1))

print(power(5, 2))


# विशिष्ट स्थान पर सबस्ट्रिंग के साथ फ़िल्टर स्ट्रिंग के लिए पायथन कार्यक्रम
def f_substring():
    test_list = ['program ', 'to', 'filter', 'for', 'substring']
    print("The original list is : " + str(test_list))
    sub_str = 'geeks'
    i, j = 0, 5
    res = list(filter(lambda ele: ele[i: j] == sub_str, test_list))
    print("Filtered list : " + str(res))


# पायथन कोड स्ट्रिंग से विराम चिह्न को दूर करने के लिए
def r_punc():
    test_str = "end, is best : for ! Nlp ;"
    print("The original string is : " + test_str)
    punc = '''!()-[]{};:'"\, <>./?@#$%^&*_~'''
    for ele in test_str:
        if ele in punc:
            test_str = test_str.replace(ele, "")
    print("The string after punctuation filter : " + test_str)


htness_4


# ग्नोम सॉर्ट को लागू करने के लिए पायथन प्रोग्राम
def gnomeSort(arr, n):
    index = 0
    while index < n:
        if index == 0:
            index = index + 1
        if arr[index] >= arr[index - 1]:
            index = index + 1
        else:
            arr[index], arr[index - 1] = arr[index - 1], arr[index]
            index = index - 1
    return arr
arr = [34, 2, 10, -9]
n = len(arr)
arr = gnomeSort(arr, n)
print("Sorted seqquence after applying Gnome Sort :")
for i in arr:
    print(i)


# पिजनहोल सॉर्ट लागू करने के लिए पायथन प्रोग्राम
def pigeonhole_sort(a):
    my_min = min(a)
    my_max = max(a)
    size = my_max - my_min + 1
    holes = [0] * size
    for x in a:
        assert type(x) is int, "integers only please"
        holes[x - my_min] += 1
    i = 0
    for count in range(size):
        while holes[count] > 0:
            holes[count] -= 1
            a[i] = count + my_min
            i += 1
a = [8, 3, 2, 7, 4, 6, 8]
print("Sorted order is : ", end=" ")
pigeonhole_sort(a)
for i in range(0, len(a)):
    print(a[i], end=" ")



# स्टोगे सॉर्ट को लागू करने के लिए पायथन प्रोग्राम
def stoogesort(arr, l, h):
    if l >= h:
        return
    if arr[l] > arr[h]:
        t = arr[l]
        arr[l] = arr[h]
        arr[h] = t
    if h - l + 1 > 2:
        t = (int)((h - l + 1) / 3)
        stoogesort(arr, l, (h - t))
        stoogesort(arr, l + t, (h))
        stoogesort(arr, l, (h - t))

arr = [2, 4, 5, 3, 1]
n = len(arr)
stoogesort(arr, 0, n - 1)
for i in range(0, n):
    print(arr[i], end= \' \')

# पायथन प्रोग्राम दो समय के बीच अंतर खोजने के लिए

def difference(h1, m1, h2, m2):

    t1 = h1 * 60 + m1
    t2 = h2 * 60 + m2
    if (t1 == t2):
        print("Both are same times")
        return
    else:
        diff = t2 - t1
    h = (int(diff / 60)) % 24
    m = diff % 60
    print(h, ":", m)
difference(7, 20, 9, 45)
difference(15, 23, 18, 54)
difference(16, 20, 16, 20)


# समय को 12 घंटे से 24 घंटे के प्रारूप में बदलने के लिए पायथन प्रोग्राम
def convert24(str1):
    if str1[-2:] == "AM" and str1[:2] == "12":
        return "00" + str1[2:-2]
    elif str1[-2:] == "AM":
        return str1[:-2]

    elif str1[-2:] == "PM" and str1[:2] == "12":
        return str1[:-2]
    else:
        return str(int(str1[:2]) + 12) + str1[2:8]
print(convert24("08:05:45 PM"))


# किसी दिए गए कोण के लिए समय खोजने के लिए पायथन 3 प्रोग्राम।

def calcAngle(hh, mm):
    hour_angle = 0.5 * (hh * 60 + mm)
    minute_angle = 6 * mm
    angle = abs(hour_angle - minute_angle)
    angle = min(360 - angle, angle)
    return angle


# अजगर फ़ंक्शन हर समय प्रिंट करने के लिए जब घंटे हाथ और मिनट के बीच का कोण
def printTime(theta):
    for hh in range(0, 12):
        for mm in range(0, 60):
            if (calcAngle(hh, mm) == theta):
                print(hh, ":", mm, sep="")
                return
    print("Input angle not valid.")
    return
theta = 90.0
printTime(theta)

# किसी फ़ंक्शन को कॉल करने की संख्या की गणना करने के लिए एक पायथन फ़ंक्शन लिखें
def counter(fn):
    count = 0
    def inner(*args, **kwargs):
        nonlocal count
        count += 1
        print(f'Function {fn.__name__} was called {count} times.')
        return fn(*"args, **kwargs)    
    return inner

# सूची से डुप्लिकेट आइटम निकालने के लिए एक पायथन फ़ंक्शन लिखें
def remove_duplicatesinlist(lst):
    return len(lst) == len(set(lst))

# उपयोगकर्ता द्वारा दिए गए फ़ंक्शन को निष्पादित करने में कितना समय लगता है, यह जानने के लिए एक पायथन डेकोरेटर फ़ंक्शन लिखें
def timed(fn):
    from time import perf_counter
    from functools import wraps

    @wraps(fn) 
    def inner(*args, **kwargs):
        start = perf_counter()
        result = fn(*args, **kwargs)
        end = perf_counter()
        elapsed = end - start

        args_ = [str(a) for a in args]
        kwargs_ = ['{0}={1}'.format(k, v) for k, v in kwargs.items()]
        all_args = args_ + kwargs_
        args_str = ','.join(all_args) # now it is comma delimited

        print(f'{fn.__name__}({args_str}) took {elapsed} seconds')

        return result
    # inner = wraps(fn)(inner)
    return inner

# मानचित्र का उपयोग करके दो उपयोगकर्ता परिभाषित सूची को जोड़ने और प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
input_string = input("Enter a list element separated by space ")
list1  = input_string.split()
input_string = input("Enter a list element separated by space ")
list2  = input_string.split()
list1 = [int(i) for i in list1] 
list2 = [int(i) for i in list2] 
result = map(lambda x, y: x + y, list1, list2) 
print(list(result))

# तारों की सूची को पूर्णांकों की सूची में बदलने के लिए एक पायथन फ़ंक्शन लिखें
def stringlist_to_intlist(sList): 
  return(list(map(int, sList)))

# ज़िप का उपयोग करके एकाधिक सूचियों को मैप करने के लिए एक पायथन फ़ंक्शन लिखें
def map_values(*args):
  return set(zip(*args))

# उपज का उपयोग करके संख्याओं के अनंत वर्ग उत्पन्न करने के लिए पायथन में जेनरेटर फ़ंक्शन लिखें
def nextSquare(): 
    i = 1;  
    # An Infinite loop to generate squares  
    while True: 
        yield i*i                 
        i += 1

# फाइबोनैचि संख्या उत्पन्न करने के लिए एक पायथन जनरेटर फ़ंक्शन लिखें
def fib(limit): 
    # Initialize first two Fibonacci Numbers  
    a, b = 0, 1  
    # One by one yield next Fibonacci Number 
    while a < limit: 
        yield a 
        a, b = b, a + b

# एक पायथन प्रोग्राम लिखें जो उपयोगकर्ता इनपुट टपल लेता है और प्रत्येक टपल तत्व की लंबाई प्रिंट करता है
userInput = input("Enter a tuple:")
x = map(lambda x:len(x), tuple(x.strip() for x in userInput.split(',')))
print(list(x))

# सूची में सम संख्याओं को खोजने के लिए सूची समझ का उपयोग करके एक पायथन फ़ंक्शन लिखें
def find_evennumbers(input_list):
  list_using_comp = [var for var in input_list if var % 2 == 0] 
  return list_using_comp

# ज़िप का उपयोग करके दो सूचियों का शब्दकोश वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def dict_using_comp(list1, list2):
  dict_using_comp = {key:value for (key, value) in zip(list1, list2)} 
  return dict_using_comp

# Google अपवित्रता URL से अपवित्रता वाले शब्दों की सूची प्राप्त करने के लिए एक फ़ंक्शन लिखें
def profanitytextfile():
    url = "https://github.com/RobertJGabriel/Google-profanity-words/blob/master/list.txt"
    html = urlopen(url).read()
    soup = BeautifulSoup(html, features="html.parser")

    textlist = []
    table = soup.find('table')
    trs = table.find_all('tr')
    for tr in trs:
        tds = tr.find_all('td')
        for td in tds:
            textlist.append(td.text)
    return textlist

# एक स्ट्रिंग में सबसे बड़ा अक्षर खोजने के लिए एक पायथन प्रोग्राम लिखें
bigChar = lambda word: reduce(lambda x,y: x if ord(x) > ord(y) else y, word)

# heap का उपयोग करके सूची को सॉर्ट करने के लिए एक पायथन फ़ंक्शन लिखें
def heapsort(iterable):
    from heapq import heappush, heappop
    h = []
    for value in iterable:
        heappush(h, value)
    return [heappop(h) for i in range(len(h))]

# सूची के रूप में पुनरावर्तनीय के पहले n आइटम वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def take(n, iterable):    
    import itertools
    return list(itertools.islice(iterable, n))

# एक पुनरावर्तक के सामने एक एकल मान को आगे बढ़ाने के लिए एक पायथन फ़ंक्शन लिखें
def prepend(value, iterator):    
    import itertools
    return itertools.chain([value], iterator)

# पिछले एन आइटम पर एक पुनरावर्तक वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def tail(n, iterable):    
    from collections import deque
    return iter(deque(iterable, maxlen=n))

# पुनरावर्तक n चरणों को आगे बढ़ाने के लिए एक पायथन फ़ंक्शन लिखें
def consume(iterator, n=None):
    import itertools
    from collections import deque
    "Advance the iterator n-steps ahead. If n is None, consume entirely."
    # Use functions that consume iterators at C speed.
    if n is None:
        # feed the entire iterator into a zero-length deque
        deque(iterator, maxlen=0)
    else:
        # advance to the empty slice starting at position n
        next(itertools.islice(iterator, n, n), None)

# nth आइटम या डिफ़ॉल्ट मान वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def nth(iterable, n, default=None):
    from itertools import islice
    return next(islice(iterable, n, None), default)

# यह जांचने के लिए कि क्या सभी तत्व एक दूसरे के बराबर हैं, एक पायथन फ़ंक्शन लिखें
def all_equal(iterable):
    from itertools import groupby
    g = groupby(iterable)
    return next(g, True) and not next(g, False)

# भविष्यवाणी कितनी बार सत्य है, यह गिनने के लिए एक पायथन फ़ंक्शन लिखें
def quantify(iterable, pred=bool):
    return sum(map(pred, iterable))

# अंतर्निहित map() फ़ंक्शन के व्यवहार का अनुकरण करने के लिए एक पायथन फ़ंक्शन लिखें
def pad_none(iterable):
    """Returns the sequence elements and then returns None indefinitely.

    Useful for emulating the behavior of the built-in map() function.
    """
    from itertools import chain, repeat
    return chain(iterable, repeat(None))

# अनुक्रम तत्वों को n बार वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def ncycles(iterable, n):
    from itertools import chain, repeat
    return chain.from_iterable(repeat(tuple(iterable), n))

# दो वैक्टरों के डॉट उत्पाद को वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def dotproduct(vec1, vec2):
    return sum(map(operator.mul, vec1, vec2))

# नेस्टिंग के एक स्तर को समतल करने के लिए एक पायथन फ़ंक्शन लिखें
def flatten(list_of_lists):
    from itertools import chain
    return chain.from_iterable(list_of_lists)

# निर्दिष्ट तर्कों के साथ कार्य करने के लिए कॉल दोहराने के लिए एक पायथन फ़ंक्शन लिखें
def repeatfunc(func, times=None, *args):
    from itertools import starmap, repeat
    if times is None:
        return starmap(func, repeat(args))
    return starmap(func, repeat(args, times))

# पुनरावर्तनीय को जोड़ीदार पुनरावर्तनीय में बदलने के लिए एक पायथन फ़ंक्शन लिखें
def pairwise(iterable):
    from itertools import tee
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)

# निश्चित-लंबाई वाले हिस्सों या ब्लॉकों में डेटा एकत्र करने के लिए एक पायथन फ़ंक्शन लिखें
def grouper(iterable, n, fillvalue=None):
    from itertools import zip_longest
    # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)

# राउंड रॉबिन एल्गोरिदम बनाने के लिए एक पायथन प्रोग्राम लिखें: "राउंडरोबिन ('ABC', 'D', 'EF') --> A D E B F C"
def roundrobin(*iterables):    
    from itertools import islice, cycle
    # Recipe credited to George Sakkis
    num_active = len(iterables)
    nexts = cycle(iter(it).__next__ for it in iterables)
    while num_active:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            # Remove the iterator we just exhausted from the cycle.
            num_active -= 1
            nexts = cycle(islice(nexts, num_active))

# एक विधेय का उपयोग करने के लिए एक पायथन फ़ंक्शन लिखें और प्रविष्टियों को झूठी प्रविष्टियों और सच्ची प्रविष्टियों में वापस करें
def partition(pred, iterable):
    from itertools import filterfalse, tee
    # partition(is_odd, range(10)) --> 0 2 4 6 8   and  1 3 5 7 9
    t1, t2 = tee(iterable)
    return filterfalse(pred, t1), filter(pred, t2)

# पुनरावर्तनीय के पावरसेट को वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def powerset(iterable):
    "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    from itertools import chain, combinations
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

list(powerset([1,2,3]))

# आदेश को संरक्षित करते हुए सभी अद्वितीय तत्वों को सूचीबद्ध करने के लिए एक पायथन फ़ंक्शन लिखें
def unique_everseen(iterable, key=None):
    from itertools import filterfalse
    # unique_everseen('AAAABBBCCDAABBB') --> A B C D
    # unique_everseen('ABBCcAD', str.lower) --> A B C D
    seen = set()
    seen_add = seen.add
    if key is None:
        for element in filterfalse(seen.__contains__, iterable):
            seen_add(element)
            yield element
    else:
        for element in iterable:
            k = key(element)
            if k not in seen:
                seen_add(k)
                yield element

# अद्वितीय तत्वों को सूचीबद्ध करने के लिए एक पायथन फ़ंक्शन लिखें, केवल देखे गए तत्व को याद रखने के आदेश को संरक्षित करें।"
def unique_justseen(iterable, key=None):
    import operator
    from itertools import groupby    
    # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B
    # unique_justseen('ABBCcAD', str.lower) --> A B C A D
    return map(next, map(operator.itemgetter(1), groupby(iterable, key)))

# एक अपवाद उठाए जाने तक बार-बार फ़ंक्शन को कॉल करने के लिए एक पायथन फ़ंक्शन लिखें।
def iter_except(func, exception, first=None):
    """Converts a call-until-exception interface to an iterator interface.
    Like builtins.iter(func, sentinel) but uses an exception instead
    of a sentinel to end the loop.
    Examples:
        iter_except(s.pop, KeyError)                             # non-blocking set iterator
    """
    try:
        if first is not None:
            yield first()            # For database APIs needing an initial cast to db.first()
        while True:
            yield func()
    except exception:
        pass

# itertools.product(*args, **kwds) से यादृच्छिक चयन वापस करने के लिए एक अजगर फ़ंक्शन लिखें
def random_product(*args, repeat=1):
    import random
    pools = [tuple(pool) for pool in args] * repeat
    return tuple(map(random.choice, pools))

# itertools.permutations (पुनरावृत्ति, आर) से यादृच्छिक चयन वापस करने के लिए एक अजगर समारोह लिखें
def random_permutation(iterable, r=None):
    import random
    pool = tuple(iterable)
    r = len(pool) if r is None else r
    return tuple(random.sample(pool, r))

# itertools.combinations (पुनरावृत्ति, आर) से यादृच्छिक चयन के लिए एक पायथन फ़ंक्शन लिखें
def random_combination(iterable, r):
    import random
    pool = tuple(iterable)
    n = len(pool)
    indices = sorted(random.sample(range(n), r))
    return tuple(pool[i] for i in indices)

# itertools.combinations_with_replacement(iterable, r) से यादृच्छिक चयन करने के लिए एक अजगर फ़ंक्शन लिखें
def random_combination_with_replacement(iterable, r):
    import random
    pool = tuple(iterable)
    n = len(pool)
    indices = sorted(random.choices(range(n), k=r))
    return tuple(pool[i] for i in indices)

# एक्स के बराबर सबसे बाएं मान का पता लगाने के लिए एक पायथन फ़ंक्शन लिखें
def index(a, x):
    from bisect import bisect_left    
    i = bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    raise ValueError

# x से कम सही मूल्य का पता लगाने के लिए एक पायथन फ़ंक्शन लिखें
def find_lt(a, x):
    from bisect import bisect_left  
    i = bisect_left(a, x)
    if i:
        return a[i-1]
    raise ValueError

# x से कम या उसके बराबर सही मूल्य खोजने के लिए एक पायथन फ़ंक्शन लिखें
def find_le(a, x):
    from bisect import bisect_right  
    i = bisect_right(a, x)
    if i:
        return a[i-1]
    raise ValueError

# x से अधिक बाईं ओर का मान खोजने के लिए एक पायथन फ़ंक्शन लिखें
def find_gt(a, x):
    from bisect import bisect_right 
    i = bisect_right(a, x)
    if i != len(a):
        return a[i]
    raise ValueError

# x के बराबर या उससे अधिक बाईं ओर आइटम खोजने के लिए एक पायथन फ़ंक्शन लिखें
def find_ge(a, x):
    from bisect import bisect_left 
    i = bisect_left(a, x)
    if i != len(a):
        return a[i]
    raise ValueError

# bisect का उपयोग करके एक न्यूमेरिक लुकअप को मैप करने के लिए एक पायथन फ़ंक्शन लिखें
def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
    from bisect import bisect
    i = bisect(breakpoints, score)
    return grades[i]

# उपयोगकर्ता इनपुट टेक्स्ट में सभी क्रियाओं और उनकी स्थिति को मुद्रित करने के लिए पायथन में एक रेगेक्स पैटर्न लिखें
import re
text = input("Enter a string: ")
for m in re.finditer(r"\w+ly", text):
    print('%02d-%02d: %s' % (m.start(), m.end(), m.group(0)))

# एक सीएसवी फ़ाइल पढ़ने और उसकी सामग्री को प्रिंट करने के लिए एक पायथन फ़ंक्शन लिखें
def read_csv(filename):
    import csv
    with open(filename, newline='') as f:
        reader = csv.reader(f)
        for row in reader:
            print(row)

# सूची को अनुक्रमित टपल में बदलने के लिए एक पायथन स्निपेट लिखें
test_list = [4, 5, 8, 9, 10] 
list(zip(range(len(test_list)), test_list))

# शब्द को वर्णों में विभाजित करने के लिए एक पायथन फ़ंक्शन लिखें
def split(word): 
    return [char for char in word]

# फ़ाइल में डेटा लेने के लिए एक पायथन फ़ंक्शन लिखें
def pickle_data(data, pickle_file):
  import pickle
  with open(pickle_file, 'wb') as f:
      pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)
  return None

# फ़ाइल से अचार डेटा लोड करने के लिए एक पायथन फ़ंक्शन लिखें
def load_pickle_data(pickle_file):
  import pickle
  with open(pickle_file, 'rb') as f:
      data = pickle.load(f)
  return data

# एक फ़ंक्शन लिखें जो 2 पुनरावृत्त a और b जोड़ता है जैसे कि a सम है और b विषम है
def add_even_odd_list(l1:list,l2:list)-> list:
    return [a+b for a,b in zip(l1,l2) if a%2==0 and b%2!=0]

# एक फ़ंक्शन लिखें जो प्रत्येक स्वर को प्रदान की गई स्ट्रिंग से अलग करता है
def strip_vowels(input_str:str)->str:

    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' ]
    return ''.join(list(filter(lambda x: x not in vowels, input_str)))

# एक फ़ंक्शन लिखें जो 1D सरणी के लिए ReLU फ़ंक्शन की तरह कार्य करता है
def relu_list(input_list:list)->list:
    return [(lambda x: x if x >= 0 else 0)(x) for x in input_list]

# एक ऐसा फंक्शन लिखें जो संख्या का फैक्टोरियल उत्पन्न करता है
def factorial(n):
    if n == 0 or n ==1:
        return 1
    else:
        return n*factorial(n-1)

# एक फ़ंक्शन लिखें जो सूची की लंबाई लौटाता है

def list_length(l):
    return len(l)

# एक फ़ंक्शन लिखें जो संख्याओं की सूची को सॉर्ट करता है और शीर्ष तत्व लौटाता है

def biggest_no(l:list)->int:
    sorted(l)

# एक स्ट्रिंग को n बार दोहराकर प्रिंट करने के लिए एक फंक्शन लिखें

def print_repeatnstring(text:str, n:int)-> str:
    return text*n

# दो सूचियों को एलिमेंट के अनुसार मर्ज करने के लिए एक फंक्शन लिखें

def merge_lists(l1:list, l2:list):
    return list(zip(l1,l2))

# दो सूचियों को जोड़ने के लिए एक फंक्शन लिखें

def append_lists(l1:list, l2:list)->list:
    return l1.extend(l2)

# सूची के विपरीत लौटने के लिए एक फ़ंक्शन लिखें

def reverse_list(l1:list)->list:
    return l1[::-1]

# तत्ववार दो सूचियों को जोड़ने के लिए एक फ़ंक्शन लिखें
def adds_listelements(l1:list, l2:list):
    return [i+j for i, j in zip(l1,l2)]

# तत्व के अनुसार दो सूचियों को घटाने के लिए एक फ़ंक्शन लिखें
def sub_listelements(l1:list, l2:list):
    return [i-j for i, j in zip(l1,l2)]

# दो सूचियों को तत्व के अनुसार जोड़ने के लिए एक फ़ंक्शन लिखें, यदि संख्याएँ सम हों
def adds_listevenelements(l1:list, l2:list):
    return [i+j for i, j in zip(l1,l2) if i*j%2 == 0]

# संख्या विषम होने पर ही दो सूचियों को तत्ववार गुणा करने के लिए एक फ़ंक्शन लिखें
def adds_listoddelements(l1:list, l2:list):
    return [i*j for i, j in zip(l1,l2) if i*j%2 == 1]

# एक ऐसा फ़ंक्शन लिखें जो सूची के तत्वों को n शक्ति वाले तत्वों की सूची लौटाता है
def n_power(l1:list, power:int)->list:
    return [i**power for i in l1]


# फिबोनैकी श्रृंखला उत्पन्न करने वाला एक फ़ंक्शन लिखें
def Fibonacci(n:int)-> int:
    if n==1:
        fibonacci = 0
    elif n==2:
        fibonacci = 1
    else:
        fibonacci = Fibonacci(n-1) + Fibonacci(n-2)
    return fibonacci


# एक ऐसा फंक्शन लिखें जो इनपुट का साइन मान लौटाता है
def sin(x:float) -> float:
    import math
    return math.sin(x)

# एक ऐसा फ़ंक्शन लिखें जो इनपुट के साइन वैल्यू का डेरिवेटिव लौटाता है
def derivative_sin(x:float)-> float:
    import math
    return math.cos(x)

# एक ऐसा फंक्शन लिखें जो इनपुट का tan मान देता है
def tan(x:float) -> float:
    import math
    return math.tan(x)

# एक ऐसा फलन लिखिए जो इनपुट के tan मान का अवकलज लौटाता है
def derivative_tan(x:float)-> float:
    import math
    return (1/math.cos(x))**2


# एक फ़ंक्शन लिखें जो इनपुट का कोसाइन मान लौटाता है
def cos(x:float) -> float:
    import math
    return math.cos(x)

# एक फ़ंक्शन लिखें जो इनपुट के कोज्या मान का व्युत्पन्न लौटाता है
def derivative_cos(x:float)-> float:
    import math
    return -(math.sin(x))


# एक ऐसा फ़ंक्शन लिखें जो इनपुट के घातीय मान को लौटाता है
def exp(x) -> float:
    import math
    return math.exp(x)

# एक फ़ंक्शन लिखें जो x के घातांक का व्युत्पन्न प्राप्त करता है
def derivative_exp(x:float) -> float:
    import math
    return math.exp(x)


# एक फ़ंक्शन लिखें जो किसी फ़ंक्शन का लॉग लौटाता है
def log(x:float)->float:
    import math
    return math.log(x)

# एक फ़ंक्शन लिखें जो किसी फ़ंक्शन के लॉग का डेरिवेटिव लौटाता है
def derivative_log(x:float)->float:
    return (1/x)


# एक ऐसा फंक्शन लिखिए जो इनपुट का Relu मान लौटाता है
def relu(x:float) -> float:
    x = 0 if x < 0 else x
    return x

# एक ऐसा फ़ंक्शन लिखें जो इनपुट के डेरिवेटिव डेरिवेटिव रिले मान लौटाता है
def derivative_relu(x:float) -> float:
    x = 1 if x > 0 else 0
    return x


# एक ऐसा फ़ंक्शन लिखें जो कचरा कलेक्टर चलाता है
def clear_memory():
    import gc
    gc.collect()

# एक फ़ंक्शन लिखें जो किसी भी लेनदेन को करने के लिए लिए गए औसत समय की गणना करता है, फ़ंक्शन fn द्वारा पुनरावृत्तियों पर लेनदेन के लिए लिए गए कुल समय का औसत
def time_it(fn, *args, repetitons= 1, **kwargs):
    import time
    total_time = []

    for _ in range(repetitons):
        start_time = time.perf_counter()
        fn(*args,**kwargs)
        end_time = time.perf_counter()
        ins_time = end_time - start_time
        total_time.append(ins_time)
    return sum(total_time)/len(total_time)


# डिक्शनरी में वैल्यू मौजूद है या नहीं, यह पहचानने के लिए एक फंक्शन लिखें
def check_value(d:dict, value)->bool:
    return any(v == value for v in dict.values())

# एक शब्दकोश के अंदर किसी मान के उदाहरणों की संख्या की गणना करने के लिए पहचानने के लिए एक फ़ंक्शन लिखें
def count_value(d:dict, value)->bool:
    return list(v == value for v in dict.values()).count(True)

# किसी सूची के अंदर मूल्य मौजूद है या नहीं, यह पहचानने के लिए एक फ़ंक्शन लिखें
def check_listvalue(l:list, value)->bool:
    return value in l

# एक टपल के अंदर मान मौजूद है या नहीं, यह पहचानने के लिए एक फ़ंक्शन लिखें
def check_tuplevalue(l:tuple, value)->bool:
    return value in l

# एक फ़ंक्शन लिखें जो लोअरकेस स्ट्रिंग लौटाता है
def str_lowercase(s:str):
    return s.lower()

# एक फ़ंक्शन लिखें जो अपरकेस स्ट्रिंग लौटाता है
def str_uppercase(s:str):
    return s.upper()

# एक ऐसा फंक्शन लिखें जो सभी विशेष वर्णों को हटा दे
def clean_str(s):
    import re
    return re.sub('[^A-Za-z0-9]+', '', s)

# एक ऐसा फ़ंक्शन लिखें जो आरोही क्रमबद्ध सूची देता है
def ascending_sort(l:list):
    sorted(l, reverse=False)

# एक ऐसा फ़ंक्शन लिखें जो अवरोही क्रमबद्ध सूची देता है
def descending_sort(l:list):
    sorted(l, reverse=True)

# एक ऐसा फ़ंक्शन लिखें जो इसके मानों के आधार पर क्रमबद्ध एक शब्दकोश लौटाता है
def descending_dict_valuesort(d:dict):
    return {key: val for key, val in sorted(d.items(), reverse=True, key = lambda ele: ele[1])}

# एक ऐसा फ़ंक्शन लिखें जो इसके मानों के आधार पर एक शब्दकोश को आरोही क्रम में लौटाता है
def ascending_dict_valuesort(d:dict):
    return {key: val for key, val in sorted(d.items(), key = lambda ele: ele[1])}

# एक ऐसा फ़ंक्शन लिखें जो कुंजी द्वारा अवरोही क्रम में एक शब्दकोश लौटाता है
def descending_dict_keysort(d:dict):
    return {key: val for key, val in sorted(d.items(), reverse=True, key = lambda ele: ele[0])}

# एक ऐसा फ़ंक्शन लिखें जो कुंजी द्वारा आरोही क्रम में एक शब्दकोश लौटाता है
def ascending_dict_keysort(d:dict):
    return {key: val for key, val in sorted(d.items(), key = lambda ele: ele[0])}

# एक फ़ंक्शन लिखें जो प्रदान किए गए मानों के साथ स्ट्रिंग में मानों को प्रतिस्थापित करता है
def replace_values(s:str, old, new)->str:
    s.replace(old, new)

# एक फ़ंक्शन लिखें जो सूची के तत्वों में शामिल हो
def join_elements(l:list)-> str:
    return (''.join(str(l)))

# स्ट्रिंग के तत्वों को विभाजित करने वाला एक फ़ंक्शन लिखें
def split_elements(s:str, seperator)-> list:
    return s.split(seperator)

# एक फ़ंक्शन लिखें जो सूची में सभी तत्वों का योग लौटाता है
def sum_elements(l:list):
    return sum(l)

# एक फ़ंक्शन लिखें जो सूची में सभी सम तत्वों का योग लौटाता है
def sum_even_elements(l:list):
    return sum([i for i in l if i%2==0])

# एक फ़ंक्शन लिखें जो सूची में सभी विषम तत्वों का योग लौटाता है
def sum_odd_elements(l:list):
    return sum([i for i in l if i%2==1])

# किसी सूची को उल्टा करने के लिए एक प्रोग्राम लिखें
lst = [11, 5, 17, 18, 23]
def reverse(lst): 
    new_lst = lst[::-1] 
    return new_lst
	
# सूची में तत्वों का योग खोजने के लिए एक कार्यक्रम लिखें
list1 = [11, 5, 17, 18, 23]
total = sum(list1)
print("Sum of all elements in given list: ", total)

# किसी सूची में सबसे बड़ी संख्या ज्ञात करने के लिए एक प्रोग्राम लिखें
list1 = [10, 20, 4, 45, 99] 
list1.sort() 
print("Largest element is:", list1[-1]) 

# किसी सूची में सम संख्याओं को प्रिंट करने के लिए एक प्रोग्राम लिखें
list1 = [10, 21, 4, 45, 66, 93] 
for num in list1: 
    if num % 2 == 0: 
       print(num, end = " ") 
       
# दिए गए रेंज में नेगेटिव नंबर प्रिंट करने के लिए एक प्रोग्राम लिखें
start, end = -4, 19
for num in range(start, end + 1): 
    if num < 0: 
        print(num, end = " ") 
        
# सूची समझ का उपयोग करके सूची से खाली सूची को हटाने के लिए एक प्रोग्राम लिखें
test_list = [5, 6, [], 3, [], [], 9] 
print("The original list is : " + str(test_list)) 
res = [ele for ele in test_list if ele != []] 
print ("List after empty list removal : " + str(res)) 

# टुपल्स की सूची से खाली टुपल्स को हटाने के लिए एक प्रोग्राम लिखें
def Remove(tuples): 
    tuples = filter(None, tuples) 
    return tuples 
  
tuples = [(), ('ram','15','8'), (), ('laxman', 'sita'),  
          ('krishna', 'akbar', '45'), ('',''),()] 
print Remove(tuples)

# एक सूची को आकार N के टुकड़ों में तोड़ने के लिए एक प्रोग्राम लिखें
l = [1, 2, 3, 4, 5, 6, 7, 8, 9]  
n = 4 
x = [l[i:i + n] for i in range(0, len(l), n)]  
print(x)

# एक स्ट्रिंग में मौजूद शब्दों की आवृत्ति खोजने के लिए एक प्रोग्राम लिखें
  
test_str = 'times of india times new india express'
print("The original string is : " + str(test_str)) 

res = {key: test_str.count(key) for key in test_str.split()} 
print("The words frequency : " + str(res))

# एक स्ट्रिंग को स्वीकार करने के लिए एक प्रोग्राम लिखें यदि उसमें सभी स्वर हों
def check(string): 
  if len(set(string).intersection("AEIOUaeiou"))>=5: 
    return ('accepted') 
  else: 
    return ("not accepted") 
  
if __name__=="__main__": 
  string="helloworld"
  print(check(string)) 
  

# d लंबाई द्वारा स्ट्रिंग को बाएँ और दाएँ घुमाने के लिए एक प्रोग्राम लिखें
def rotate(input,d):  
  
    Lfirst = input[0 : d]  
    Lsecond = input[d :]  
    Rfirst = input[0 : len(input)-d]  
    Rsecond = input[len(input)-d : ]  
  
    print ("Left Rotation : ", (Lsecond + Lfirst) ) 
    print ("Right Rotation : ", (Rsecond + Rfirst))  
  
if __name__ == "__main__":  
    input = 'helloworld'
    d=2
    rotate(input,d) 
    

# की-वैल्यू लिस्ट को फ्लैट डिक्शनरी में बदलने के लिए एक प्रोग्राम लिखें

from itertools import product 
test_dict = {'month' : [1, 2, 3], 
             'name' : ['Jan', 'Feb', 'March']} 
  
print("The original dictionary is : " + str(test_dict)) 
  
res = dict(zip(test_dict['month'], test_dict['name'])) 
print("Flattened dictionary : " + str(res)) 

# डुप्लीकेट शब्दों को हटाने के लिए एक प्रोग्राम लिखें
s = "Hello world Hello"
l = s.split() 
k = [] 
for i in l: 
    if (s.count(i)>1 and (i not in k)or s.count(i)==1): 
        k.append(i) 
print(' '.join(k)) 


# शब्दकोश में बदलने के लिए एक प्रोग्राम लिखें
def Convert(tup, di): 
    for a, b in tup: 
        di.setdefault(a, []).append(b) 
    return di 
      
tups = [("A", 10), ("B", 20), ("C", 30),  
     ("D", 40), ("E", 50), ("F", 60)] 
dictionary = {} 
print (Convert(tups, dictionary)) 


# टपल सूची से अंक निकालने के लिए प्रोग्राम लिखें
from itertools import chain 
test_list = [(15, 3), (3, 9), (1, 10), (99, 2)] 
print("The original list is : " + str(test_list)) 
temp = map(lambda ele: str(ele), chain.from_iterable(test_list)) 
res = set() 
for sub in temp: 
    for ele in sub: 
        res.add(ele) 
print("The extrated digits : " + str(res))  

# सूची समझ का उपयोग करके K लंबाई के Tuples को निकालने के लिए एक प्रोग्राम लिखें
  
test_list = [(4, 5), (4, ), (8, 6, 7), (1, ), (3, 4, 6, 7)] 
print("The original list : " + str(test_list)) 
K = 1
res = [ele for ele in test_list if len(ele) != K] 
print("Filtered list : " + str(res)) 

# टपल में अधिकतम और न्यूनतम K तत्वों को खोजने के लिए एक प्रोग्राम लिखें
test_tup = (5, 20, 3, 7, 6, 8) 
print("The original tuple is : " + str(test_tup)) 
K = 2
test_tup = list(test_tup) 
temp = sorted(test_tup) 
res = tuple(temp[:K] + temp[-K:]) 
print("The extracted values : " + str(res))  

# वर्तमान दिनांक और समय प्राप्त करने के लिए एक प्रोग्राम लिखें
import datetime  
current_time = datetime.datetime.now()  
    
print ("Time now at greenwich meridian is : " , end = "")  
print (current_time)

# समय को 12 घंटे से 24 घंटे के प्रारूप में बदलने के लिए एक प्रोग्राम लिखें
  
def convert24(str1): 
      
    # Checking if last two elements of time 
    # is AM and first two elements are 12 
    if str1[-2:] == "AM" and str1[:2] == "12": 
        return "00" + str1[2:-2] 
          
    # remove the AM     
    elif str1[-2:] == "AM": 
        return str1[:-2] 
      
    # Checking if last two elements of time 
    # is PM and first two elements are 12    
    elif str1[-2:] == "PM" and str1[:2] == "12": 
        return str1[:-2] 
          
    else: 
          
        # add 12 to hours and remove PM 
        return str(int(str1[:2]) + 12) + str1[2:8] 
  
print(convert24("08:05:45 PM"))   

# दो बार के बीच अंतर खोजने के लिए एक प्रोग्राम लिखें
  
  
def difference(h1, m1, h2, m2): 
      
    # convert h1 : m1 into minutes 
    t1 = h1 * 60 + m1 
      
    # convert h2 : m2 into minutes  
    t2 = h2 * 60 + m2 
      
    if (t1 == t2):  
        print("Both are same times") 
        return 
    else: 
          
        # calculating the difference 
        diff = t2-t1 
          
    # calculating hours from difference 
    h = (int(diff / 60)) % 24
      
    # calculating minutes from difference 
    m = diff % 60
  
    print(h, ":", m) 
  

if __name__ == "__main__": 
      
    difference(7, 20, 9, 45) 
    difference(15, 23, 18, 54) 
    difference(16, 20, 16, 20) 
    
# कल, आज और आने वाले कल को खोजने के लिए कार्यक्रम लिखें
   
from datetime import datetime, timedelta 
  
  
presentday = datetime.now() # or presentday = datetime.today() 
  
yesterday = presentday - timedelta(1) 
  
tomorrow = presentday + timedelta(1) 
  
  
print("Yesterday = ", yesterday.strftime('%d-%m-%Y')) 
print("Today = ", presentday.strftime('%d-%m-%Y')) 
print("Tomorrow = ", tomorrow.strftime('%d-%m-%Y')) 

# संख्या और अक्षर को छोड़कर सभी वर्णों को हटाने के लिए एक प्रोग्राम लिखें
  
import re 
  
ini_string = "123abcjw:, .@! eiw"
  
	
print ("initial string : ", ini_string) 
  
result = re.sub('[\W_]+', '', ini_string) 
  
	
print ("final string", result) 

# update() विधि का उपयोग करके तानाशाही को मर्ज करने के लिए एक प्रोग्राम लिखें
def Merge(dict1, dict2):
    return(dict2.update(dict1))
     

dict1 = {'a': 10, 'b': 8}
dict2 = {'d': 6, 'c': 4}
 
print(Merge(dict1, dict2))
print(dict2)

# एक स्ट्रिंग में सम लंबाई के शब्दों को प्रिंट करने के लिए एक प्रोग्राम लिखें
  
def printWords(s): 
    s = s.split(' ')  
    for word in s:  
        if len(word)%2==0: 
            print(word)  

s = "hello world" 
printWords(s)

# एक स्ट्रिंग में सभी डुप्लिकेट अक्षरों को हटाने के लिए एक प्रोग्राम लिखें

def removeDuplicate(str): 
    s=set(str) 
    s="".join(s) 
    print("Without Order:",s) 
    t="" 
    for i in str: 
        if(i in t): 
            pass
        else: 
            t=t+i 
        print("With Order:",t) 
      
str="helloworld"
removeDuplicate(str) 

# स्ट्रिंग में अधिकतम आवृत्ति वर्ण मुद्रित करने के लिए एक प्रोग्राम लिखें
  
 
test_str = "Helloworld"
  
print ("The original string is : " + test_str) 
  
all_freq = {} 
for i in test_str: 
    if i in all_freq: 
        all_freq[i] += 1
    else: 
        all_freq[i] = 1
res = max(all_freq, key = all_freq.get)  
  
print ("The maximum of all characters in Helloworld is : " + str(res)) 

# यह जांचने के लिए एक प्रोग्राम लिखें कि स्ट्रिंग में कोई विशेष वर्ण है या नहीं
  
import re 
def run(string): 
  
    regex = re.compile('[@_!#$%^&*()<>?/\|}{~:]') 
      
    if(regex.search(string) == None): 
        print("String is accepted") 
          
    else: 
        print("String is not accepted.") 
      
  
if __name__ == '__main__' : 
      
    # Enter the string 
    string = "Hello@World"
      
    # calling run function  
    run(string) 
    
# एक स्ट्रिंग बाइनरी है या नहीं यह जांचने के लिए एक प्रोग्राम लिखें
def check(string) : 
    p = set(string) 
    s = {'0', '1'} 
    if s == p or p == {'0'} or p == {'1'}: 
        print("Yes") 
    else : 
        print("No") 
          
if __name__ == "__main__" : 
  
    string = "101010000111"
    check(string) 
   
# दी गई स्ट्रिंग हेटेरोग्राम है या नहीं, यह जांचने के लिए एक प्रोग्राम लिखें
  
def heterogram(input): 
  
     alphabets = [ ch for ch in input if ( ord(ch) >= ord('a') and ord(ch) <= ord('z') )] 
  
     if len(set(alphabets))==len(alphabets): 
         print ('Yes') 
     else: 
         print ('No') 
  
if __name__ == "__main__": 
    input = 'Hello World'
    heterogram(input) 

# यह जांचने के लिए एक प्रोग्राम लिखें कि दी गई कुंजी पहले से ही किसी शब्दकोश में मौजूद है या नहीं।
  
def checkKey(dict, key): 
      
    if key in dict.keys(): 
        print("Present, ", end =" ") 
        print("value =", dict[key]) 
    else: 
        print("Not present") 
  
dict = {'a': 100, 'b':200, 'c':300} 
  
key = 'b'
checkKey(dict, key) 
  
key = 'w'
checkKey(dict, key) 

# स्ट्रिंग पैलिंड्रोम है या नहीं, यह जांचने के लिए एक प्रोग्राम लिखें
def isPalindrome(s):
    return s == s[::-1]
s = "malayalam"
ans = isPalindrome(s)
 
if ans:
    print("Yes")
else:
    print("No")

# एक प्रोग्राम लिखें जो एक सूची से स्वर से शुरू होने वाले शब्दों को निकालता है

test_list = ["have", "a", "good", "one"] 
  
print("The original list is : " + str(test_list)) 
  
res = [] 
vow = "aeiou"
for sub in test_list: 
    flag = False
      
    # checking for begin char 
    for ele in vow: 
        if sub.startswith(ele): 
            flag = True 
            break
    if flag: 
        res.append(sub) 
  
print("The extracted words : " + str(res)) 

# सूची समझ + zip() का उपयोग करके स्वरों को अगले स्वर से बदलने के लिए एक कार्यक्रम लिखें
  
test_str = 'helloworld'
print("The original string is : " + str(test_str)) 
vow = 'a e i o u'.split() 
temp = dict(zip(vow, vow[1:] + [vow[0]])) 
res = "".join([temp.get(ele, ele) for ele in test_str]) 
print("The replaced string : " + str(res)) 

# स्ट्रिंग के शब्दों को उल्टा करने के लिए एक प्रोग्राम लिखें
  
def rev_sentence(sentence):  
    words = sentence.split(' ')  
    reverse_sentence = ' '.join(reversed(words))  
    return reverse_sentence  
  
if __name__ == "__main__":  
    input = 'have a good day'
    print (rev_sentence(input)) 
    
# स्ट्रिंग में कम से कम आवृत्ति वर्ण खोजने के लिए एक प्रोग्राम लिखें

test_str = "helloworld"
print ("The original string is : " + test_str) 
all_freq = {} 
for i in test_str: 
    if i in all_freq: 
        all_freq[i] += 1
    else: 
        all_freq[i] = 1
res = min(all_freq, key = all_freq.get)  
  
print ("The minimum of all characters in the given word is : " + str(res)) 

# एक सूची में सबसे लगातार तत्व खोजने के लिए एक प्रोग्राम लिखें
  
def most_frequent(List): 
    counter = 0
    num = List[0] 
      
    for i in List: 
        curr_frequency = List.count(i) 
        if(curr_frequency> counter): 
            counter = curr_frequency 
            num = i 
  
    return num 
  
List = [2, 1, 2, 2, 1, 3] 
print(most_frequent(List)) 

# प्रत्येक वर्ण जोड़े के बाद एक प्रोग्राम सम्मिलित वर्ण लिखें
  
test_str = "HellowWorld"

print("The original string is : " + test_str) 
res = ', '.join(test_str[i:i + 2] for i in range(0, len(test_str), 2)) 
 
print("The string after inserting comma after every character pair : " + res) 

# एक स्ट्रिंग से i-th अनुक्रमित वर्ण को हटाने के लिए एक प्रोग्राम लिखें
  
def remove(string, i):  
  
    a = string[ : i]  
    b = string[i + 1: ] 
    return a + b 
     
	
if __name__ == '__main__': 
      
    string = "HellowWorld"
      
    # Remove nth index element 
    i = 5
    
    # Print the new string 
    print(remove(string, i)) 

# एक स्ट्रिंग में कम से कम एक अक्षर और एक संख्या है या नहीं, यह जांचने के लिए एक प्रोग्राम लिखें
def checkString(str): 
    
    flag_l = False
    flag_n = False
      
    for i in str: 
        
        # if string has letter 
        if i.isalpha(): 
            flag_l = True
  
        # if string has number 
        if i.isdigit(): 
            flag_n = True
      
    return flag_l and flag_n 
  
  

print(checkString('helloworld')) 
print(checkString('helloworld2020'))

# एक कार्यक्रम लिखें कम से कम आवृत्ति तत्व निकालें

from collections import defaultdict 
test_list = [1, 3, 4, 5, 1, 3, 5] 
  
 
print("The original list : " + str(test_list)) 
  

res = defaultdict(int) 
for ele in test_list: 
   res[ele] += 1 
min_occ = 9999
for ele in res: 
    if min_occ > res[ele]: 
        min_occ = res[ele] 
        tar_ele = ele 
  

print("The minimum occurring element is : " + str(tar_ele)) 

# 2 सूचियों की जाँच करने के लिए एक प्रोग्राम लिखें और पता करें कि क्या कोई तत्व सामान्य है
  
def common_data(list1, list2): 
    result = False
  
    for x in list1: 
  
        # traverse in the 2nd list 
        for y in list2: 
    
            # if one common 
            if x == y: 
                result = True
                return result  
                  
    return result 
      

a = [1, 2, 3, 4, 5] 
b = [5, 6, 7, 8, 9] 
print(common_data(a, b)) 
  
a = [1, 2, 3, 4, 5] 
b = [6, 7, 8, 9] 
print(common_data(a, b)) 

# त्रिभुज का क्षेत्रफल ज्ञात करने के लिए एक प्रोग्राम लिखिए

a = float(input('Enter first side: '))  
b = float(input('Enter second side: '))  
c = float(input('Enter third side: '))  
  
s = (a + b + c) / 2  
  
area = (s*(s-a)*(s-b)*(s-c)) ** 0.5  
print('The area of the triangle is %0.2f' %area)   

# दो वेरिएबल्स को स्वैप करने के लिए एक प्रोग्राम लिखें
x = input('Enter value of x: ')  
y = input('Enter value of y: ')  
  
temp = x  
x = y  
y = temp  
 
print('The value of x after swapping: {}'.format(x))  
print('The value of y after swapping: {}'.format(y)) 

# किलोमीटर को मील में बदलने के लिए एक प्रोग्राम लिखें

kilometers = float(input('How many kilometers?: '))  
conv_fac = 0.621371  
miles = kilometers * conv_fac  
print('%0.3f kilometers is equal to %0.3f miles' %(kilometers,miles))  

# सेल्सियस को फारेनहाइट में बदलने के लिए एक प्रोग्राम लिखें

celsius = float(input('Enter temperature in Celsius: '))  
fahrenheit = (celsius * 1.8) + 32  
print('%0.1f  Celsius is equal to %0.1f degree Fahrenheit'%(celsius,fahrenheit))  

# कैलेंडर प्रदर्शित करने के लिए एक प्रोग्राम लिखें

import calendar  
yy = int(input("Enter year: "))  
mm = int(input("Enter month: "))  
  
print(calendar.month(yy,mm))  

# यह जाँचने के लिए एक प्रोग्राम लिखें कि क्या वर्ष लीप वर्ष है

year = int(input("Enter a year: "))  
if (year % 4) == 0:  
   if (year % 100) == 0:  
       if (year % 400) == 0:  
           print("{0} is a leap year".format(year))  
       else:  
           print("{0} is not a leap year".format(year))  
   else:  
       print("{0} is a leap year".format(year))  
else:  
   print("{0} is not a leap year".format(year))  
   
# संख्या एक अभाज्य संख्या है या नहीं, यह जांचने के लिए एक प्रोग्राम लिखें

num = int(input("Enter a number: "))  
  
if num > 1:  
   for i in range(2,num):  
       if (num % i) == 0:  
           print(num,"is not a prime number")  
           print(i,"times",num//i,"is",num)  
           break  
   else:  
       print(num,"is a prime number")  
         
else:  
   print(num,"is not a prime number")  
   
# अंतराल के बीच सभी अभाज्य संख्याओं को प्रिंट करने के लिए एक प्रोग्राम लिखें

lower = int(input("Enter lower range: "))  
upper = int(input("Enter upper range: "))  
  
for num in range(lower,upper + 1):  
   if num > 1:  
       for i in range(2,num):  
           if (num % i) == 0:  
               break  
       else:  
           print(num)  
           
# किसी संख्या का भाज्य ज्ञात करने के लिए एक प्रोग्राम लिखें

num = int(input("Enter a number: "))  
factorial = 1  
if num < 0:  
   print("Sorry, factorial does not exist for negative numbers")  
elif num == 0:  
   print("The factorial of 0 is 1")  
else:  
   for i in range(1,num + 1):  
       factorial = factorial*i  
   print("The factorial of",num,"is",factorial) 
   
# किसी संख्या की गुणन तालिका प्रदर्शित करने के लिए एक प्रोग्राम लिखें

num = int(input("Show the multiplication table of? "))  
	
for i in range(1,11):  
   print(num,'x',i,'=',num*i)  
   
# फाइबोनैचि अनुक्रम को प्रिंट करने के लिए एक प्रोग्राम लिखें

nterms = int(input("How many terms you want? "))  

n1 = 0  
n2 = 1  
count = 2  
if nterms <= 0:  
   print("Plese enter a positive integer")  
elif nterms == 1:  
   print("Fibonacci sequence:")  
   print(n1)  
else:  
   print("Fibonacci sequence:")  
   print(n1,",",n2,end=', ')  
   while count < nterms:  
       nth = n1 + n2  
       print(nth,end=' , ')  
       # update values  
       n1 = n2  
       n2 = nth  
       count += 1  
       
# आर्मस्ट्रांग नंबर की जांच के लिए एक प्रोग्राम लिखें

num = int(input("Enter a number: "))  
sum = 0  
temp = num  
  
while temp > 0:  
   digit = temp % 10  
   sum += digit ** 3  
   temp //= 10  
  
if num == sum:  
   print(num,"is an Armstrong number")  
else:  
   print(num,"is not an Armstrong number")  
   
# अन्तराल में आर्मस्ट्रांग संख्या ज्ञात करने के लिए एक प्रोग्राम लिखिए

lower = int(input("Enter lower range: "))  
upper = int(input("Enter upper range: "))  
  
for num in range(lower,upper + 1):  
   sum = 0  
   temp = num  
   while temp > 0:  
       digit = temp % 10  
       sum += digit ** 3  
       temp //= 10  
       if num == sum:  
            print(num)  
            
# प्राकृतिक संख्याओं का योग ज्ञात करने के लिए एक प्रोग्राम लिखें

num = int(input("Enter a number: "))  
  
if num < 0:  
   print("Enter a positive number")  
else:  
   sum = 0  
   # use while loop to iterate un till zero  
   while(num > 0):  
       sum += num  
       num -= 1  
   print("The sum is",sum)  

# एलसीएम खोजने के लिए एक कार्यक्रम लिखें

def lcm(x, y):  
   if x > y:  
       greater = x  
   else:  
       greater = y  
  while(True):  
       if((greater % x == 0) and (greater % y == 0)):  
           lcm = greater  
           break  
       greater += 1  
   return lcm  
  
  
num1 = int(input("Enter first number: "))  
num2 = int(input("Enter second number: "))  
print("The L.C.M. of", num1,"and", num2,"is", lcm(num1, num2)) 

# एचसीएफ खोजने के लिए एक कार्यक्रम लिखें

def hcf(x, y):  
   if x > y:  
       smaller = y  
   else:  
       smaller = x  
   for i in range(1,smaller + 1):  
       if((x % i == 0) and (y % i == 0)):  
           hcf = i  
   return hcf  
  
num1 = int(input("Enter first number: "))  
num2 = int(input("Enter second number: "))  
print("The H.C.F. of", num1,"and", num2,"is", hcf(num1, num2))  

# दशमलव को बाइनरी, ऑक्टल और हेक्साडेसिमल में बदलने के लिए एक प्रोग्राम लिखें
dec = int(input("Enter a decimal number: "))  
  
print(bin(dec),"in binary.")  
print(oct(dec),"in octal.")  
print(hex(dec),"in hexadecimal."  

# पायथन कार्यक्रम एक चरित्र के एएससीआई मूल्य खोजने के लिए

c = input("Enter a character: ")  
print("The ASCII value of '" + c + "' is",ord(c))

# एक साधारण कैलकुलेटर बनाने के लिए एक प्रोग्राम लिखें


def add(x, y):  
   """This function adds two numbers"""
   return x + y 
def subtract(x, y): 
   """This function subtracts two numbers""" 
   return x - y 
def multiply(x, y): 
   """This function multiplies two numbers""" 
   return x * y 
def divide(x, y): 
   """This function divides two numbers"""  
   return x / y  
print("Select operation.")  
print("1.Add")  
print("2.Subtract")  
print("3.Multiply")  
print("4.Divide")  
  
choice = input("Enter choice(1/2/3/4):")  
  
num1 = int(input("Enter first number: "))  
num2 = int(input("Enter second number: "))  
  
if choice == '1':  
   print(num1,"+",num2,"=", add(num1,num2))  
  
elif choice == '2':  
   print(num1,"-",num2,"=", subtract(num1,num2))  
  
elif choice == '3':  
   print(num1,"*",num2,"=", multiply(num1,num2))  
elif choice == '4':  
   print(num1,"/",num2,"=", divide(num1,num2))  
else:  
   print("Invalid input")    
   
# शब्दों को वर्णानुक्रम में क्रमबद्ध करने के लिए एक प्रोग्राम लिखें

my_str = input("Enter a string: ")  

words = my_str.split()  

words.sort()  

for word in words:  
   print(word)  
   
# नेस्टेड लूप का उपयोग करके दो मैट्रिसेस जोड़ने के लिए एक प्रोग्राम लिखें

X = [[12,7,3],
    [4 ,5,6],
    [7 ,8,9]]

Y = [[5,8,1],
    [6,7,3],
    [4,5,9]]

result = [[0,0,0],
         [0,0,0],
         [0,0,0]]

for i in range(len(X)):
   # iterate through columns
   for j in range(len(X[0])):
       result[i][j] = X[i][j] + Y[i][j]

for r in result:
   print(r)  

# नेस्टेड लूप का उपयोग करके मैट्रिक्स को स्थानांतरित करने के लिए एक प्रोग्राम लिखें

X = [[12,7],
    [4 ,5],
    [3 ,8]]

result = [[0,0,0],
         [0,0,0]]


for i in range(len(X)):
   # iterate through columns
   for j in range(len(X[0])):
       result[j][i] = X[i][j]

for r in result:
   print(r)  

# नेस्टेड लूप का उपयोग करके दो आव्यूहों को गुणा करने के लिए एक प्रोग्राम लिखें


X = [[12,7,3],
    [4 ,5,6],
    [7 ,8,9]]

Y = [[5,8,1,2],
    [6,7,3,0],
    [4,5,9,1]]

result = [[0,0,0,0],
         [0,0,0,0],
         [0,0,0,0]]


for i in range(len(X)):

   for j in range(len(Y[0])):

       for k in range(len(Y)):
           result[i][j] += X[i][k] * Y[k][j]

for r in result:
   print(r)   
   
# एक स्ट्रिंग से विराम चिह्न हटाने के लिए एक प्रोग्राम लिखें

punctuations = '''!()-[]{};:'"\,<>./?@#$%^&*_~'''

my_str = "Hello!!!, he said ---and went."

no_punct = ""
for char in my_str:
   if char not in punctuations:
       no_punct = no_punct + char

print(no_punct)

# ताश की गड्डी को फेरने के लिए एक प्रोग्राम लिखें

import itertools, random

deck = list(itertools.product(range(1,14),['Spade','Heart','Diamond','Club']))
random.shuffle(deck)

print("You got:")
for i in range(5):
   print(deck[i][0], "of", deck[i][1])
   
# अनाम फ़ंक्शन का उपयोग करके 2 की शक्तियों को प्रदर्शित करने के लिए एक प्रोग्राम लिखें

terms = 10
result = list(map(lambda x: 2 ** x, range(terms)))

print("The total terms are:",terms)
for i in range(terms):
   print("2 raised to power",i,"is",result[i])

# 2 बाइनरी नंबर जोड़ने के लिए एक प्रोग्राम लिखें

num1 = '00001'
num2 = '10001'

sum = bin(int(num1,2) + int(num2,2))
print(sum)

# साधारण ब्याज खोजने के लिए एक प्रोग्राम लिखें

p = float(input("Enter the principle amount : "))
r = float(input("Enter the rate of interest : "))
t = float(input("Enter the time in the years: "))

si = (p*r*t)/100

print("Principle amount: ", p)
print("Interest rate   : ", r)
print("Time in years   : ", t)
print("Simple Interest : ", si)

# चक्रवृद्धि ब्याज खोजने के लिए एक कार्यक्रम लिखें

p = float(input("Enter the principle amount : "))
r = float(input("Enter the rate of interest : "))
t = float(input("Enter the time in the years: "))

ci =  p * (pow((1 + r / 100), t)) 

print("Principle amount  : ", p)
print("Interest rate     : ", r)
print("Time in years     : ", t)
print("compound Interest : ", ci)

# सितारों (*) के पैटर्न को प्रिंट करने के लिए एक प्रोग्राम लिखें

for row in range (0,5):
    for column in range (0, row+1):
        print ("*", end="")

    # ending row
    print('\r')
    
# पायथन में निरपेक्ष मान वापस करने के लिए एक प्रोग्राम लिखें

def get_absolute_value(n):
	if n >= 0:
		return n
	else:
		return -n

print(get_absolute_value(101))

# किसी संख्या की शक्ति ज्ञात करने के लिए एक प्रोग्राम लिखें

a = 10
b = 3

result = a**b

print (a, " to the power of ", b, " is = ", result)

# 1 से N तक की संख्याओं के बाइनरी मान को प्रिंट करने के लिए एक प्रोग्राम लिखें

n = int(input("Enter the value of N: "))

for i in range(1, n+1):
    print("Binary value of ", i, " is: ", bin(i))
    
# बाइनरी में एक पूर्णांक का प्रतिनिधित्व करने के लिए आवश्यक बिट्स की संख्या खोजने के लिए एक प्रोग्राम लिखें

num = int(input("Enter an integer number: "))

bits = num.bit_length()

print("bits required to store ", num, " = ", bits)
print("binary value of ", num, " is = ", bin(num))

# 2 सूचियों के बीच अंतर खोजने के लिए एक प्रोग्राम लिखें

list1 = [10, 20, 30, 40, 50]
list2 = [10, 20, 30, 60, 70]

print "list1:", list1
print "list2:", list2

print "Difference elements:"
print (list (set(list1) - set (list2)))

# एक सूची में निर्दिष्ट सूचकांक पर एक तत्व जोड़ने के लिए एक प्रोग्राम लिखें

list = [10, 20, 30]
print (list)
list.insert (1, "ABC")
print (list)
list.insert (3, "PQR")
print (list)

# एक स्ट्रिंग की सम लंबाई वाले शब्दों को प्रिंट करने के लिए एक प्रोग्राम लिखें
str = "Python is a programming language"

words = list(str.split(' '))

print "str: ", str
print "list converted string: ", words
print "EVEN length words:"
for W in words:
	if(len(W)%2==0 ):
		print W
        
# किसी दिए गए स्ट्रिंग की N कॉपी बनाने के लिए एक प्रोग्राम लिखें

str1 = "Hello"
n = 3

str2 = str1 * 3 

print "str1: ", str1 
print "str2: ", str2

# पायथन में दिए गए स्ट्रिंग से मोबाइल नंबर निकालने के लिए एक प्रोग्राम लिखें

import re

string='''hello you can call me at 018002089898.'''

Phonenumber=re.compile(r'\d\d\d\d\d\d\d\d\d\d\d\d')
m=Phonenumber.search(string)

print('mobile number found from the string : ',m.group())

# एक स्ट्रिंग में प्रत्येक शब्द के पहले अक्षर को कैपिटलाइज़ करने के लिए एक प्रोग्राम लिखें

def capitalize(text):
  return text.title()

str1 = "Hello world!"
str2 = "hello world!"
str3 = "HELLO WORLD!"
str4 = "includehelp.com is a tutorials site"

print("str1: ", str1)
print("str2: ", str2)
print("str3: ", str3)
print("str4: ", str4)
print()

# डाइस थ्रो फंक्शन को डिजाइन करने के लिए एक प्रोग्राम लिखें

import random

def dice():
    return random.choice([1,2,3,4,5,6])
    
# पूर्णांकों की दी गई सूची से पूर्ण संख्याओं को प्रिंट करने के लिए एक प्रोग्राम लिखिए

def checkPerfectNum(n) :
	i = 2;sum = 1;

	while(i <= n//2 ) :
		if (n % i == 0) :
			sum += i			
		
		i += 1
		if sum == n :
			print(n,end=' ')

if __name__ == "__main__" :

	print("Enter list of integers: ")
	list_of_intgers = list(map(int,input().split()))

	print("Given list of integers:",list_of_intgers)

	print("Perfect numbers present in the list is: ")
	for num in list_of_intgers :
		checkPerfectNum(num)
        
# मीटर को गज में बदलने के लिए एक प्रोग्राम लिखिए
num = float(input("Enter the distance measured in centimeter : "))

inc = num/2.54 
print("Distance in inch : ", inc)

# हनोई का एक प्रोग्राम टॉवर लिखें

def hanoi(x):
    global repN
    repN += 1
    if x == 1:
        return 2
    
    else:
        return 3*hanoi(x-1) + 2
    
x = int(input("ENTER THE NUMBER OF DISKS: "))

global repN
repN =0

print('NUMBER OF STEPS: ', hanoi(x), ' :', repN)

# डेटासेट के विचरण को खोजने के लिए एक प्रोग्राम लिखें

def variance(X):
    mean = sum(X)/len(X)
    tot = 0.0
    for x in X:
        tot = tot + (x - mean)**2
    return tot/len(X)

 
sample = [1, 2, 3, 4, 5] 
print("variance of the sample is: ", variance(sample))

# दिन के विजेता को खोजने के लिए एक प्रोग्राम लिखें

def find_winner_of_the_day(*match_tuple):
    team1_count = 0
    team2_count = 0
     
    for team_name in match_tuple :
         
        if team_name == "Team1" :
            team1_count += 1
        else :
            team2_count += 1
             
    if team1_count == team2_count :
        return "Tie"
         
    elif team1_count > team2_count :
        return "Team1"
     
    else :
        return "Team2"
     
     
if __name__ == "__main__" :
     
    print(find_winner_of_the_day("Team1","Team2","Team1"))
    print(find_winner_of_the_day("Team1","Team2","Team1","Team2"))
    print(find_winner_of_the_day("Team1","Team2","Team2","Team1","Team2"))
    
# तीसरे चर के बिना दो पूर्णांकों के मान की अदला-बदली के लिए एक प्रोग्राम लिखें

x = int(input("Enter the value of x :"))
y = int(input("Enter the value of y :"))

(x,y) = (y,x)

print('Value of x: ', x, '\nValue of y: ', y, '\nWOO!! Values SWAPPEDDD')

# मतदान के लिए योग्यता जांचने के लिए एक प्रोग्राम लिखें

age = int(input("Enter Age : "))

if age>=18:
        status="Eligible"
else:
    status="Not Eligible"

print("You are ",status," for Vote.")

# संस्करण जानकारी मुद्रित करने के लिए एक प्रोग्राम लिखें

import sys

print("Python version: ", sys.version)
print("Python version info: ", sys.version_info)

# किसी संख्या के सभी अंकों का योग ज्ञात करने के लिए एक प्रोग्राम लिखें

def sumDigits(num):
  if num == 0:
    return 0
  else:
    return num % 10 + sumDigits(int(num / 10))

x = 0
print("Number: ", x)
print("Sum of digits: ", sumDigits(x))
print()

# स्ट्रिंग चर के साथ दोहरे उद्धरण चिह्नों को प्रिंट करने के लिए एक प्रोग्राम लिखें
str1 = "Hello world";

print("\"%s\"" % str1)
print('"%s"' % str1)
print('"{}"'.format(str1))

# आईपी ​​​​एड्रेस से अग्रणी शून्य हटाने के लिए एक प्रोग्राम लिखें

import re
def removeLeadingZeros(ip):
    modified_ip = re.sub(regex, '.', ip)
    print(modified_ip)


if __name__ == '__main__' : 
	
	ip = "216.08.094.196"
	removeLeadingZeros(ip)

# बाइनरी सर्च के लिए एक प्रोग्राम लिखें

def binary_search(l, num_find):

    start = 0
    end = len(l) - 1
    mid = (start + end) // 2
    
    found = False
    position = -1

    while start <= end:
        if l[mid] == num_find:
            found = True
            position = mid
            break
        
        if num_find > l[mid]:
            start = mid + 1
            mid = (start + end) // 2
        else:
            end = mid - 1
            mid = (start + end) // 2

    return (found, position)

if __name__=='__main__':
    
    l = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    num = 6
    found = binary_search(l, num)
    if found[0]:
        print('Number %d found at position %d'%(num, found[1]+1))
    else:
        print('Number %d not found'%num)
        
# एक फ़ाइल की विषम पंक्तियों को दूसरी फ़ाइल में कॉपी करने के लिए एक प्रोग्राम लिखें

file1 = open('file1.txt', 'r') 
file2 = open('file2.txt', 'w') 

lines = file1.readlines() 
type(lines) 
for i in range(0, len(lines)): 
	if(i % 2 != 0): 
		file2.write(lines[i]) 

file1.close()
file2.close() 

file1 = open('file1.txt', 'r') 
file2 = open('file2.txt', 'r') 

str1 = file1.read()
str2 = file2.read()

print("file1 content...")
print(str1)

print() # to print new line

print("file2 content...")
print(str2)

file1.close()
file2.close()

# पायथन में अंक वाले स्ट्रिंग को उलटने के लिए एक प्रोग्राम लिखें

def reverse(n):
    s=str(n) 
    p=s[::-1]
    return p 

num = int(input('Enter a positive value: '))
print('The reverse integer:',reverse(num))

# एक स्ट्रिंग इनपुट करने के लिए एक प्रोग्राम लिखें और कुल संख्या अपरकेस और लोअरकेस अक्षर खोजें

print("Input a string: ")
str1 = input()

no_of_ucase, no_of_lcase = 0,0

for c in str1:
    if c>='A' and c<='Z':
        no_of_ucase += 1
    if c>='a' and c<='z':
        no_of_lcase += 1

print("Input string is: ", str1)
print("Total number of uppercase letters: ", no_of_ucase)
print("Total number of lowercase letters: ", no_of_lcase)

# एक स्ट्रिंग इनपुट करने के लिए एक प्रोग्राम लिखें और अक्षरों और अंकों की कुल संख्या ज्ञात करें

print("Input a string: ")
str1 = input()

no_of_letters, no_of_digits = 0,0

for c in str1:
    if (c>='a' and c<='z') or (c>='A' and c<='Z'):
        no_of_letters += 1
    if c>='0' and c<='9':
        no_of_digits += 1

print("Input string is: ", str1)
print("Total number of letters: ", no_of_letters)
print("Total number of digits: ", no_of_digits)

# हनोई के टावर को लागू करने के लिए एक पायथन फ़ंक्शन लिखें

def hanoi(disks, source, auxiliary, target):
    if disks == 1:
        print('Move disk 1 from peg {} to peg {}.'.format(source, target))
        return
 
    hanoi(disks - 1, source, target, auxiliary)
    print('Move disk {} from peg {} to peg {}.'.format(disks, source, target))
    hanoi(disks - 1, auxiliary, source, target)


# एक क्यू का उपयोग करके स्टैक को लागू करने के लिए एक पायथन प्रोग्राम लिखें

class Stack:
    def __init__(self):
        self.q = Queue()
 
    def is_empty(self):
        return self.q.is_empty()
 
    def push(self, data):
        self.q.enqueue(data)
 
    def pop(self):
        for _ in range(self.q.get_size() - 1):
            dequeued = self.q.dequeue()
            self.q.enqueue(dequeued)
        return self.q.dequeue()
 
 
class Queue:
    def __init__(self):
        self.items = []
        self.size = 0
 
    def is_empty(self):
        return self.items == []
 
    def enqueue(self, data):
        self.size += 1
        self.items.append(data)
 
    def dequeue(self):
        self.size -= 1
        return self.items.pop(0)
 
    def get_size(self):
        return self.size
 
 
s = Stack()
 
print('Menu')
print('push <value>')
print('pop')
print('quit')
 
while True:
    do = input('What would you like to do? ').split()
 
    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break

# डेक्यू को लागू करने के लिए एक पायथन प्रोग्राम लिखें

class Dequeue:
    def __init__(self):
        self.items = []
 
    def is_empty(self):
        return self.items == []
 
    def append(self, data):
        self.items.append(data)
 
    def append_left(self, data):
        self.items.insert(0, data)
 
    def pop(self):
        return self.items.pop()
 
    def pop_left(self):
        return self.items.pop(0)
 
 
q = Dequeue()
print('Menu')
print('append <value>')
print('appendleft <value>')
print('pop')
print('popleft')
print('quit')
 
while True:
    do = input('What would you like to do? ').split()
 
    operation = do[0].strip().lower()
    if operation == 'append':
        q.append(int(do[1]))
    elif operation == 'appendleft':
        q.append_left(int(do[1]))
    elif operation == 'pop':
        if q.is_empty():
            print('Dequeue is empty.')
        else:
            print('Popped value from right: ', q.pop())
    elif operation == 'popleft':
        if q.is_empty():
            print('Dequeue is empty.')
        else:
            print('Popped value from left: ', q.pop_left())
    elif operation == 'quit':
        break

# यदि स्टैक का उपयोग करके स्ट्रिंग पैलिंड्रोम है तो जांचने और प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

class Stack:
    def __init__(self):
        self.items = []
 
    def is_empty(self):
        return self.items == []
 
    def push(self, data):
        self.items.append(data)
 
    def pop(self):
        return self.items.pop()
 
 
s = Stack()
text = "ABA"
 
for character in text:
    s.push(character)
 
reversed_text = ''
while not s.is_empty():
    reversed_text = reversed_text + s.pop()
 
if text == reversed_text:
    print('The string is a palindrome.')
else:
    print('The string is not a palindrome.')

# स्टैक का उपयोग करके अभिव्यक्ति को सही ढंग से संश्लेषित किया गया है या नहीं, इसकी जांच और प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

class Stack:
    def __init__(self):
        self.items = []
 
    def is_empty(self):
        return self.items == []
 
    def push(self, data):
        self.items.append(data)
 
    def pop(self):
        return self.items.pop()
 
 
s = Stack()
exp = "(x+y"
 
for c in exp:
    if c == '(':
        s.push(1)
    elif c == ')':
        if s.is_empty():
            is_balanced = False
            break
        s.pop()
else:
    if s.is_empty():
        is_balanced = True
    else:
        is_balanced = False
 
if is_balanced:
    print('Expression is correctly parenthesized.')
else:
    print('Expression is not correctly parenthesized.')

# रैखिक खोज को लागू करने के लिए एक पायथन प्रोग्राम लिखें और यदि कुंजी तत्व मिल जाए तो उसे प्रिंट करें

def linear_search(alist, key):
    """Return index of key in alist. Return -1 if key not present."""
    for i in range(len(alist)):
        if alist[i] == key:
            return i
    return -1
 
 
alist = [2, 3, 5, 6, 4, 5]

key = 6
 
index = linear_search(alist, key)
if index < 0:
    print(f'{key} was not found.')
else:
    print(f'{key} was found at index {index}.')

# रिकर्सन के बिना बाइनरी सर्च को लागू करने के लिए एक पायथन प्रोग्राम लिखें और यदि कुंजी तत्व मिल जाए तो उसे प्रिंट करें

def binary_search(alist, key):
    """Search key in alist[start... end - 1]."""
    start = 0
    end = len(alist)
    while start < end:
        mid = (start + end)//2
        if alist[mid] > key:
            end = mid
        elif alist[mid] < key:
            start = mid + 1
        else:
            return mid
    return -1
 
 
alist = [2, 3, 5, 6, 4, 5]

key = 6
 
index = binary_search(alist, key)
if index < 0:
    print(f'{key} was not found.')
else:
    print(f'{key} was found at index {index}.')


# पुनरावर्तन के साथ बाइनरी खोज को लागू करने के लिए एक पायथन प्रोग्राम लिखें और यदि कुंजी तत्व मिल जाए तो उसे प्रिंट करें

def binary_search_rec(alist, start, end, key):
    """Search key in alist[start... end - 1]."""
    if not start < end:
        return -1
 
    mid = (start + end)//2
    if alist[mid] < key:
        return binary_search_rec(alist, mid + 1, end, key)
    elif alist[mid] > key:
        return binary_search_rec(alist, start, mid, key)
    else:
        return mid
 
 
alist = [2, 3, 5, 6, 4, 5]

key = 6
 
index = binary_search_rec(alist, 0, len(alist), key)
if index < 0:
    print(f'{key} was not found.')
else:
    print(f'{key} was found at index {index}.')


# बबल सॉर्ट को लागू करने के लिए एक पायथन प्रोग्राम लिखें और नीचे दी गई सूची के लिए सॉर्ट की गई सूची को प्रिंट करें

def bubble_sort(alist):
    for i in range(len(alist) - 1, 0, -1):
        no_swap = True
        for j in range(0, i):
            if alist[j + 1] < alist[j]:
                alist[j], alist[j + 1] = alist[j + 1], alist[j]
                no_swap = False
        if no_swap:
            return
 
 
alist = [2, 3, 5, 6, 4, 5]
bubble_sort(alist)
print('Sorted list: ', end='')
print(alist)

# चयन प्रकार को लागू करने के लिए एक पायथन प्रोग्राम लिखें और नीचे दी गई सूची के लिए क्रमबद्ध सूची को प्रिंट करें

def selection_sort(alist):
    for i in range(0, len(alist) - 1):
        smallest = i
        for j in range(i + 1, len(alist)):
            if alist[j] < alist[smallest]:
                smallest = j
        alist[i], alist[smallest] = alist[smallest], alist[i]
 
 
alist = [2, 3, 5, 6, 4, 5]
selection_sort(alist)
print('Sorted list: ', end='')
print(alist)

# इंसर्शन सॉर्ट लागू करने के लिए एक पायथन प्रोग्राम लिखें और नीचे दी गई सूची के लिए सॉर्ट की गई सूची को प्रिंट करें

def insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        j = i - 1
        while (j >= 0 and temp < alist[j]):
            alist[j + 1] = alist[j]
            j = j - 1
        alist[j + 1] = temp
 
 
alist = [2, 3, 5, 6, 4, 5]
insertion_sort(alist)
print('Sorted list: ', end='')
print(alist)

# मर्ज सॉर्ट लागू करने के लिए एक पायथन प्रोग्राम लिखें और नीचे दी गई सूची के लिए सॉर्ट की गई सूची को प्रिंट करें

def merge_sort(alist, start, end):
    '''Sorts the list from indexes start to end - 1 inclusive.'''
    if end - start > 1:
        mid = (start + end)//2
        merge_sort(alist, start, mid)
        merge_sort(alist, mid, end)
        merge_list(alist, start, mid, end)
 
def merge_list(alist, start, mid, end):
    left = alist[start:mid]
    right = alist[mid:end]
    k = start
    i = 0
    j = 0
    while (start + i < mid and mid + j < end):
        if (left[i] <= right[j]):
            alist[k] = left[i]
            i = i + 1
        else:
            alist[k] = right[j]
            j = j + 1
        k = k + 1
    if start + i < mid:
        while k < end:
            alist[k] = left[i]
            i = i + 1
            k = k + 1
    else:
        while k < end:
            alist[k] = right[j]
            j = j + 1
            k = k + 1
 
 
alist = [2, 3, 5, 6, 4, 5]
merge_sort(alist, 0, len(alist))
print('Sorted list: ', end='')
print(alist)

# क्विकसॉर्ट को लागू करने के लिए एक पायथन प्रोग्राम लिखें और नीचे दी गई सूची के लिए क्रमबद्ध सूची को प्रिंट करें

def quicksort(alist, start, end):
    '''Sorts the list from indexes start to end - 1 inclusive.'''
    if end - start > 1:
        p = partition(alist, start, end)
        quicksort(alist, start, p)
        quicksort(alist, p + 1, end)
 
 
def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1
 
    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1
 
        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j
 
 
alist = [2, 3, 5, 6, 4, 5]
quicksort(alist, 0, len(alist))
print('Sorted list: ', end='')
print(alist)

# हीप्सोर्ट को लागू करने के लिए एक पायथन प्रोग्राम लिखें और नीचे दी गई सूची के लिए क्रमबद्ध सूची को प्रिंट करें

def heapsort(alist):
    build_max_heap(alist)
    for i in range(len(alist) - 1, 0, -1):
        alist[0], alist[i] = alist[i], alist[0]
        max_heapify(alist, index=0, size=i)
 
def parent(i):
    return (i - 1)//2
 
def left(i):
    return 2*i + 1
 
def right(i):
    return 2*i + 2
 
def build_max_heap(alist):
    length = len(alist)
    start = parent(length - 1)
    while start >= 0:
        max_heapify(alist, index=start, size=length)
        start = start - 1
 
def max_heapify(alist, index, size):
    l = left(index)
    r = right(index)
    if (l < size and alist[l] > alist[index]):
        largest = l
    else:
        largest = index
    if (r < size and alist[r] > alist[largest]):
        largest = r
    if (largest != index):
        alist[largest], alist[index] = alist[index], alist[largest]
        max_heapify(alist, largest, size)
 
 
alist = [2, 3, 5, 6, 4, 5]
heapsort(alist)
print('Sorted list: ', end='')
print(alist)

# काउंटिंग सॉर्ट लागू करने के लिए एक पायथन प्रोग्राम लिखें और नीचे दी गई सूची के लिए सॉर्ट की गई सूची को प्रिंट करें

def counting_sort(alist, largest):
    c = [0]*(largest + 1)
    for i in range(len(alist)):
        c[alist[i]] = c[alist[i]] + 1
 
    c[0] = c[0] - 1 
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]
 
    result = [None]*len(alist)
 
    for x in reversed(alist):
        result[c[x]] = x
        c[x] = c[x] - 1
 
    return result
 
 
alist = [2, 3, 5, 6, 4, 5]
k = max(alist)
sorted_list = counting_sort(alist, k)
print('Sorted list: ', end='')
print(sorted_list)

# रेडिक्स सॉर्ट को लागू करने के लिए एक पायथन प्रोग्राम लिखें और नीचे दी गई सूची के लिए सॉर्ट की गई सूची को प्रिंट करें

def radix_sort(alist, base=10):
    if alist == []:
        return
 
    def key_factory(digit, base):
        def key(alist, index):
            return ((alist[index]//(base**digit)) % base)
        return key
    largest = max(alist)
    exp = 0
    while base**exp <= largest:
        alist = counting_sort(alist, base - 1, key_factory(exp, base))
        exp = exp + 1
    return alist
 
def counting_sort(alist, largest, key):
    c = [0]*(largest + 1)
    for i in range(len(alist)):
        c[key(alist, i)] = c[key(alist, i)] + 1
 
    c[0] = c[0] - 1
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]
 
    result = [None]*len(alist)
    for i in range(len(alist) - 1, -1, -1):
        result[c[key(alist, i)]] = alist[i]
        c[key(alist, i)] = c[key(alist, i)] - 1
 
    return result
 
alist = [2, 3, 5, 6, 4, 5]
sorted_list = radix_sort(alist)
print('Sorted list: ', end='')
print(sorted_list)

# बकेट सॉर्ट को लागू करने के लिए एक पायथन प्रोग्राम लिखें और नीचे दी गई सूची के लिए सॉर्ट की गई सूची को प्रिंट करें

def bucket_sort(alist):
    largest = max(alist)
    length = len(alist)
    size = largest/length
 
    buckets = [[] for _ in range(length)]
    for i in range(length):
        j = int(alist[i]/size)
        if j != length:
            buckets[j].append(alist[i])
        else:
            buckets[length - 1].append(alist[i])
 
    for i in range(length):
        insertion_sort(buckets[i])
 
    result = []
    for i in range(length):
        result = result + buckets[i]
 
    return result
 
def insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        j = i - 1
        while (j >= 0 and temp < alist[j]):
            alist[j + 1] = alist[j]
            j = j - 1
        alist[j + 1] = temp
 
 
alist = [2, 3, 5, 6, 4, 5]
sorted_list = bucket_sort(alist)
print('Sorted list: ', end='')
print(sorted_list)

# गनोम सॉर्ट को लागू करने के लिए एक पायथन प्रोग्राम लिखें और नीचे दी गई सूची के लिए सॉर्ट की गई सूची को प्रिंट करें

def gnome_sort(alist):
    for pos in range(1, len(alist)):
        while (pos != 0 and alist[pos] < alist[pos - 1]):
            alist[pos], alist[pos - 1] = alist[pos - 1], alist[pos]
            pos = pos - 1
 
 
alist = [2, 3, 5, 6, 4, 5]
gnome_sort(alist)
print('Sorted list: ', end='')
print(alist)

# कॉकटेल शेकर सॉर्ट लागू करने के लिए एक पायथन प्रोग्राम लिखें और नीचे दी गई सूची के लिए सॉर्ट की गई सूची को प्रिंट करें

def cocktail_shaker_sort(alist):
    def swap(i, j):
        alist[i], alist[j] = alist[j], alist[i]
 
    upper = len(alist) - 1
    lower = 0
 
    no_swap = False
    while (not no_swap and upper - lower > 1):
        no_swap = True
        for j in range(lower, upper):
            if alist[j + 1] < alist[j]:
                swap(j + 1, j)
                no_swap = False
        upper = upper - 1
 
        for j in range(upper, lower, -1):
            if alist[j - 1] > alist[j]:
                swap(j - 1, j)
                no_swap = False
        lower = lower + 1
 
 
alist = [2, 3, 5, 6, 4, 5]
cocktail_shaker_sort(alist)
print('Sorted list: ', end='')
print(alist)

# कॉम्ब सॉर्ट लागू करने के लिए एक पायथन प्रोग्राम लिखें और नीचे दी गई सूची के लिए सॉर्ट की गई सूची को प्रिंट करें

def comb_sort(alist):
    def swap(i, j):
        alist[i], alist[j] = alist[j], alist[i]
 
    gap = len(alist)
    shrink = 1.3
 
    no_swap = False
    while not no_swap:
        gap = int(gap/shrink)
 
        if gap < 1:
            gap = 1
            no_swap = True
        else:
            no_swap = False
 
        i = 0
        while i + gap < len(alist):
            if alist[i] > alist[i + gap]:
                swap(i, i + gap)
                no_swap = False
            i = i + 1
 
 
alist = [2, 3, 5, 6, 4, 5]
comb_sort(alist)
print('Sorted list: ', end='')
print(alist)

# शेल सॉर्ट को लागू करने के लिए एक पायथन प्रोग्राम लिखें और नीचे दी गई सूची के लिए सॉर्ट की गई सूची को प्रिंट करें

def gaps(size):
    length = size.bit_length()
    for k in range(length - 1, 0, -1):
        yield 2**k - 1
 
 
def shell_sort(alist):
    def insertion_sort_with_gap(gap):
        for i in range(gap, len(alist)):
            temp = alist[i]
            j = i - gap
            while (j >= 0 and temp < alist[j]):
                alist[j + gap] = alist[j]
                j = j - gap
            alist[j + gap] = temp
 
    for g in gaps(len(alist)):
        insertion_sort_with_gap(g)
 
 
alist = [2, 3, 5, 6, 4, 5]
shell_sort(alist)
print('Sorted list: ', end='')
print(alist)

# एक आयत के क्षेत्रफल की गणना करने और क्षेत्र को प्रिंट करने के लिए एक पायथन वर्ग लिखें

class rectangle():
    def __init__(self,breadth,length):
        self.breadth=breadth
        self.length=length
    def area(self):
        return self.breadth*self.length
a=6
b=4
obj=rectangle(a,b)
print("Area of rectangle:",obj.area())

# एक वृत्त के क्षेत्रफल की गणना करने के लिए एक पायथन वर्ग लिखें और एक त्रिज्या के लिए घाटी को प्रिंट करें

class CircleArea():
    def __init__(self,radius):
        self.radius=radius
    def area(self):
        return 3.14 * self.radius * self.radius
a=6
obj=CircleArea(a)
print("Area of rectangle:",obj.area())

# एक वृत्त की परिधि की गणना करने के लिए एक पायथन वर्ग लिखें और एक त्रिज्या के लिए घाटी को प्रिंट करें

class CirclePerimeter():
    def __init__(self,radius):
        self.radius=radius
    def perimeter(self):
        return 2 * 3.14 * self.radius
a=6
obj=CirclePerimeter(a)
print("Perimeter of rectangle:",obj.perimeter())

# विशिष्ट पूर्णांकों के एक सेट से सभी संभावित सबसेट को प्रिंट करने के लिए एक पायथन वर्ग लिखें

class sub:  
    def f1(self, s1):  
        return self.f2([], sorted(s1))  
 
    def f2(self, curr, s1):  
        if s1:  
            return self.f2(curr, s1[1:]) + self.f2(curr + [s1[0]], s1[1:])  
        return [curr]  
a=[2, 3, 5, 6, 4, 5]

print("Subsets: ")
print(sub().f1(a))

# फ़ाइल की सामग्री को पढ़ने और प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

a=str(input("Enter file name .txt extension:"))
file2=open(a,'r')
line=file2.readline()
while(line!=""):
    print(line)
    line=file2.readline()
file2.close()

# टेक्स्ट फ़ाइल में शब्दों की संख्या गिनने और प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

fname = input("Enter file name: ")
 
num_words = 0
 
with open(fname, 'r') as f:
    for line in f:
        words = line.split()
        num_words += len(words)
print("Number of words:")
print(num_words)

# पाठ फ़ाइल में पंक्तियों की संख्या गिनने के लिए एक पायथन प्रोग्राम लिखें

fname = input("Enter file name: ")
num_lines = 0
with open(fname, 'r') as f:
    for line in f:
        num_lines += 1
print("Number of lines:")
print(num_lines)

# पाठ फ़ाइल में किसी शब्द की घटनाओं की गणना करने के लिए एक पायथन प्रोग्राम लिखें

fname = input("Enter file name: ")
word='the'
k = 0
 
with open(fname, 'r') as f:
    for line in f:
        words = line.split()
        for i in words:
            if(i==word):
                k=k+1
print(f"Frequency of Occurrences of the word {a} is:")
print(k)

# एक फ़ाइल की सामग्री को दूसरे में कॉपी करने के लिए एक पायथन फ़ंक्शन लिखें

def copy(from_file, to_file):
    with open(from_file) as f:
        with open(to_file, "w") as f1:
            for line in f:
                f1.write(line)

# एक पायथन फ़ंक्शन लिखें जो पाठ फ़ाइल में एक निश्चित पत्र प्रकट होने की संख्या की संख्या की गणना करता है
def count_letter(fname, l):
    k = 0
    with open(fname, 'r') as f:
        for line in f:
            words = line.split()
            for i in words:
                for letter in i:
                    if(letter==l):
                        k=k+1
    return k

# एक पायथन फ़ंक्शन लिखें जो टेक्स्ट फ़ाइल में मौजूद सभी नंबरों को प्रिंट करता है

def print_number(fname):
    with open(fname, 'r') as f:
        for line in f:
            words = line.split()
            for i in words:
                for letter in i:
                    if(letter.isdigit()):
                        print(letter)


# एक टेक्स्ट फ़ाइल में रिक्त स्थान की संख्या की गणना करने वाला एक पायथन फ़ंक्शन लिखें

def count_blank_space(fname):
    k = 0
    with open(fname, 'r') as f:
        for line in f:
            words = line.split()
            for i in words:
                for letter in i:
                    if(letter.isspace):
                        k=k+1
    return k

# एक पायथन फ़ंक्शन लिखें जो फ़ाइल में प्रत्येक शब्द के पहले अक्षर को कैपिटलाइज़ करता है

def capitalize(fname):
    with open(fname, 'r') as f:
        for line in f:
            l=line.title()
            print(l)

# एक पायथन फ़ंक्शन लिखें जो फ़ाइल की सामग्री को रिवर्स ऑर्डर में प्रिंट करता है

def reverse_content(filename):
    for line in reversed(list(open(filename))):
        print(line.rstrip())

# सूची को समतल करने और प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

a=[[1,[[2]],[[[3]]]],[[4],5]]
flatten=lambda l: sum(map(flatten,l),[]) if isinstance(l,list) else [l]
print(flatten(a))

# दो नंबरों का एलसीएम प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

def lcm(a,b):
    lcm.multiple=lcm.multiple+b
    if((lcm.multiple % a == 0) and (lcm.multiple % b == 0)):
        return lcm.multiple
    else:
        lcm(a, b)
    return lcm.multiple
lcm.multiple=0
a=4
b=7
if(a>b):
    LCM=lcm(b,a)
else:
    LCM=lcm(a,b)

print(LCM)

# दो नंबरों के जीसीडी को प्रिंट करने के लिए एक पायथन फ़ंक्शन लिखें

def gcd(a,b):
    if(b==0):
        return a
    else:
        return gcd(b,a%b)


# कोई संख्या अभाज्य है या नहीं, यह जानने के लिए एक पायथन फ़ंक्शन लिखें

def check(n, div = None):
    if div is None:
        div = n - 1
    while div >= 2:
        if n % div == 0:
            print("Number not prime")
            return False
        else:
            return check(n, div-1)
    else:
        print("Number is prime")
        return 'True'

# रिकर्सन का उपयोग करके किसी संख्या की शक्ति ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें

def power(base,exp):
    if(exp==1):
        return(base)
    if(exp!=1):
        return(base*power(base,exp-1))

# पुनरावर्तन का उपयोग करके नेस्टेड सूची का कुल योग ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें

def sum1(lst):
    total = 0
    for element in lst:
        if (type(element) == type([])):
            total = total + sum1(element)
        else:
            total = total + element
    return total

# सेट का उपयोग करके एक स्ट्रिंग में मौजूद स्वरों की संख्या को गिनने और प्रिंट करने के लिए एक पायथन फ़ंक्शन लिखें

def count_vowels(s):
    count = 0
    vowels = set("aeiou")
    for letter in s:
        if letter in vowels:
            count += 1
    return count

# दो इनपुट स्ट्रिंग्स में सामान्य अक्षरों को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

s1='python'
s2='schoolofai'
a=list(set(s1)&set(s2))
print("The common letters are:")
for i in a:
    print(i)

# एक पायथन प्रोग्राम लिखें जो प्रिंट करता है कि कौन से अक्षर पहले स्ट्रिंग में हैं लेकिन दूसरे में नहीं

s1='python'
s2='schoolofai'
a=list(set(s1)-set(s2))
print("The letters are:")
for i in a:
    print(i)

# दो शब्दकोशों को एक में जोड़ने के लिए एक पायथन प्रोग्राम लिखें

def concat_dic(d1, d2):
    return d1.update(d2)

# शब्दकोश में सभी वस्तुओं को गुणा करने के लिए एक पायथन प्रोग्राम लिखें

def mul_dict(d):
    tot=1
    for i in d:    
        tot=tot*d[i]
    return tot

# किसी डिक्शनरी से दी गई कुंजी को निकालने के लिए एक पायथन प्रोग्राम लिखें

def remove_item_dict(d, key):
    if key in d: 
        del d[key]
    else:
        print("Key not found!")
        exit(0)

# एक शब्दकोश में दो सूचियों को मैप करने के लिए एक पायथन प्रोग्राम लिखें

def map_dict(keys, values):
    return dict(zip(keys,values))

# नॉन-एम्प्टी स्ट्रिंग से nth इंडेक्स कैरेक्टर को हटाने के लिए एक पायथन प्रोग्राम लिखें

def remove(string, n):  
      first = string[:n]   
      last = string[n+1:]  
      return first + last

# यह पता लगाने के लिए एक पायथन प्रोग्राम लिखें कि क्या दो स्ट्रिंग एनाग्राम हैं

def anagram_check(s1, s2):
    if(sorted(s1)==sorted(s2)):
        return True
    else:
        return False

# एक नया स्ट्रिंग बनाने के लिए एक पायथन प्रोग्राम लिखें जहां पहले कैरेक्टर और आखिरी कैरेक्टर का आदान-प्रदान किया गया हो

def change(string):
      return string[-1:] + string[1:-1] + string[:1]

# एक स्ट्रिंग में विषम सूचकांक मानों के वर्णों को हटाने के लिए एक पायथन प्रोग्राम लिखें

def modify(string):  
    final = ""   
    for i in range(len(string)):  
        if i % 2 == 0:  
            final = final + string[i]  
    return final

# दो स्ट्रिंग लेने और बड़ी स्ट्रिंग प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

string1='python'
string2='theschoolofai'
count1=0
count2=0
for i in string1:
      count1=count1+1
for j in string2:
      count2=count2+1
if(count1<count2):
      print("Larger string is:")
      print(string2)
elif(count1==count2):
      print("Both strings are equal.")
else:
      print("Larger string is:")
      print(string1)

# एक स्ट्रिंग में लोअरकेस वर्णों की संख्या गिनने और प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

string='This is an Assignment'
count=0
for i in string:
      if(i.islower()):
            count=count+1
print("The number of lowercase characters is:")
print(count)

# एक सूची में सम और विषम तत्वों को दो अलग-अलग सूचियों में रखने के लिए एक पायथन प्रोग्राम लिखें

a=[2, 3, 8, 9, 2, 4, 6]
even=[]
odd=[]
for j in a:
    if(j%2==0):
        even.append(j)
    else:
        odd.append(j)
print("The even list",even)
print("The odd list",odd)

# सबलिस्ट में दूसरे तत्व के अनुसार सूची को क्रमबद्ध करने के लिए एक पायथन प्रोग्राम लिखें

a=[['A',34],['B',21],['C',26]]
for i in range(0,len(a)):
    for j in range(0,len(a)-i-1):
        if(a[j][1]>a[j+1][1]):
            temp=a[j]
            a[j]=a[j+1]
            a[j+1]=temp


# बबल सॉर्ट का उपयोग करके सूची में दूसरी सबसे बड़ी संख्या खोजने के लिए एक पायथन प्रोग्राम लिखें

a=[2, 3, 8, 9, 2, 4, 6]
for i in range(0,len(a)):
    for j in range(0,len(a)-i-1):
        if(a[j]>a[j+1]):
            temp=a[j]
            a[j]=a[j+1]
            a[j+1]=temp 

# दो सूचियों के प्रतिच्छेदन को खोजने के लिए एक पायथन प्रोग्राम लिखें

def main(alist, blist):
    def intersection(a, b):
        return list(set(a) & set(b))
    return intersection(alist, blist)

# सूची समझ का उपयोग करके नंबर के वर्ग के रूप में पहले तत्व और दूसरे तत्व के रूप में पहले तत्व के साथ टुपल्स की सूची बनाने के लिए एक पायथन प्रोग्राम लिखें

l_range=2
u_range=5
a=[(x,x**2) for x in range(l_range,u_range+1)]


# एक रेंज में सभी नंबरों को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें जो कि परफेक्ट स्क्वायर हैं और संख्या में सभी अंकों का योग 10 से कम है

l=6
u=9
a=[x for x in range(l,u+1) if (int(x**0.5))**2==x and sum(list(map(int,str(x))))<10]
print(a)

# किसी सूची के प्रथम और अंतिम मान की अदला-बदली करने के लिए Python प्रोग्राम लिखें

a=[2, 3, 8, 9, 2, 4, 6]
n = len(a)
temp=a[0]
a[0]=a[n-1]
a[n-1]=temp
print("New list is:")
print(a)

# सूची से डुप्लिकेट आइटम निकालने और प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

a=[2, 3, 8, 9, 2, 4, 6]
b = set()
unique = []
for x in a:
    if x not in b:
        unique.append(x)
        b.add(x)
print("Non-duplicate items:")
print(unique)

# शब्दों की सूची पढ़ने और सबसे लंबे शब्द की लंबाई वापस करने के लिए एक पायथन प्रोग्राम लिखें

a=['the', 'tsai', 'python']
max1=len(a[0])
temp=a[0]
for i in a:
    if(len(i)>max1):
       max1=len(i)
       temp=i
print("The word with the longest length is:")
print(temp)

# एक सूची में दिए गए शब्द की ith घटना को हटाने के लिए एक पायथन प्रोग्राम लिखें जहां शब्द दोहराए जा सकते हैं

a=['the', 'tsai', 'python' ,'a' ,'the', 'a']
c=[]
count=0
b='a'
n=3
for i in a:
    if(i==b):
        count=count+1
        if(count!=n):
            c.append(i)
    else:
        c.append(i)
if(count==0):
    print("Item not found ")
else: 
    print("The number of repetitions is: ",count)
    print("Updated list is: ",c)
    print("The distinct elements are: ",set(a))


# एक सूची में अजीब संख्या में आने वाले तत्व को खोजने के लिए एक पायथन फ़ंक्शन लिखें

def find_odd_occurring(alist):
    """Return the element that occurs odd number of times in alist.
 
    alist is a list in which all elements except one element occurs an even
    number of times.
    """
    ans = 0
 
    for element in alist:
        ans ^= element
 
    return ans

# यह जाँचने के लिए एक पायथन प्रोग्राम लिखें कि क्या कोई तिथि मान्य है और यदि यह है तो बढ़ी हुई तिथि को प्रिंट करें

date="20/04/2021"
dd,mm,yy=date.split('/')
dd=int(dd)
mm=int(mm)
yy=int(yy)
if(mm==1 or mm==3 or mm==5 or mm==7 or mm==8 or mm==10 or mm==12):
    max1=31
elif(mm==4 or mm==6 or mm==9 or mm==11):
    max1=30
elif(yy%4==0 and yy%100!=0 or yy%400==0):
    max1=29
else:
    max1=28
if(mm<1 or mm>12):
    print("Date is invalid.")
elif(dd<1 or dd>max1):
    print("Date is invalid.")
elif(dd==max1 and mm!=12):
    dd=1
    mm=mm+1
    print("The incremented date is: ",dd,mm,yy)
elif(dd==31 and mm==12):
    dd=1
    mm=1
    yy=yy+1
    print("The incremented date is: ",dd,mm,yy)
else:
    dd=dd+1
    print("The incremented date is: ",dd,mm,yy)

# दिया गया वर्ष लीप वर्ष है या नहीं यह जांचने के लिए एक पायथन फ़ंक्शन लिखें

def leapyear_check(year):
    if(year%4==0 and year%100!=0 or year%400==0):
        return True
    else:
        return False

# एक पूर्णांक के प्रमुख कारक को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

n=24
print("Factors are:")
i=1
while(i<=n):
    k=0
    if(n%i==0):
        j=1
        while(j<=i):
            if(i%j==0):
                k=k+1
            j=j+1
        if(k==2):
            print(i)
    i=i+1


# एक पूर्णांक के सभी विभाजकों को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

n=60
print("The divisors of the number are:")
for i in range(1,n+1):
    if(n%i==0):
        print(i)


# कोई संख्या एक आर्मस्ट्रांग संख्या है या नहीं यह जांचने के लिए एक पायथन प्रोग्राम लिखें

def amstrong_check(n):
    a=list(map(int,str(n)))
    b=list(map(lambda x:x**3,a))
    if(sum(b)==n):
        return True
    else:
        return False

# उपयोगकर्ता द्वारा दी गई पंक्तियों की संख्या के लिए पास्कल के त्रिकोण को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

n=10
a=[]
for i in range(n):
    a.append([])
    a[i].append(1)
    for j in range(1,i):
        a[i].append(a[i-1][j-1]+a[i-1][j])
    if(n!=0):
        a[i].append(1)
for i in range(n):
    print("   "*(n-i),end=" ",sep=" ")
    for j in range(0,i+1):
        print('{0:6}'.format(a[i][j]),end=" ",sep=" ")
    print()

# कोई संख्या एक पूर्ण संख्या है या नहीं यह जांचने के लिए एक पायथन प्रोग्राम लिखें

def perfect_no_check(n):
    sum1 = 0
    for i in range(1, n):
        if(n % i == 0):
            sum1 = sum1 + i
    if (sum1 == n):
        return True
    else:
        return False

# कोई संख्या प्रबल संख्या है या नहीं यह जाँचने के लिए एक Python प्रोग्राम लिखें

def strong_no_check(num):
    sum1=0
    temp=num
    while(num):
        i=1
        f=1
        r=num%10
        while(i<=r):
            f=f*i
            i=i+1
        sum1=sum1+f
        num=num//10
    if(sum1==temp):
        return True
    else:
        return False

# यदि दो संख्याएँ सौहार्दपूर्ण संख्याएँ हैं, तो जाँचने के लिए एक पायथन प्रोग्राम लिखें

def amicable_no_check(x, y):
    sum1=0
    sum2=0
    for i in range(1,x):
        if x%i==0:
            sum1+=i
    for j in range(1,y):
        if y%j==0:
            sum2+=j
    if(sum1==y and sum2==x):
        return True
    else:
        return False

# कोई संख्या एक अभाज्य संख्या है या नहीं यह जांचने के लिए एक पायथन प्रोग्राम लिखें

def prime_no_check(a):
    k=0
    for i in range(2,a//2+1):
        if(a%i==0):
            k=k+1
    if(k<=0):
        return True
    else:
        return False

# प्रथम एन प्राकृतिक संख्याओं के योग को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

n=7
sum1 = 0
while(n > 0):
    sum1=sum1+n
    n=n-1
print("The sum of first n natural numbers is",sum1)

# रेंज में सभी पायथागॉरियन ट्रिपल को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

limit=10
c=0
m=2
while(c<limit):
    for n in range(1,m+1):
        a=m*m-n*n
        b=2*m*n
        c=m*m+n*n
        if(c>limit):
            break
        if(a==0 or b==0 or c==0):
            break
        print(a,b,c)
    m=m+1

# एक सूची में एक विशेष संख्या कितनी बार आती है, इसकी संख्या को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

a=[2, 3, 8, 9, 2, 4, 6]
k=0
num=int(input("Enter the number to be counted:"))
for j in a:
    if(j==num):
        k=k+1
print("Number of times",num,"appears is",k)

# दी गई संख्या के लिए Collatz Conjecture का परीक्षण और प्रिंट करने के लिए Python प्रोग्राम लिखें

def collatz(n):
    while n > 1:
        print(n, end=' ')
        if (n % 2):
            # n is odd
            n = 3*n + 1
        else:
            # n is even
            n = n//2
    print(1, end='')

# एक संख्या में सेट बिट्स की गणना करने के लिए एक पायथन फ़ंक्शन लिखें

def count_set_bits(n):
    count = 0
    while n:
        n &= n - 1
        count += 1
    return count

# पुनरावर्तन का उपयोग करके ग्रे कोड उत्पन्न करने के लिए एक पायथन प्रोग्राम लिखें

def get_gray_codes(n):
    """Return n-bit Gray code in a list."""
    if n == 0:
        return ['']
    first_half = get_gray_codes(n - 1)
    second_half = first_half.copy()
 
    first_half = ['0' + code for code in first_half]
    second_half = ['1' + code for code in reversed(second_half)]
 
    return first_half + second_half

# ग्रे कोड को बाइनरी में बदलने के लिए एक पायथन प्रोग्राम लिखें

def gray_to_binary(n):
    """Convert Gray codeword to binary and return it."""
    n = int(n, 2)
 
    mask = n
    while mask != 0:
        mask >>= 1
        n ^= mask

    return bin(n)[2:]

# बाइनरी को ग्रे कोड में बदलने के लिए एक पायथन प्रोग्राम लिखें

def binary_to_gray(n):
    """Convert Binary to Gray codeword and return it."""
    n = int(n, 2)
    n ^= (n >> 1)

    return bin(n)[2:]

# दी गई संख्या को उलटने के लिए एक पायथन प्रोग्राम लिखें

n=1023
rev=0
while(n>0):
    dig=n%10
    rev=rev*10+dig
    n=n//10
print("Reverse of the number:",rev)

# तीन अंकों को स्वीकार करने के लिए एक पायथन प्रोग्राम लिखें और अंकों से सभी संभावित संयोजनों को प्रिंट करें

a=2
b=9
c=5
d=[]
d.append(a)
d.append(b)
d.append(c)
for i in range(0,3):
    for j in range(0,3):
        for k in range(0,3):
            if(i!=j&j!=k&k!=i):
                print(d[i],d[j],d[k])

# आइडेंटिटी मैट्रिक्स को प्रिंट करने के लिए एक पायथन फंक्शन लिखें

def print_identity_matrix(n):
    for i in range(0,n):
        for j in range(0,n):
            if(i==j):
                print("1",sep=" ",end=" ")
            else:
                print("0",sep=" ",end=" ")
        print()

# सूची के रूप में दिए गए मेनू और लागत का उपयोग करके एक पायथन प्रोग्राम प्रिंट रेस्तरां मेनू लिखें

class Food(object):
    def __init__(self, name, price):
        self.name = name
        self.price = price
    
    def getprice(self):
        return self.price
    
    def __str__(self):
        return self.name + ' : ' + str(self.getprice())
    
def buildmenu(names, costs):
    menu = []
    for i in range(len(names)):
        menu.append(Food(names[i], costs[i]))
    return menu

names = ['Coffee', 'Tea', 'Pizza', 'Burger', 'Fries', 'Apple', 'Donut', 'Cake']

costs = [250, 150, 180, 70, 65, 55, 120, 350]

Foods = buildmenu(names, costs)

n = 1
for el in Foods:
    print(n,'. ', el)
    n = n + 1

# क्लोजर का उपयोग करके दी गई संख्या के लिए फाइबोनैचि श्रृंखला की सूची मुद्रित करने के लिए एक पायथन प्रोग्राम लिखें

def fib():
    cache = {1:1, 2:1}

    def calc_fib(n):
        if n not in cache:
            print(f'Calculating fib({n})')
            cache[n] = calc_fib(n - 1) + calc_fib(n - 2)
        return cache[n]
    return calc_fib

# किसी दिए गए नो यूजिंग क्लास के लिए फाइबोनैचि श्रृंखला की सूची प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

class Fib:
    def __init__(self):
        self.cache = {1:1, 2:1}

    def fib(self, n):
        if n not in self.cache:
            print(f'Calculating fib({n})')
            self.cache[n] = self.fib(n-1) + self.fib(n-2)
        return self.cache[n]

# क्लोजर का उपयोग करके दी गई संख्या के फैक्टोरियल की गणना करने के लिए एक पायथन फ़ंक्शन लिखें

def fact():
    cache = {0:1, 1:1}

    def calc_fib(n):
        if n not in cache:
            print(f'Calculating fact({n})')
            cache[n] = calc_fib(n - 1) * n
        return cache[n]
    return calc_fib

# वर्ग का उपयोग करके दिए गए नहीं के भाज्य की गणना करने के लिए एक पायथन फ़ंक्शन लिखें

class Fact:
    def __init__(self):
        self.cache = {0:1, 1:1}

    def fact(self, n):
        if n not in self.cache:
            self.cache[n] = self.fact(n-1) * n
        return self.cache[n]

# दो दिए गए अनुक्रमों के डॉट उत्पाद की गणना करने के लिए एक पायथन फ़ंक्शन लिखें


def dot_product(a, b):
    return sum( e[0]*e[1] for e in zip(a, b))

# साइन श्रृंखला का योग ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें

import math
def sin(x,n):
    sine = 0
    for i in range(n):
        sign = (-1)**i
        pi=22/7
        y=x*(pi/180)
        sine = sine + ((y**(2.0*i+1))/math.factorial(2*i+1))*sign
    return sine

# कोसाइन श्रृंखला का योग ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें

def cosine(x,n):
    cosx = 1
    sign = -1
    for i in range(2, n, 2):
        pi=22/7
        y=x*(pi/180)
        cosx = cosx + (sign*(y**i))/math.factorial(i)
        sign = -sign
    return cosx

# एक स्ट्रिंग से स्वरों को निकालने के लिए एक पायथन फ़ंक्शन लिखें

def vowel_stripping(string):
    '''This function takes a string as an input strips out vowels and returns stripted out string'''
    return "".join([x for x in string if x not in('a','e','i','o','u')])

# एक पायथन फ़ंक्शन लिखें जो स्ट्रिंग्स के चरित्र को बदल देता है

def char_shift(string, shift_count):
    '''This function takes a string as an input and shifts each character by 5 and returns shifted string'''
    return "".join([chr(ord(x)+shift_count) if (ord(x)+shift_count) <= 122 else chr(96 + (ord(x)+shift_count) - 122) for x in string])

# एक पायथन फ़ंक्शन लिखें जो एक स्ट्रिंग में सबसे बड़ा वर्ण लौटाता है

from functools import reduce
def biggest_char(string):
    '''This function takes an input as a string and returns the biggest output character in the string'''
    biggest_chr = lambda x, y: x if ord(x) > ord(y) else y
    return reduce(biggest_chr, string)

# एक समभुज बहुभुज के आंतरिक कोण की गणना करने वाला एक पायथन फ़ंक्शन लिखें

def interior_angle(no_of_sides):
    return (no_of_sides - 2) * 180 / no_of_sides

# एक समबाहु बहुभुज की पार्श्व लंबाई की गणना करने वाला एक पायथन फ़ंक्शन लिखें

import math
def side_length(no_of_sides, circumradius):
    return 2 * circumradius * math.sin(math.pi / no_of_sides)

# एक समभुज बहुभुज के क्षेत्रफल की गणना करने वाला एक पायथन फ़ंक्शन लिखें


import math
def area(no_of_sides, circumradius):
    side_length = 2 * circumradius * math.sin(math.pi / no_of_sides)
    apothem = circumradius * math.cos(math.pi / no_of_sides)
    return no_of_sides / 2 * side_length * apothem



# दिए गए इंटरजर को बाइनरी में प्रिंट करने के लिए एक फंक्शन लिखें
def int_to_binary(num: int):
    """
    function to print number to binary
    """
    if isinstance(num, int):
        print(f'The binary of {num} is {bin(num).replace("0b","")}')
    else:
        raise ValueError('Invalid Input')


# दी गई स्ट्रिंग पैलिंड्रोम है या नहीं यह जांचने के लिए एक फ़ंक्शन लिखें (केस असंवेदनशील)
def palindrome_str_check(value: str):
    """
    function to print whether string is palindrome or not
    """
    if isinstance(value, str) :
        print( value.lower() == value[::-1].lower() )
    else:
        raise ValueError('Invalid Input')


# DD/MM/YYYY प्रारूप में दी गई तारीख मान्य है या नहीं, यह जांचने के लिए एक फ़ंक्शन लिखें
def date_validation(inputdate: str):
    """
    function take input date in DD/MM/YYYY format and check its validation.
    """
    import datetime
    dd, mm, year = inputdate.split('/')
    isValidDate = True
    try :
        datetime.datetime(int(year),int(mm), int(dd))
    except ValueError : 
        isValidDate = False
    if(isValidDate):
        print ("Input Date is Valid")
    else:
        print ("Input Date is invalid")


# विभाजक की गिनती मुद्रित करने के लिए एक फ़ंक्शन लिखें
def divisor_count(num: int):
    """
    function to count the number of divisor of interger.
    """
    if isinstance(num, int):
        count = 0
        for i in range(1, num+1):
            if num%i == 0:
                count = count+1
        print(f'Number of divisor is {count}')
    else:
        raise ValueError('Invalid Input')


# सूची समझ का उपयोग करके विभाजक की गिनती मुद्रित करने के लिए एक फ़ंक्शन लिखें
def divisor_using_list(num: int):
    """
    function to count the number of divisor using list comprehension.
    """
    if isinstance(num, int):
        count = [i for i in range(1,num+1) if not num%i]
        print(f'Number of divisor is {count}')
    else:
        raise ValueError('Invalid Input')


# दो डिक्शनरी के मर्जर को प्रिंट करने के लिए एक फंक्शन लिखें
def merge_dict(dict1: dict, dict2: dict):
    """
    function to print merger of two dictionary
    """
    final_dict = {**dict1, **dict2}
    print(final_dict)


# किसी सूची में दूसरी सबसे बड़ी संख्या को प्रिंट करने के लिए एक फंक्शन लिखें
def second_large_num(num: list):
    if isinstance(num, list):
        num.sort()
        print (num[-2])
    else:
        raise ValueError('Invalid Input')


# सूची से खाली सूची को हटाने और प्रिंट करने के लिए एक फ़ंक्शन लिखें
def remove_empty_list(num1: list):
    if isinstance(num1, list):
        modified = list(filter(None, num1))
        print(modified)


# एक सूची और प्रिंट से खाली टुपल्स को हटाने के लिए एक फ़ंक्शन लिखें
def remove_empty_tuple(num1: list):
    if isinstance(num1, list):
        modified = list(filter(None, num1))
        print(modified)


# सूची से डुप्लिकेट निकालने के लिए एक पायथन फ़ंक्शन लिखें
def remove_duplicates(dup_list: list):
    print(list(set(dup_list)))


# एक स्ट्रिंग में प्रत्येक शब्द को उलटने के लिए एक फ़ंक्शन लिखें
def reverse_word(sen: str):
    words = sen.split(' ')
    rever_word = [ i[::-1] for i in words ]
    final_sen = ' '.join(rever_word)
    print(final_sen)


# लीप वर्ष की जाँच करने के लिए कार्य
def check_leap_year(year: int):
    if not year%4:
        print('Leap Year')
    else:
        print('Not a leap year')


# गुणन सारणी को प्रिंट करने का कार्य
def maths_tables( no_ : int):
     for i in range(1, 11):
         print(f'{no_}x{i}={no_*i}')


# आर्मस्ट्रांग संख्या की जांच करने के लिए कार्य करें या नहीं
def check_armstrong(no_: int):
    sum_ = 0
    temp = no_
    while temp > 0:
        digit = temp % 10
        sum_ += digit ** 3 
        temp //= 10

    if no_ == sum_:  
       print(f"{no_} is an Armstrong number")  
    else:  
       print(f"{no_} is not an Armstrong number")


# एक सीमा में सभी आर्मस्ट्रांग को प्रिंट करने का कार्य
def print_all_armstrong(lower: int, upper: int):
    for num in range(lower,upper + 1):  
        sum_ = 0
        temp = num
        while temp > 0:
            digit = temp % 10
            sum_ += digit ** 3
            temp //= 10
            if num == sum_:
                print(num)

# दो नंबर के LCM को प्रिंट करने का कार्य
def ret_lcm(x: int, y: int):
    if x > y:
        greater = x
    else:
        greater = y
    while(True):
        if((greater % x == 0) and (greater % y == 0)):
            lcm = greater
            break
        greater += 1
    return lcm


# दो नंबरों के HCF को प्रिंट करने का कार्य
def ret_hcf(x: int, y: int):
    if x > y:
        greater = x
    else:
        greater = y
    while(True):
        if((greater % x == 0) and (greater % y == 0)):
            lcm = greater  
            break
        greater += 1
    return int(x*y/lcm)


# एक चरित्र के एएससीआई मूल्य को प्रिंट करने के लिए कार्य करता है
def show_ascii(a: str):
    print(ord(a))


# कैलेंडर प्रिंट करने का कार्य
def show_mm_calendar(mm: int, yyyy: int):
    import calendar
    print(calendar.month(yyyy, mm)


# एक ऐसा फ़ंक्शन बनाएं जो 1 और 10 के बीच संख्याओं की सूची लेता है (एक संख्या को छोड़कर) और लापता संख्या लौटाता है।
def print_miss_num(l: list):
     print(f'Missing number is {55-sum(l)}')


# स्ट्रिंग से समतुल्य मार्श कोड प्रिंट करने का कार्य

def encode_marsh(sen : str):
    char_to_dots = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
                      'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
                      'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
                      'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
                      'Y': '-.--', 'Z': '--..', ' ': ' ', '0': '-----',
                      '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....',
                      '6': '-....', '7': '--...', '8': '---..', '9': '----.',
                      '&': '.-...', "'": '.----.', '@': '.--.-.', ')': '-.--.-', '(': '-.--.',
                      ':': '---...', ',': '--..--', '=': '-...-', '!': '-.-.--', '.': '.-.-.-',
                      '-': '-....-', '+': '.-.-.', '"': '.-..-.', '?': '..--..', '/': '-..-.'
                    }
    for i in sen:
        print(char_to_dots[i.upper()])


# एक वाक्य को नजरबंद करने का कार्य
def check_intern(a , b):
    if a is b:
        print(f'{a} and {b} is interned by Python')
    else:
        print(f'{a} and {b} is not interned by Python')


# स्ट्रिंग को इंटर्न स्ट्रिंग में बदलें
def str_to_intern_str(a):
    import sys
    b = sys.intern(a)
    if a is b:
        print('Sentence is interned')
    else:
        raise ValueError('This should not happen')


# एक कैल्क फ़ंक्शन द्वारा 10 मिलियन बार एक साधारण गुणा करने के लिए लगने वाले समय को प्रिंट करने के लिए एक फ़ंक्शन लिखें
def time_calc(n: int):
    import time
    start = time.perf_counter()
    for i in range(10000000):
        n*2
    end = time.perf_counter()
    return end-start


# दिए गए आधार के साथ अन्य मान को इंट में प्रिंट करने के लिए एक फ़ंक्शन लिखें
def other_int(value, b):
    return int(value, b)


# किसी संख्या को उसके तुल्य भिन्न में बदलने के लिए एक फंक्शन लिखिए
def no_to_fraction(no_):
    from fractions import Fractions
    return Fractions(no_)


# दो नंबर (फ़्लोटिंग भी) की जाँच करने के लिए फ़ंक्शन पास हैं या नहीं
def check_isclose(x, y)
    from math import isclose
    return isclose(x, y)


# उपयोगकर्ता के उल्लेख के अनुसार तापमान को परिवर्तित करने का कार्य
def temp_converter(temp , temp_given_in= 'F'):
    if temp < 0:
        raise ValueError("Input Temperature is Negative")
    else:
        if temp_given_in.upper() == 'F':
            t = (temp-32)*5/9
            return t
        elif temp_given_in.upper() == 'C':
            t = 9/5 * (temp) + 32
            return t
        elif temp_given_in.upper() not in ('C' , 'F'):
            raise NotImplementedError("Invalid Temperature Coneversion")


# नियमित बहुभुज क्षेत्र को प्रिंट करने का कार्य

def polygon_area(side_length=1, side=3):
    from math import tan
    if side_length <= 0:
        raise ValueError("How come Side is zero.")
    else:
        if side <= 0 or side >=7:
            raise NotImplementedError 
        elif side in ( 2 , 1 ):
            raise ValueError("No Polygon of Side 1 & 2 Exists")
        elif side == 3:
            return side_length*side_length*side/4*tan(180/side)
        elif side == 4:
            return side_length*side_length
        elif side == 5:
            return side_length*side_length*side/4*tan(180/side)
        elif side == 6:
            return side_length*side_length*side/4*tan(180/side)


# उपयोगकर्ता के उल्लेखित डेटा के अनुसार गति परिवर्तक को वापस करने का कार्य

def speed_converter(speed , dist = 'KM', time = 'HR'):
    if speed < 0 or type(dist) == str or type(time) == str:
        raise ValueError("Invalid Input Format")
    else:
        if dist.upper == 'KM':
            if time.upper()  == 'S':
                return True
            elif time.upper == 'MS':
                return True
            elif time.upper() == 'M':
                return True
            elif time.upper() == 'HR':
                return True
            elif time.upper() == 'DAY':
                return True
            else:
                raise ValueError("Valid Distance Invalid Time")
        elif dist.upper == 'M':
            if time.upper()  == 'S':
                return True
            elif time.upper == 'MS':
                return True
            elif time.upper() == 'M':
                return True
            elif time.upper() == 'HR':
                return True
            elif time.upper() == 'DAY':
                return True
            else:
                raise ValueError("Valid Distance Invalid Time")
        elif dist.upper == 'FT':
            if time.upper()  == 'S':
                return True
            elif time.upper == 'MS':
                return True
            elif time.upper() == 'M':
                return True
            elif time.upper() == 'HR':
                return True
            elif time.upper() == 'DAY':
                return True
            else:
                raise ValueError("Valid Distance Invalid Time")
        elif dist.upper == 'YRD':
            if time.upper()  == 'S':
                return True
            elif time.upper == 'MS':
                return True
            elif time.upper() == 'M':
                return True
            elif time.upper() == 'HR':
                return True
            elif time.upper() == 'DAY':
                return True
            else:
                raise ValueError("Valid Distance Invalid Time")
        else:
            raise ValueError("Invalid User Distance Input")


# शब्दकोश से मान निकालने का कार्य
def remove_dic_value(a: dict, key)
    a.pop(key)
    return a


# शब्दकोश की शुरुआत में समारोह सम्मिलित करें
def dict_in_at_begin(orgin: dict, new_: dict):
    final = {**new_, **origin}
    return final


# टुपल्स की सूची को शब्दकोश में बदलने का कार्य
# Input  : [ ('a',1), ('b', 2), ('c', 3)]
# Output : { 'a':1, 'b':2, 'c':3 }
def list_to_dict(l: list):
    final_dict = {}
    for i in l:
        final_dict[i[0]] = i[1]
    return final_dict


# कुंजी के संबंध में शब्दकोश को सॉर्ट करने का कार्य
def dict_sort_with_key(test_dict: dict):
    final dict = {}
    temp = sorted(test_dict)
    for i in temp:
        final_dict[i] = test_dict[a]
    return final_dict


# एक पत्र के मिरिर वर्ण वापस करने के लिए कार्य

def mirror_character(word: str, value: int):
    import string
    letters = string.ascii_lowercase
    rev_letter = letters[::-1]
    dict_char = dict(zip(letters, rev_letter))
    final_1 = word[0:value]
    final_2 = []
    for i in range(value, len(word)):
        final_2.append(dict_char[word[i]])
    print(final_1+''.join(final_2))


# दो टपल जोड़ने का कार्य

def add_tuple(tup1, tup2):
    return tup1+tup2


# प्रत्येक टपल में संख्या और उसके घन वाली दी गई सूची से टुपल्स की सूची बनाने के लिए कार्य करें

def list_of_tuple( l: list):
    final = [ (i, pow(i,3)) for i in l]
    return final


# अक्षर के दर्पण का शब्दकोश बनाने का कार्य
def letter_mirror():
    import string
    letter = string.ascii_lowercase
    rvr_letter = letter[::-1]
    dict_char = dict(zip(letter, rvr_letter))
    return dict_char


# पत्र के एएससीआई मूल्य को प्रिंट करने का कार्य
def show_ascii():
    import string
    letter = string.ascii_letters
    for i in letter:
        print(i+":"+str(ord(i)))


# GMT पर वर्तमान समय प्राप्त करने के लिए कार्य करें
def current_time():
    import datetime
    print(datetime.datetime.now())


# भारत समय मुद्रित करने के लिए समारोह
def get_India_time():
    import datetime, pytz
    print(datetime.datetime.now( pytz.timezone('Asia/kolkata') ))


# समारोह कल और कल की तारीख मुद्रित करने के लिए
def tmrw_yest_time()
    import datetime
    yesterday = datetime.datetime.now() - datetime.timedelta(1)
    tmrw = datetime.datetime.now() + datetime.timedelta(1)
    print( yesterday, tmrw )


# सार्वभौमिक कार्य
def universal_func(*args, **kwargs):
    print(args)
    print(**kwargs)


# लॉगिंग संदेश
def logging(msg, *, dt = datetime.utcnow()):
    print(f'message at {dt} was {msg}')


# पुनरावर्तन का उपयोग करके संख्या का भाज्य
def factorial(n: int):
    if n<1:
        return 1
    else:
        return n * factorial(n-1)


# प्रथम श्रेणी समारोह
def call_func(x, func):
    return fn(x)


# दस्तावेज दिखाने के लिए समारोह
def doc_func(*args, **kwargs):
    """
    function to show how to do do documentation of function
    First line after function wriiten inside triple quotes.
    Don't forget to close when job is done.
    """
    pass


# एनोटेशन दिखाने के लिए कार्य करें
def anno_func(a: "Mandatory",
              b: "Optional"=2,
              c: "Optional"=10,
              *args: "Extra Position variable",
              **kwargs: "Provide extra to unpack dictionary") -> 'Documentation to show how to do do annotation':
    """
    function to show how to do do documentation of function
    First line after function wriiten inside triple quotes.
    Don't forget to close when job is done.
    """
    pass


# फ़ंक्शन यह जांचने के लिए कि दिया गया नाम फ़ंक्शन या विधि है या नहीं
def inspect_func(fn):
    from inspect import isfunction, ismethod
    print(f'{fn} is method {ismethod(func)}')
    print(f'{fn} is function {isfunction(func)}')


# फ़ंक्शन के स्रोत कोड को प्रिंट करने के लिए फ़ंक्शन

def print_so(f: "Function name/class name/module"):
    from inspect import getsource
    print(getsource(f))


# ज़िप दो टपल
def zip_to_tuple( tup1, tup2):
    return zip(tup1, tup2)


# pythonish का उपयोग करके फैक्टोरियल
def fact_one_line(n):
    return 1 if n < 2 else n*fact_one_line(n-1)


# सभी कार्यान्वयन के लिए कार्य करें
def all_imp(a):
   return all(a)


# किसी भी कार्यान्वयन के लिए कार्य करें
def any_imp(a):
   return any(a)


# बूलियन को सही/गलत दिखाने का कार्य एक संख्या है
def bool_show(a=5):
    return True*a



# वैश्विक चर कार्यान्वयन का उपयोग करने के लिए कार्य
def gloabl_use(n):
    global val
    return val * n


# स्थानीय अवधारणा का कार्यान्वयन
def inner_show():
    x = 'Hola'
    def inner():
        nonlocal x
        x = 'Hola World'
        print(f'Inner function x is {x}')
    inner()
    print(f'outer function x is {x}')


# कस्टम काउंटर समारोह
def custom_counter():
    """
    An implementation of closures
    """
    x = 0
    def inner():
       nonlocal x
       x += 1
       print(f' Switch or button is called {x} times')
     return inner


# काउंटर के साथ कस्टम लॉगिंग
def custom_counter_log():
    """
    An implementation of closures
    """
    x = 0
    dt = datetime.now()
    def inner():
       nonlocal x
       x += 1
       print(f' Switch or button is called {x} at {dt}')
     return inner

# एक समय व्यतीत बंद करने के लिए कार्य करें
def time_elsaped()
    start = perf_counter()
    def inner()
        nonlocal perf_counter
        return perf_counter() - start
    return inner


# कार्य करने के लिए काउंटर संलग्न करने के लिए कार्य
def attach_counter(fn: "Function"):
    count = 0
    def inner(*args, **kwargs):
        nonlocal count
        count += 1
        return fn(*args, **kwargs)
    return inner



# लॉग विवरण के साथ फ़ंक्शन क्लोजर को दूसरे फ़ंक्शन में संलग्न करें
def attach_log(fn: "function"):
    def inner(*args, **kwargs):
        dt = datetime.now()
        print(f'{fn.__name__} is called at {dt} with {args} {kwargs} ')
        return fn(*args, **kwargs)
    return inner


# फंक्शन काउंटर एक डिक्शनरी में कॉल किए गए मल्टीपल फंक्शन की संख्या को स्टोर करने के लिए
def count_func_dict(fn: "Function Name"):
    count = 0
    def inner(*args, **kwargs):
        nonlocal count
        count =+= 1
        counter_67[fn.__name__] = count
        return fn(*args, **kwargs)
    return inner


# असीमित लंबाई int पहले दो और बाकी के लिए न्यूनतम 2 मान के टपल को अनपैक करने के लिए एक फ़ंक्शन लिखें
def unpack_tuple(tup):
    a, b , *c = tup
    return a , b, c



# एक फ़ंक्शन लिखें जो असीमित संख्या लेता है और इसे जोड़ता है
def add_unlimited(*args):
    return sum(args)


# जब भी क्लास के ऑब्जेक्ट को कॉल किया जाता है तो यूजर डिफाइंड मैसेज को प्रिंट करने के लिए क्लास को कॉल किया जाता है
class User:
    def __init__(self, msg="Demo of custom message by repr and str in class"):
        self.msg = msg

    def __repr__(self):
        return f"Object of User class is called with parameter {self.msg}"

    def __str__(self):
        return f"Object of User class is called with parameter {self.msg}"



# वर्ग समानता के कार्यान्वयन और एक वर्ग में कार्यान्वयन से कम दिखाने के लिए

class GqLt:
    def __init__(self, msg="Demo of lt and eq in class"):
        self.msg = msg

    def __eq__(self, other):
        """
        Equality check between two object of same class.
        It is mandatory to implement __eq__ in class to do equality check.
        """
        if isinstance(other, GqLt):
            return "Code to be written here to match equality check between two object of same class"
        else:
            raise ValueError('Invalid comparison')

    def __lt__(self, other):
        """
        Less than or greater than check between two objects of same class.
        It is mandatory to implement __eq__ in class to do equality check.
        """
        if isinstance(other, GqLt):
            return "Code to be written here to match equality check between two object of same class"
        else:
            raise ValueError('Invalid comparison')


# क्लास को यह दिखाने के लिए कि क्लास को कॉल करने योग्य कैसे बनाया जाए
class CallShow:
    """
    This is the space to do documentation related to class.
    """
    def __init__(self, msg = 'Demo class to show how to make class object as callable'):
        self.msg = msg

    def __call__(self):
        """
        to make object as callable the class should have __call__ in it
        """
        return f"Code to be writen here above to act as per accling object of call"


# Namedtuple में IPL मैच के डेटा को स्टोर करने का कार्य
def store_ipl_date(tuple1):
    from collections import namedtuple
    IplData = namedtuple('IplData', 'match toss choice session1 session2 winner')
    return IplData(*tuple1)


# नामांकित दिखाने के लिए कार्य टपल का उदाहरण है
def show_ins_tup():
    from collections import namedtuple
    IplData = namedtuple('IplData', 'match toss choice session1 session2 winner')
    match1 = IplData('RCBvsKKR', 'KKR', 'bat', '229/9', '85/8', 'KKR')
    return isinstance(match1, tuple)


# दो वैक्टरों का रिटर्न डॉट उत्पाद
def dot_product(a: "Vector1", b: "Vector2"):
    return sum( e[0]*e[1] for e in zip(a,b) )


# namedtuple के दस्तावेज दिखाने के लिए कार्य
def show_doc_named():
    from collections import namedtuple
    IplData = namedtuple('IplData', 'match toss choice session1 session2 winner')
    IplData.__doc__ = 'Namedtuple class to store the IPL match data'
    IplData.match.__doc__ = 'Team name'
    IplData.toss.__doc__ = 'Who won the toss'
    IplData.choice.__doc__ = 'Decision taken by wiinng team toss'
    IplData.session1.__doc__ = 'Run scored by Team1'
    IplData.session2.__doc__ = 'Run scored by Team2'
    IplData.winner.__doc__ = 'Winning Team'
    return help(IplData)


# एक फ़ंक्शन चलने पर सभी स्थानीय मान दिखाएं
def show_local():
    import math
    a = 10
    b = 'Hello There'
    print(locals())


# कक्षा स्थिर विधि के कार्यान्वयन को दिखाने के लिए
class Mathematics:
    """
    This is the space to do documentation related to class.
    """
    def __init__(self, msg="Demo class of Mathematics"):
        self.msg = msg

    def __str__(self):
        return f' String representation of an object'

    def __repr__(self):
        return f' repr representation of an object with parameter {self.msg}'

    @staticmethod
    def addition(a: "Variable1", b: 'Variable2'):
        """
        @staticmethod makes the mtethod of class as static method.
        It is always recommended to metion it via decorator.
        """
        return a+b


# वर्ग सूची के कस्टम अनुक्रम के कार्यान्वयन को दिखाने के लिए
class CustomList:
    """
    This is the space to do documentation related to class.
    """
    def __init__(self):
        self.list_ = [1,2,3,4]

    def __len__(self):
        return len(self.list_)

    def __getitem__(self, i):
        if isinstance(i, int):
            if i<0:
                i = len(self.list_) + i
            
            if i<0 or i>=len(self.list_):
                raise IndexError('Invalid Input')
            else:
                return self.list_[i]


# वर्ग टपल के कस्टम अनुक्रम के कार्यान्वयन को दिखाने के लिए
class CustomTuple:
    """
    This is the space to do documentation related to class.
    """
    def __init__(self):
        self.list_ = (1,2,3,4)

    def __len__(self):
        return len(self.list_)

    def __getitem__(self, i):
        if isinstance(i, int):
            if i<0:
                i = len(self.list_) + i
            
            if i<0 or i>=len(self.list_):
                raise IndexError('Invalid Input')
            else:
                return self.list_[i]


# उपयोगकर्ता की पसंद के बीच पूर्णांक यादृच्छिक संख्या उत्पन्न करें
def gen_ran_int_number(lower, upper):
    import random
    final = [ random.randint(lower, upper) for _ in range(10) ]
    return final


# f स्ट्रिंग का उपयोग करने का तरीका दिखाने के लिए फ़ंक्शन
def f_string(msg: "user message"):
    print(f'This is an f string with user paramter {msg}')


# टपल की तुलना में सूची से पढ़ने के मूल्यों को दिखाने का कार्य महंगा है
def compare_list_tuple():
    from timeit import timeit
    import random
    l = [ random.randint(1,100) for _ in range(100) ]
    tu = tuple(l)
    list_time = timeit(stmt = 'max(l)', globals = locals(), number = 1)
    tup_time = timeit(stmt = 'max(tu)', globals = locals(), number = 1)
    if list_time > tup_time:
        print('Hence proved')
    else:
        raise ValueError('You did something Wrong')


# पुनरावृत्तियों की अवधारणा का उपयोग करके यादृच्छिक संख्या उत्पन्न करें

class RandomInt:
    """
    This is the space to do documentation related to class.
    """
    def __init__(self):
       self.n = 10

    def __next__(self):
        if self.n > 0:
           print(random.randint(0,10))
           self.n -= 1
        else:
           raise StopIteration

    def __iter__(self):
        return self


# 10 यादृच्छिक पूर्णांक संख्या को प्रिंट करने के लिए उदाहरण का उपयोग करके iter, iterables और iterator में अंतर करें
class RandomInt:
    """
    This is the space to do documentation related to class.
    """
    def __init__(self):
       pass

    def __iter__(self):
        return self.RandomIntIterator(self)

    class RandomIntIterator:
        def __init__(self):
            self.count = 10

        def __iter__(self):
            return self

        def __next__(self):
            if self.count > 0:
                print(random.randint(0,10))
                self.count -= 1
            else:
                raise StopIteration


# टपल के उदाहरण का उपयोग करके कस्टम अनुक्रम प्रकार, iter, iterables और iterator की कक्षा दिखाएं
class CustomTupleIter:
    """
    This is the space to do documentation related to class.
    """
    def __init__(self):
        self.list_ = (1,2,3,4)

    def __len__(self):
        return len(self.list_)

    def __getitem__(self, i):
        if isinstance(i, int):
            if i<0:
                i = len(self.list_) + i

            if i<0 or i>=len(self.list_):
                raise IndexError('Invalid Input')
            else:
                return self.list_[i]

    def __iter__(self):
        return self.CustomTupleIterator(self)

    class CustomTupleIterator:
        def __init__(self, other):
            self.count = 0
            self.other = other

        def __iter__(self):
            return self

        def __next__(self):
            if self.count < len(self.other.list_):
                self.count += 1
                return self.other.list_[self.count]
            else:
                raise StopIteration


# दो कार्यात्मकता के साथ मूल सूची का क्लोन i. पुनरावृत्ति और अनुक्रम
class CustomListIter:
    """
    This is the space to do documentation related to class.
    """
    def __init__(self):
        self.list_ = [1,2,3,4]

    def __len__(self):
        return len(self.list_)

    def __getitem__(self, i):
        if isinstance(i, int):
            if i<0:
                i = len(self.list_) + i

            if i<0 or i>=len(self.list_):
                raise IndexError('Invalid Input')
            else:
                return self.list_[i]

    def __iter__(self):
        return self.CustomListIterator(self)

    class CustomListIterator:
        def __init__(self, other):
            self.count = 0
            self.other = other

        def __iter__(self):
            return self

        def __next__(self):
            if self.count < len(self.other.list_):
                self.count += 1
                return self.other.list_[self.count]
            else:
                raise StopIteration


# एक वर्ग लिखें जो वर्गों की तरह कार्य करता है और मूल्यों और कस्टम अनुक्रम प्रकार के वर्गों को मुद्रित करना चाहिए।
class Square:
    def __init__(self, n):
        self.n = n

    def __iter__(self):
        return self.show_sq(self.n)

    @staticmethod
    def show_sq(n):
         for i in range(n):
             yield i**2

    def __getitem__(self, i):
       if isinstance(i, int):
            if i < = self.n:
                print(i**2)
            else:
                raise ValueError('Index out of bound')


# फाइबोनैसी जनरेटर का उपयोग कर
def fibo(n):
    x = 0
    yield x
    y = 1
    yield y
    for i in range(n-1):
        x, y = y, x+y
        yield y



# शो जनरेटर सूची से तेज है
def show_gen_fast():
    from timeit import timeit
    dt = timeit("[num for num in fib(100) ]", globals = globals(), number=1)
    return dt

# दो strings जोड़ें
def add_str(str1,str2):
   return str1 + str2

# हम एकाधिक विरासत से निपट रहे हैं
class A(object):
    def foo(self):
        print("class A")

class B(object):
    def foo(self):
        print("class B")

class C(A, B):
    pass

# मल्टीपल इनहेरिटेंस के मामले में पास कैसे काम करता है
class A1(object):
   def foo(self):
      print("class A1")

class B1(A1):
   pass

class C1(A1):
   def foo(self):
      print("class C1")

class D1(B1,C1):
   pass

# सूची परिवर्तनशील हैं
a_list = []
print('ID:', id(a_list))
a_list += [1]
print('ID (+=):', id(a_list))
a_list = a_list + [2]
print('ID (list = list + ...):', id(a_list))

# सभी रिक्त सूचियाँ समान नहीं हैं
a_list = []
print(a_list, '\nID (initial):',id(a_list), '\n')
a_list.append(1)
print(a_list, '\nID (append):',id(a_list), '\n')
a_list.extend([2])
print(a_list, '\nID (extend):',id(a_list))

# डेटाटाइम मॉड्यूल में सही और गलत
from platform import python_version
import datetime

print("Current python version: ", python_version())
print('"datetime.time(0,0,0)" (Midnight) ->', bool(datetime.time(0,0,0))) # Python version <= 3.4.5 evaluates this statement to False

# पायथन छोटे पूर्णांकों के लिए वस्तुओं का पुन: उपयोग करता है - समानता के लिए "==" का उपयोग करें, पहचान के लिए "है"
a = 1
b = 1
print('a is b', bool(a is b))
c = 999
d = 999
print('c is d', bool(c is d))

# समानता ऑपरेटर इस तरह काम करता है
print('256 is 257-1', 256 is 257-1)
print('257 is 258-1', 257 is 258 - 1)
print('-5 is -6+1', -5 is -6+1)
print('-7 is -6-1', -7 is -6-1)

# समानता (==) बनाम पहचान (है) के लिए परीक्षण का वर्णन करें
a = 'hello world!'
b = 'hello world!'
print('a is b,', a is b)
print('a == b,', a == b)

# हम सोचेंगे कि पहचान का अर्थ हमेशा समानता होगा, लेकिन यह हमेशा सच नहीं होता, जैसा कि हम अगले उदाहरण में देख सकते हैं:
a = float('nan')
print('a is a,', a is a)
print('a == a,', a == a)

# अजगर में उथला प्रति
list1 = [1,2]
list2 = list1        # reference
list3 = list1[:]     # shallow copy
list4 = list1.copy() # shallow copy
print('IDs:\nlist1: {}\nlist2: {}\nlist3: {}\nlist4: {}\n'
      .format(id(list1), id(list2), id(list3), id(list4)))

# पायथन में डीपकॉपी

list1 = [[1],[2]]
list2 = list1.copy()    # shallow copy
list3 = deepcopy(list1) # deep copy
print('IDs:\nlist1: {}\nlist2: {}\nlist3: {}\n'
      .format(id(list1), id(list2), id(list3)))

#logical or logical and 
result = (2 or 3) * (5 and 7)
print('2 * 7 =', result)

# कार्यों के लिए डिफ़ॉल्ट तर्क के रूप में परिवर्तनशील वस्तुओं का उपयोग न करें
def append_to_list(value, def_list=[]):
    def_list.append(value)
    return def_list
my_list = append_to_list(1)
print(my_list)

my_other_list = append_to_list(2)
print(my_other_list)

# बहस करो और सो जाओ
import time
def report_arg(my_default=time.time()):
    print(my_default)
report_arg()
time.sleep(5)
report_arg()

# जनरेटर की खपत होती है
gen = (i for i in range(5))
print('2 in gen,', 2 in gen)
print('3 in gen,', 3 in gen)
print('1 in gen,', 1 in gen) 

# जनरेटर को सूची में बदलें
gen = (i for i in range(5))
a_list = list(gen)

# बूल वर्ग का उपयोग
print('isinstance(True, int):', isinstance(True, int))

# लैम्ब्डा फ़ंक्शन का उपयोग करके संख्याओं की सूची बनाएं, लेकिन सही तरीके से नहीं
my_list = [lambda: i for i in range(5)]
for l in my_list:
    print(l())

# सूची बनाकर संख्याओं को ठीक से प्रिंट करें
my_list = [lambda x=i: x for i in range(5)]
for l in my_list:
    print(l())

# स्थानीय गुंजाइश प्रतिनिधित्व
x = 0
def in_func():
    x = 1
    print('in_func:', x)

# वैश्विक स्कोप प्रतिनिधित्व
x = 0
def in_func1():
    x = 1
    print('in_func1:', x)
print('global:', x)

# वैश्विक कीवर्ड का उपयोग
x = 0
def in_func2():
    global x
    x = 1
    print('in_func2:', x)
in_func2()
print('global:', x)

# स्थानीय बनाम संलग्न
def outer():
    x = 1
    print('outer before:', x)

    def inner():
        x = 2
        print("inner:", x)
    inner()
    print("outer after:", x)
outer()

# गैर-स्थानीय कीवर्ड काम आता है
def outer():
    x = 1
    print('outer before:', x)

    def inner():
        nonlocal x
        x = 2
        print("inner:", x)
    inner()
    print("outer after:", x)
outer()

# tuples अपरिवर्तनीय हैं
tup = (1,)
tup[0] += 1

# क्या होगा अगर हम एक अपरिवर्तनीय वस्तु को अपरिवर्तनीय टपल में डालते हैं
tup1 = ([],)
print('tup before: ', tup1)
tup1[0] += [1]


# TypeError को बढ़ाए बिना tuple की परिवर्तनशील सामग्री को संशोधित करने के तरीके हैं
tup = ([],)
print('tup before: ', tup)
tup[0].extend([1])
print('tup after: ', tup)

# टुपल में डेटा जोड़ने का दूसरा तरीका
tup = ([],)
print('tup before: ', tup)
tup[0].append(1)
print('tup after: ', tup)

# न्यूमेरिक्स की तरह टुपल्स जोड़ें
my_tup = (1,)
my_tup += (4,)
my_tup = my_tup + (5,)
print(my_tup)

# पर्दे के "पीछे" क्या होता है कि टपल को संशोधित नहीं किया जाता है, लेकिन हर बार एक नई वस्तु उत्पन्न होती है, जो पुराने "नाम टैग" को विरासत में देगी
my_tup = (1,)
print(id(my_tup))
my_tup += (4,)
print(id(my_tup))
my_tup = my_tup + (5,)
print(id(my_tup))

# एक सादा सूची बनाएँ

def plainlist(n=100000):
    my_list = []
    for i in range(n):
        if i % 5 == 0:
            my_list.append(i)
    return my_list

# एक सूची समझ बनाएँ
def listcompr(n=100000):
    my_list = [i for i in range(n) if i % 5 == 0]
    return my_list

# जेनरेटर बनाएं
def generator(n=100000):
    my_gen = (i for i in range(n) if i % 5 == 0)
    return my_gen

# उपज समारोह का उपयोग कर जेनरेटर
def generator_yield(n=100000):
    for i in range(n):
        if i % 5 == 0:
            yield i

# जेनरेटर सूची समझ से तेज़ हैं
import timeit
def test_plainlist(plain_list):
    for i in plain_list():
        pass


def test_listcompr(listcompr):
    for i in listcompr():
        pass


def test_generator(generator):
    for i in generator():
        pass


def test_generator_yield(generator_yield):
    for i in generator_yield():
        pass
print('plain_list:     ', end='')
%timeit test_plainlist(plainlist)
print('\nlistcompr:     ', end='')
%timeit test_listcompr(listcompr)
print('\ngenerator:     ', end='')
%timeit test_generator(generator)
print('\ngenerator_yield:     ', end='')
%timeit test_generator_yield(generator_yield)

# सार्वजनिक बनाम निजी वर्ग के तरीके और नाम प्रबंधन
    def public_method(self):
        print('Hello public world!')

    def __private_method(self):
        print('Hello private world!')

    def call_private_method_in_class(self):
        self.__private_method()


my_instance = my_class()

my_instance.public_method()
my_instance._my_class__private_method()
my_instance.call_private_method_in_class()

# इसके माध्यम से लूपिंग करते समय किसी सूची को संशोधित करने के परिणाम
a = [1, 2, 3, 4, 5]
for i in a:
    if not i % 2:
        a.remove(i)
print(a)
b = [2, 4, 5, 6]
for i in b:
     if not i % 2:
         b.remove(i)
print(b)

#  सूचकांक द्वारा सूची सूचकांक के माध्यम से पुनरावृति
b = [2, 4, 5, 6]
for index, item in enumerate(b):
    print(index, item)
    if not item % 2:
        b.remove(item)
print(b)

# चर नामों में डायनेमिक बाइंडिंग और टाइपोस
print('first list:')
for i in range(3):
    print(i)
    
print('\nsecond list:')
for j in range(3):
    print(i) # I (intentionally) made typo here!

# "श्रेणी से बाहर" इंडेक्स का उपयोग करके स्लाइसिंग की सूची बनाएं
my_list = [1, 2, 3, 4, 5]
print(my_list[5])

# वैश्विक चर नामों और अनबाउंडलोकल एरर्स का पुन: उपयोग करना
def my_func():
    print(var)
var = 'global'
my_func()

# स्थानीय समकक्ष को प्रभावित किए बिना स्थानीय दायरे में समान चर नाम का उपयोग करने में कोई समस्या नहीं है:
def my_func():
    var = 'locally changed'
var = 'global'
my_func()
print(var)

# यदि हम एक चर नाम का उपयोग करते हैं जो वैश्विक दायरे में होता है, तो हमें सावधान रहना होगा, और यदि हम इस नाम का पुन: उपयोग करना चाहते हैं तो हम इसे स्थानीय कार्य क्षेत्र में एक्सेस करना चाहते हैं
def my_func():
    print(var)  # want to access global variable
    var = 'locally changed'  # but Python thinks we forgot to define the local variable!

var = 'global'
my_func()

# हमें वैश्विक कीवर्ड का उपयोग करना होगा

def my_func():
    global var
    print(var)  # want to access global variable
    var = 'locally changed'  # changes the gobal variable
var = 'global'
my_func()
print(var)

# परिवर्तनशील वस्तुओं की प्रतियां बनाना
my_list1 = [[1, 2, 3]] * 2
print('initially ---> ', my_list1)
my_list1[1][0] = 'a'
print("after my_list1[1][0] = 'a' ---> ", my_list1)

# हमें "नई" वस्तुओं को बेहतर बनाना चाहिए
my_list2 = [[1, 2, 3] for i in range(2)]
print('initially:  ---> ', my_list2)
my_list2[1][0] = 'a'
print("after my_list2[1][0] = 'a':  ---> ", my_list2)

for a, b in zip(my_list1, my_list2):
    print('id my_list1: {}, id my_list2: {}'.format(id(a), id(b)))

# अंत में ब्लॉक में निष्फल बयान
def try_finally1():
    try:
        print('in try:')
        print('do some stuff')
        float('abc')
    except ValueError:
        print('an error occurred')
    else:
        print('no error occurred')
    finally:
        print('always execute finally')
try_finally1()

# मानों के रूप में चरों को प्रकार निर्दिष्ट करना
a_var = str
a_var(123)

# यादृच्छिक पसंद
from random import choice

a, b, c = float, int, str
for i in range(5):
    j = choice([a,b,c])(i)
    print(j, type(j))


# जेनरेटर का केवल पहला खंड तुरंत मूल्यांकन किया जाता है
gen_fails = (i for i in 1/0)

# आलसी मूल्यांकन
gen_succeeds = (i for i in range(5) for j in 1/0)
print('But obviously fails when we iterate ...')
for i in gen_succeeds:
    print(i)

# *args का उपयोग
def a_func(*args):
    print('type of args:', type(args))
    print('args contents:', args)
    print('1st argument:', args[0])
a_func(0, 1, 'a', 'b', 'c')

# kwargs का उपयोग
def b_func(**kwargs):
    print('type of kwargs:', type(kwargs))
    print('kwargs contents: ', kwargs)
    print('value of argument a:', kwargs['a'])

b_func(a=1, b=2, c=3, d=4)

# पुनरावृति की अनपैकिंग
val1, *vals = [1, 2, 3, 4, 5]
print('val1:', val1)
print('vals:', vals)

# अगर और के लिए
for i in range(5):
    if i == 1:
        print('in for')
else:
    print('in else')
print('after for-loop')

# ब्रेक का उपयोग
for i in range(5):
    if i == 1:
        break
else:
    print('in else')
print('after for-loop')

# सशर्त उपयोगकेस
a_list = [1,2]
if a_list[0] == 1:
    print('Hello, World!')
else:
    print('Bye, World!')

# जबकि का उपयोग
i = 0
while i < 2:
    print(i)
    i += 1
else:
    print('in else')

# स्ट्रिंग का इंटर्निंग
hello1 = 'Hello'
hello2 = 'Hell' + 'o'
hello3 = 'Hell'
hello3 = hello3 + 'o'
print('hello1 is hello2:', hello1 is hello2)
print('hello1 is hello3:', hello1 is hello3)

# उदाहरण डॉकस्ट्रिंग के उपयोग को प्रदर्शित करने के लिए
def greet(name):
    """
    This function greets to
    the person passed in as
    a parameter
    """
    print("Hello, " + name + ". Good morning!")

# निरपेक्ष कार्य
def absolute_value(num):
    """This function returns the absolute
    value of the entered number"""

    if num >= 0:
        return num
    else:
        return -num
print(absolute_value(2))
print(absolute_value(-4))

# शब्दकोश का उपयोग
dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}
print "dict['Name']: ", dict['Name']
print "dict['Age']: ", dict['Age']

# उपयोगकर्ता इनपुट स्वीकार करें
str = input("Enter your input: ")
print ("Received input is : ", str)

# Nth कैटलन नंबर खोजने के लिए एक पुनरावर्ती कार्य
def catalan(n): 
    # Base Case 
    if n <= 1: 
        return 1
  
    # Catalan(n) is the sum  
    # of catalan(i)*catalan(n-i-1) 
    res = 0
    for i in range(n): 
        res += catalan(i) * catalan(n-i-1) 
  
    return res 
  
for i in range(10): 
    print (catalan(i))

# एक सहज पुनरावर्ती पायथन कार्यान्वयन
  
def binomialCoeff(n , k): 
  
    if k > n : 
       return 0
    if k==0 or k ==n : 
        return 1
  
    # Recursive Call 
    return binomialCoeff(n-1 , k-1) + binomialCoeff(n-1 , k) 

n = 5
k = 2
print ("Value of C(%d,%d) is (%d)" %(n , k , binomialCoeff(n , k)) )

# एलआईएस समस्या का एक सहज पायथन कार्यान्वयन

global maximum 
  
def _lis(arr , n ): 
  
    # to allow the access of global variable 
    global maximum 
  
    # Base Case 
    if n == 1 : 
        return 1
  
    # maxEndingHere is the length of LIS ending with arr[n-1] 
    maxEndingHere = 1
  
    """Recursively get all LIS ending with arr[0], arr[1]..arr[n-2] 
       IF arr[n-1] is maller than arr[n-1], and max ending with 
       arr[n-1] needs to be updated, then update it"""
    for i in range(1, n): 
        res = _lis(arr , i) 
        if arr[i-1] < arr[n-1] and res+1 > maxEndingHere: 
            maxEndingHere = res +1
  
    # Compare maxEndingHere with overall maximum. And 
    # update the overall maximum if needed 
    maximum = max(maximum , maxEndingHere) 
  
    return maxEndingHere 
  
def lis(arr): 
  
    # to allow the access of global variable 
    global maximum 
  
    # lenght of arr 
    n = len(arr) 
  
    # maximum variable holds the result 
    maximum = 1
  
    # The function _lis() stores its result in maximum 
    _lis(arr , n) 
  
    return maximum 
  
arr = [10 , 22 , 9 , 33 , 21 , 50 , 41 , 60] 
n = len(arr) 
print ("Length of lis is ", lis(arr) )

# nवें फाइबोनैचि संख्या के लिए कार्य

def Fibonacci(n): 
    if n<0: 
        print("Incorrect input") 
    # First Fibonacci number is 0 
    elif n==0: 
        return 0
    # Second Fibonacci number is 1 
    elif n==1: 
        return 1
    else: 
        return Fibonacci(n-1)+Fibonacci(n-2) 
  
  
print(Fibonacci(9)) 

# समान लंबाई की दो सूची जोड़ने के लिए एक पायथन प्रोग्राम लिखें
def add_two_list_items():
    num1 = [1,2,3]
    num2 = [4,5,6]
    sum = num1 + num2
    print(f'Sum: {sum}')


# यदि पहली सूची का आइटम सम है और दूसरी सूची का आइटम विषम है, तो दो सूची से संख्याएँ जोड़ने के लिए एक पायथन प्रोग्राम लिखें
def add_two_lists_even_odd(l1, l2):
    new = []
    for x, y in zip(l1, l2):
        if l1%2 == 0 and l2%2 != 0:
            new.append(x+y)
    return new

# एक पायथन कार्यक्रम लिखें KM/H को MPH में बदलें
kmh = 50
mph =  0.6214 * kmh
print("Speed:", kmh, "KM/H = ", mph, "MPH")

# तीन संख्याओं में से सबसे छोटी संख्या को खोजने और प्रिंट करने के लिए एक प्रोग्राम लिखें
num1 = 100
num2 = 200
num3 = 300
if (num1 <= num2) and (num1 <= num3):
    smallest = num1
elif (num2 <= num1) and (num2 <= num3):
    smallest = num2
else:
    smallest = num3
print(f'smallest:{smallest}')

# सूची को क्रमबद्ध करने के लिए एक फ़ंक्शन लिखें
raw_list = [-5, -23, 5, 0, 23, -6, 23, 67]
sorted_list = []
while raw_list:
    minimum = raw_list[0]   
    for x in raw_list: 
        if x < minimum:
            minimum = x
    sorted_list.append(minimum)
    raw_list.remove(minimum)    

print(soreted_list)

# किसी फ़ंक्शन को चलाने में लगने वाले समय को प्रिंट करने के लिए एक फ़ंक्शन लिखें
import time
def time_it(fn, *args, repetitons= 1, **kwargs):
    start = time.perf_counter()
    if (repetitons <= 0):
        raise ValueError("repetitions should be greater that 0")
    if (not(isinstance(repetitons,int))):
        raise ValueError("Repetions must be of type Integer")
    for _ in range(repetitons):
        fn(*args, **kwargs)
    stop = time.perf_counter()
    return ((stop - start)/repetitons)



# साधारण ब्याज की गणना करने के लिए एक पायथन फ़ंक्शन लिखें
def simple_interest(p,t,r): 
   
    si = (p * t * r)/100
    return si 

# अंतराल में सभी प्राइम नंबरों को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
start = 11
end = 25
 
for i in range(start,end):
  if i>1:
    for j in range(2,i):
        if(i % j==0):
            break
    else:
        print(i)

# क्लोजर कॉन्सेप्ट का उपयोग करके शब्द को कितनी बार दोहराया गया है, यह रिकॉर्ड करने के लिए एक काउंटर को लागू करने के लिए एक पायथन फंक्शन लिखें
def word_counter():
    counter = {}
    def count(word):
        counter[word] = counter.get(word, 0) + 1
        return counter[word]
    return count

# एक स्ट्रिंग पैलिंड्रोम है या नहीं, यह जांचने और प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
st = 'malayalam'
j = -1
flag = 0
for i in st:
    if i != st[j]:
      j = j - 1
      flag = 1
      break
    j = j - 1
if flag == 1:
    print("Not a palindrome")
else:
    print("It is a palindrome")

# नियमित अभिव्यक्ति का उपयोग करके इनपुट स्ट्रिंग से URL खोजने के लिए एक पायथन फ़ंक्शन लिखें
import re 
def Find(string): 
    regex = r"(?i)\b((?:https?://|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'\".,<>?«»“”‘’]))"
    url = re.findall(regex,string)       
    return [x[0] for x in url] 
      
# सूची से एन सबसे बड़े तत्वों को खोजने के लिए एक पायथन प्रोग्राम लिखें
l = [1000,298,3579,100,200,-45,900] 
n = 4
l.sort() 
print(l[-n:])

# मानचित्र और लैम्ब्डा का उपयोग करके दो सूचियाँ जोड़ने के लिए एक पायथन प्रोग्राम लिखें
nums1 = [1, 2, 3]
nums2 = [4, 5, 6]
result = map(lambda x, y: x + y, nums1, nums2)
print(list(result))

# फ्लोट नंबरों की समानता का परीक्षण करने के लिए एक पायथन फ़ंक्शन लिखें
def float_equality_testing(a, b):
    
    rel_tol = 1e-12
    abs_tol = 1e-05
    return abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)

# बहुभुज क्षेत्र को कैलकुलेट करने के लिए एक पायथन फ़ंक्शन लिखें
def polygon_area( side_length, sides = 3):
    if(sides < 3 or sides > 6 ):
        raise ValueError("number of sides must be greater than 2 and less than 7")
    if(side_length < 0 ):
        raise ValueError("side length must be positive")

    return sides * (side_length ** 2) / (4 * tan(pi / sides))

# सूचियों की दी गई सूची से सकारात्मक तत्व प्राप्त करने के लिए एक पायथन प्रोग्राम लिखें
Input = [[10, -11, 222], [42, -222, -412, 99, -87]] 
temp = map(lambda elem: filter(lambda a: a>0, elem), Input) 
Output = [[a for a in elem if a>0] for elem in temp] 

# एक सूची से खाली टुपल्स को हटाने के लिए प्रोग्राम लिखें
def Remove(tuples): 
    tuples = filter(None, tuples) 
    return tuples

# किसी सूची का संचयी योग खोजने के लिए एक पायथन प्रोग्राम लिखें
list=[10,20,30,40,50]
new_list=[] 
j=0
for i in range(0,len(list)):
    j+=list[i]
    new_list.append(j) 
print(new_list)

# सूची को स्ट्रिंग में बदलने के लिए एक पायथन फ़ंक्शन लिखें
s = ['I', 'want', 4, 'apples', 'and', 18, 'bananas'] 
listToStr = ' '.join(map(str, s)) 
print(listToStr)

# 2 शब्दकोशों को मर्ज करने के लिए एक पायथन प्रोग्राम लिखें
x = {'a' : 1, 'b' : 2, 'c' : 3}
y = {'x' : 10, 'y' : 20, 'z' : 30 }
z = {**x , **y}

# सिग्मॉइड फ़ंक्शन को लागू करने के लिए एक पायथन कोड लिखें
import math
def sigmoid(x):
  return 1 / (1 + math.exp(-x))

# RELU फ़ंक्शन को लागू करने के लिए एक पायथन कोड लिखें
def relu(array):
    return [max(0,i) for i in array if(isinstance(i, int) or isinstance(i, float))]

# दी गई संख्या फाइबोनैचि है या नहीं, यह जांचने के लिए एक पायथन फ़ंक्शन लिखें
def fiboacci_number_check(n):
    if(isinstance(n,int)):
        result = list(filter(lambda num : int(math.sqrt(num)) * int(math.sqrt(num)) == num, [5*n*n + 4,5*n*n - 4] ))
        return bool(result) 
    else:
        raise TypeError("Input should be of type Int") 

# एक स्ट्रिंग में सभी स्वरों को निकालने के लिए एक पायथन प्रोग्राम लिखें
string = "Remove Vowel"
vowel = ['a', 'e', 'i', 'o', 'u']
"".join([i for i in string if i not in vowel]

# अगला फिबोनैकी नंबर देने के लिए एक पायथन प्रोग्राम लिखें

    num_1, num_2,count = 0, 1,0

    def next_fibbonacci_number() :
    
        nonlocal num_1, num_2, count

        if(count == 0):
            count+=1
            return 0
        elif(count==1):
            count+=1
            return num_2
        else:
            num_1, num_2 = num_2, num_1+num_2
            return num_2

    return next_fibbonacci_number
# किसी दिए गए नंबर के भाज्य की गणना करने के लिए एक पायथन फ़ंक्शन लिखें
def factorial(n):
    fact = 1
    for num in range(2, n + 1):
        fact = fact * num
    return(fact)

# एक पायथन प्रोग्राम लिखें जो ऐसी सभी संख्याएँ खोजेगा जो 7 से विभाज्य हैं लेकिन 2000 और 3200 के बीच 5 से अधिक नहीं हैं (दोनों शामिल हैं)
l=[]
for i in range(2000, 3201):
    if (i%7==0) and (i%5!=0):
        l.append(str(i))

print(','.join(l))

# 0 और 9 के बीच एक यादृच्छिक संख्या उत्पन्न करने के लिए पायथन प्रोग्राम लिखें
import csv
def read_csv(input_file):
    with open(input_file) as csv_file:
        csv_reader = csv.reader(csv_file, delimiter=',')
        for row in csv_reader:
                print(f'{row}')
                break

# एक यादृच्छिक संख्या उत्पन्न करने के लिए एक पायथन प्रोग्राम लिखें
import random
print(random.randint(0,9))

# लीप वर्ष की जाँच करने के लिए एक पायथन प्रोग्राम लिखें
year = 2000
if (year % 4) == 0:
   if (year % 100) == 0:
       if (year % 400) == 0:
           print(f"{year} is a leap year")
       else:
           print(f"{year} is not a leap year")
   else:
       print(f"{year} is a leap year")
else:
   print(f"{year} is not a leap year")

# LCM की गणना करने के लिए एक पायथन फ़ंक्शन लिखें
def compute_lcm(x, y):
   if x > y:
       greater = x
   else:
       greater = y

   while(True):
       if((greater % x == 0) and (greater % y == 0)):
           lcm = greater
           break
       greater += 1

   return lcm
# GCD की गणना करने के लिए एक पायथन फ़ंक्शन लिखें
def compute_gcd(x, y):

   while(y):
       x, y = y, x % y
   return x

# एक स्ट्रिंग से विराम चिह्नों को हटाने के लिए एक पायथन प्रोग्राम लिखें
punctuations = '''!()-[]{};:'"\,<>./?@#$%^&*_~'''
my_str = "Hello!!!, he said ---and went."
no_punct = ""
for char in my_str:
   if char not in punctuations:
       no_punct = no_punct + char
print(no_punct)

# फ़ाइल का हैश खोजने के लिए एक पायथन फ़ंक्शन लिखें
import hashlib
def hash_file(filename):

   h = hashlib.sha1()
   with open(filename,'rb') as file:
       chunk = 0
       while chunk != b'':
           chunk = file.read(1024)
           h.update(chunk)
   return h.hexdigest()

# जेपीईजी छवि के आकार (रिज़ॉल्यूशन) को खोजने के लिए एक पायथन प्रोग्राम लिखें और इसे प्रिंट करें
def jpeg_res(filename):
   with open(filename,'rb') as img_file:
       img_file.seek(163)

       a = img_file.read(2)

       # calculate height
       height = (a[0] << 8) + a[1]

       # next 2 bytes is width
       a = img_file.read(2)

       # calculate width
       width = (a[0] << 8) + a[1]

   print("The resolution of the image is",width,"x",height)

# प्रत्येक स्वर की संख्या गिनने के लिए एक पायथन प्रोग्राम लिखें
ip_str = 'Hello, have you tried our tutorial section yet?'
ip_str = ip_str.casefold()
count = {x:sum([1 for char in ip_str if char == x]) for x in 'aeiou'}
print(count)

# चरित्र के ASCII मूल्य का पता लगाने के लिए एक अजगर कार्यक्रम लिखें
c = 'p'
print("The ASCII value of '" + c + "' is", ord(c))

# द्विघात समीकरण को हल करने के लिए एक पायथन प्रोग्राम लिखें
import cmath
a = 1
b = 5
c = 6
d = (b**2) - (4*a*c)
sol1 = (-b-cmath.sqrt(d))/(2*a)
sol2 = (-b+cmath.sqrt(d))/(2*a)
print('The solution are {0} and {1}'.format(sol1,sol2))

# सेल्सियस को फ़ारेनहाइट में बदलने के लिए एक पायथन प्रोग्राम लिखें
celsius = 37.5
fahrenheit = (celsius * 1.8) + 32
print(f'{celsius} degree Celsius is equal to {fahrenheit} degree Fahrenheit')

# एन अंकों की आर्मस्ट्रांग संख्या की जांच के लिए एक पायथन प्रोग्राम लिखें
num = 1634
order = len(str(num))
sum = 0
temp = num
while temp > 0:
   digit = temp % 10
   sum += digit ** order
   temp //= 10
if num == sum:
   print(num,"is an Armstrong number")
else:
   print(num,"is not an Armstrong number")

# प्राकृतिक संख्याओं का योग ज्ञात करने के लिए एक पायथन प्रोग्राम लिखें
num = 16
if num < 0:
   print("Enter a positive number")
else:
   sum = 0
   while(num > 0):
       sum += num
       num -= 1
   print("The sum is", sum)

# कार्ड के डेक को शफल करने के लिए एक पायथन प्रोग्राम लिखें
import itertools, random
deck = list(itertools.product(range(1,14),['Spade','Heart','Diamond','Club']))
random.shuffle(deck)
print(deck)

# दशमलव को बाइनरी में बदलने के लिए एक पायथन फ़ंक्शन लिखें
def convertToBinary(n):
   if n > 1:
       convertToBinary(n//2)
   print(n % 2,end = '')

# wrtie a python function to solve Tower Of Hanoi and print necessary statements
def TowerOfHanoi(n , source, destination, auxiliary): 
    if n==1: 
        print("Move disk 1 from source",source,"to destination",destination) 
        return
    TowerOfHanoi(n-1, source, auxiliary, destination) 
    print("Move disk",n,"from source",source,"to destination",destination) 
    TowerOfHanoi(n-1, auxiliary, destination, source) 

# एक वर्ष में हर दिन होने वाली संख्या का पता लगाने के लिए एक पायथन फ़ंक्शन लिखें और उन्हें प्रिंट करें
import datetime  
import calendar 
   
def day_occur_time(year): 
    days = [ "Monday", "Tuesday", "Wednesday",   
           "Thursday",  "Friday", "Saturday",  
           "Sunday" ] 
    L = [52 for i in range(7)] 

    pos = -1
    day = datetime.datetime(year, month = 1, day = 1).strftime("%A") 
    for i in range(7): 
        if day == days[i]: 
            pos = i 
    if calendar.isleap(year): 
        L[pos] += 1
        L[(pos+1)%7] += 1       
    else: 
        L[pos] += 1

    for i in range(7): 
        print(days[i], L[i])

# रेंज में सभी पायथागॉरियन ट्रिपल को निर्धारित करने के लिए एक पायथन प्रोग्राम लिखें
limit= 50
c=0
m=2
while(c<limit):
    for n in range(1,m+1):
        a=m*m-n*n
        b=2*m*n
        c=m*m+n*n
        if(c>limit):
            break
        if(a==0 or b==0 or c==0):
            break
        print(a,b,c)
    m=m+1

# बाइनरी को ग्रे कोड में बदलने का कार्य
def binary_to_gray(n):
    n = int(n, 2) 
    n ^= (n >> 1)
    return bin(n)[2:]

# दो सूचियों के प्रतिच्छेदन को खोजने के लिए एक पायथन फ़ंक्शन लिखें
def intersection(a, b):
    return list(set(a) & set(b))

# डिक्शनरी से दी गई कुंजी को निकालने के लिए एक पायथन प्रोग्राम लिखें
d = {'a':1,'b':2,'c':3,'d':4}
key= 'd'
if key in d: 
    del d[key]
else:
    print("Key not found!")
    exit(0)

# टेक्स्ट फ़ाइल में शब्दों की संख्या गिनने के लिए एक पायथन फ़ंक्शन लिखें और इसे प्रिंट करें
def word_count(fname) : 
    num_words = 0
    with open(fname, 'r') as f:
        for line in f:
            words = line.split()
            num_words += len(words)
    print(num_words)

# किसी संख्या में काउंट सेट बिट्स के लिए एक पायथन फ़ंक्शन लिखें
def count_set_bits(n):
    count = 0
    while n:
        n &= n - 1
        count += 1
    return count

# रिकर्सन का उपयोग किए बिना सूची को समतल करने के लिए एक पायथन प्रोग्राम लिखें
a=[[1,[[2]],[[[3]]]],[[4],5]]
flatten=lambda l: sum(map(flatten,l),[]) if isinstance(l,list) else [l]
print(flatten(a))

# पिरामिड पैटर्न को प्रिंट करने के लिए एक पायथन फंक्शन लिखें
def pyramid_pattern(symbol='*', count=4):
    for i in range(1, count + 1):
        print(' ' * (count - i) + symbol * i, end='')
        print(symbol * (i - 1) + ' ' * (count - i))


# किसी दिए गए फ़ाइल में दिए गए शब्द की घटना को गिनने के लिए एक पायथन फ़ंक्शन लिखें
def check_word_count(word, file):
    if not os.path.isfile(file):
        raise FileNotFoundError
    if not isinstance(word, str):
        raise TypeError

    with open(file, 'r') as f:
        lines = f.readlines()
        words = [l.strip().split(' ') for l in lines]
        words = [word for sublist in words for word in sublist]
        c = Counter(words)
    return c.get(word, 0)


# दी गई लंबाई के साथ सूची से क्रमपरिवर्तन करने के लिए एक पायथन फ़ंक्शन लिखें
def get_permutations(data_list, l=2):
    return list(permutations(data_list, r=l))


# लेक्सिकोग्राफिक क्रमबद्ध क्रम में स्ट्रिंग के आकार के सभी संभावित क्रमपरिवर्तन प्राप्त करने के लिए एक पायथन प्रोग्राम लिखें
def get_ordered_permutations(word, k):
    [print(''.join(x)) for x in sorted(list(permutations(word, int(k))))]


# लेक्सिकोग्राफिक सॉर्ट किए गए क्रम में स्ट्रिंग के आकार तक, सभी संभावित संयोजन प्राप्त करने के लिए एक पायथन प्रोग्राम लिखें
def get_ordered_combinations(string, k):
    [print(''.join(x)) for i in range(1, int(k) + 1) for x in combinations(sorted(string), i)]


# लेक्सिकोग्राफिक क्रमबद्ध क्रम में स्ट्रिंग के सभी संभावित आकार प्रतिस्थापन संयोजन प्राप्त करने के लिए एक पायथन फ़ंक्शन लिखें
def get_ordered_combinations_with_replacement(string, k):
    [print(''.join(x)) for x in combinations_with_replacement(sorted(string), int(k))]



# दिए गए शिफ्ट मान के साथ सीज़र सिफर के लिए एक पायथन फ़ंक्शन लिखें और संशोधित टेक्स्ट वापस करें
def caesar_cipher(text, shift=1):
    alphabet = string.ascii_lowercase
    shifted_alphabet = alphabet[shift:] + alphabet[:shift]
    table = str.maketrans(alphabet, shifted_alphabet)
    return text.translate(table)


# सभी अक्षरों के मामले को स्वैप करने के लिए स्ट्रिंग के लिए एक पायथन फ़ंक्शन लिखें
def swap_case(s):
    return ''.join(x for x in (i.lower() if i.isupper() else i.upper() for i in s))


# उपयोगकर्ता से दो सेटों के बीच सममित अंतर प्राप्त करने के लिए एक पायथन फ़ंक्शन लिखें
def symmetric_diff_sets():
    M, m = input(), set(list(map(int, input().split())))
    N, n = input(), set(list(map(int, input().split())))
    s = sorted(list(m.difference(n)) + list(n.difference(m)))
    for i in s:
        print(i)


# दिया गया सेट सबसेट है या नहीं, यह जांचने के लिए एक पायथन फ़ंक्शन लिखें
def check_subset():
    for _ in range(int(input())):
        x, a, z, b = input(), set(input().split()), input(), set(input().split())
    print(a.issubset(b))


# बेसिक HTML पार्सर के लिए एक पायथन प्रोग्राम लिखें
from html.parser import HTMLParser


class MyHTMLParser(HTMLParser):
    def handle_starttag(self, tag, attrs):
        print(tag)
        for attr in attrs:
            print("->", attr[0], ">", attr[1])


parser = MyHTMLParser()

for i in range(int(input())):
    parser.feed(input())


# NLTK का उपयोग कर नामांकित इकाई पहचानकर्ता के लिए एक पायथन फ़ंक्शन लिखें
def ner_checker(texts):
    all_set = set()

    def nltk_ner_check(texts):
        for i, text in texts:
            for entity in nltk.ne_chunk(nltk.pos_tag(nltk.word_tokenize(text))):
                if isinstance(entity, nltk.tree.Tree):
                    etext = " ".join([word for word, tag in entity.leaves()])
                    # label = entity.label()
                    all_set.add(etext)

    nltk_ner_check(texts=texts)
    return all_set


# किसी दिए गए स्ट्रिंग को संपीड़ित करने के लिए एक फ़ंक्शन लिखें। मान लीजिए कि एक वर्ण 'c' स्ट्रिंग में लगातार X बार आता है। स्ट्रिंग में वर्ण 'c' की इन लगातार घटनाओं को (X, c) से बदलें
def compress(text):
    from itertools import groupby
    for k, g in groupby(text):
        print("({}, {})".format(len(list(g)), k), end=" ")


# किसी दिए गए स्ट्रिंग 'एन' बार की पुनरावृत्ति में 'ए' को गिनने के लिए एक पायथन फ़ंक्शन लिखें
def repeated_string(s, n):
    return s.count('a') * (n // len(s)) + s[:n % len(s)].count('a')


# दिए गए स्ट्रिंग के सभी सबस्ट्रिंग्स को खोजने के लिए एक पायथन फ़ंक्शन लिखें जिसमें 2 या अधिक स्वर हों। साथ ही, इन सबस्ट्रिंग्स को 2 व्यंजनों के बीच में होना चाहिए और इसमें केवल स्वर होने चाहिए
def find_substr():
    import re
    v = "aeiou"
    c = "qwrtypsdfghjklzxcvbnm"
    m = re.findall(r"(?<=[%s])([%s]{2,})[%s]" % (c, v, c), input(), flags=re.I)
    print('\n'.join(m or ['-1']))


# एक पायथन फ़ंक्शन लिखें जो पांच सकारात्मक पूर्णांक देता है और न्यूनतम और अधिकतम मान ज्ञात करता है जिसे पांच पूर्णांकों में से चार को जोड़कर गणना की जा सकती है
def min_max():
    nums = [int(x) for x in input().strip().split(' ')]
    print(sum(nums) - max(nums), sum(nums) - min(nums))


# (i, j) जोड़े की संख्या खोजने के लिए एक पायथन फ़ंक्शन लिखें जहां i<j और ar[i]+ar[j] डेटा सूची में k द्वारा विभाज्य है
def divisible_sum_pairs(arr, k):
    count = 0
    n = len(arr)
    for i in range(n - 1):
        j = i + 1
        while j < n:
            if ((arr[i] + arr[j]) % k) == 0:
                count += 1
            j += 1
    return count


import math


# एक वृत्त के क्षेत्रफल की गणना करने के लिए एक अजगर वर्ग लिखें और एक त्रिज्या के लिए घाटी को प्रिंट करें
class CircleArea:
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius * self.radius


r = 2
obj = CircleArea(r)
print("Area of circle:", obj.area())


# टेक्स्ट फ़ाइल में शब्दों की संख्या गिनने के लिए एक पायथन फ़ंक्शन लिखें
def check_words():
    fname = input("file name: ")
    num_words = 0
    with open(fname, 'r') as f:
        for line in f:
            words = line.split()
            num_words += len(words)
    print("Number of words = ", num_words)


# पाठ फ़ाइल में पंक्तियों की संख्या गिनने के लिए एक पायथन फ़ंक्शन लिखें
def check_lines():
    fname = input("file name: ")
    num_lines = 0
    with open(fname, 'r') as f:
        for line in f:
            num_lines += 1
    print("Number of lines = ", num_lines)


# एक टेक्स्ट फ़ाइल में रिक्त स्थान की संख्या की गणना करने वाला एक पायथन फ़ंक्शन लिखें
def count_blank_space():
    fname = input("file name:")
    count = 0
    with open(fname, 'r') as f:
        for line in f:
            count += line.count(' ')
    return count


# 2 स्ट्रिंग एनाग्राम हैं या नहीं, यह जांचने के लिए एक पायथन फ़ंक्शन लिखें
def anagram(s1, s2):
    if sorted(s1) == sorted(s2):
        return True
    else:
        return False


# किसी सूची से डुप्लिकेट आइटम निकालने और संशोधित डेटा सूची वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def remove_duplicates(data):
    c = Counter(data)
    s = set(data)
    for item in s:
        count = c.get(item)
        while count > 1:
            data.pop(item)
            count -= 1
    return data


# पाठ में सबसे आम शब्द प्राप्त करने के लिए एक पायथन फ़ंक्शन लिखें
def most_common(text):
    c = Counter(text)
    return c.most_common(1)


# दी गई पारियों द्वारा दिए गए बिन नंबर पर बिटवाइज़ गुणा करने के लिए एक पायथन फ़ंक्शन लिखें
def bit_mul(n, shift):
    return n << shift


# दिए गए बदलावों की संख्या के साथ बिटवाइज़ डिवीजन के लिए एक पायथन फ़ंक्शन लिखें
def bit_div(n, shift):
    return n >> shift


# कतार को लागू करने के लिए एक पायथन प्रोग्राम लिखें
from collections import deque

class Queue():
    '''
    Thread-safe, memory-efficient, maximally-sized queue supporting queueing and
    dequeueing in worst-case O(1) time.
    '''


    def __init__(self, max_size = 10):
        '''
        Initialize this queue to the empty queue.

        Parameters
        ----------
        max_size : int
            Maximum number of items contained in this queue. Defaults to 10.
        '''

        self._queue = deque(maxlen=max_size)


    def enqueue(self, item):
        '''
        Queues the passed item (i.e., pushes this item onto the tail of this
        queue).

        If this queue is already full, the item at the head of this queue
        is silently removed from this queue *before* the passed item is
        queued.
        '''

        self._queue.append(item)


    def dequeue(self):
        '''
        Dequeues (i.e., removes) the item at the head of this queue *and*
        returns this item.

        Raises
        ----------
        IndexError
            If this queue is empty.
        '''

        return self._queue.pop()


# संख्याओं की दो सूचियों के बीच डॉट उत्पाद प्राप्त करने के लिए एक पायथन फ़ंक्शन लिखें
def dot_product(a, b):
    return sum(e[0] * e[1] for e in zip(a, b))


# किसी दिए गए स्ट्रिंग से विराम चिह्न निकालने के लिए एक पायथन फ़ंक्शन लिखें
def strip_punctuations(s):
    return s.translate(str.maketrans('', '', string.punctuation))


# एक पायथन फ़ंक्शन लिखें जो एक स्ट्रिंग में सबसे बड़ा चरित्र लौटाता है
from functools import reduce


def biggest_char(string):
    if not isinstance(string, str):
        raise TypeError
    return reduce(lambda x, y: x if ord(x) > ord(y) else y, string)


# संख्या में अंकों की संख्या गिनने के लिए एक पायथन फ़ंक्शन लिखें
def count_digits():
    n = int(input("Enter number:"))
    count = 0
    while n > 0:
        count = count + 1
        n = n // 10
    return count


# एक स्ट्रिंग में स्वरों की संख्या गिनने के लिए एक पायथन फ़ंक्शन लिखें
def count_vowels(text):
    v = set('aeiou')
    for i in v:
        print(f'\n {i} occurs {text.count(i)} times')


# बाहरी आईपी पता जांचने के लिए एक पायथन फ़ंक्शन लिखें
def check_ip():
    import re
    import urllib.request as ur
    url = "http://checkip.dyndns.org"
    with ur.urlopen(url) as u:
        s = str(u.read())
        ip = re.findall(r"\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}", s)
        print("IP Address: ", ip[0])
        return ip[0]


# कुछ अजीब सम्मोहन पाठ के लिए एक अजगर कार्य लिखें
def weird():
    import random

    def getlength(script):
        return sum((i['length'] for i in script))

    def truncate(target_length, script):
        if getlength(script) > target_length:
            script = sorted(script, key=lambda k: (k['priority'], -k['length']))[:-1]
            return truncate(target_length, script)
        return sorted(script, key=lambda k: k['index'])

    def as_text(script):
        return "\n".join([i['text'] for i in script])

    priorities_and_sentences = [
        (1, "...now... sitting comfortably in the chair"),
        (2, "...with your feet still flat on the ground"),
        (3, "...back straight and head up right"),
        (2, "...make these adjustments now if you need to"),
        (3, "... pause.............................."),
        (1, "...your eyes ...still ...comfortably closed"),
        (2, "...nice and relaxed...comfortable and relaxed..."),
        (3, "... pause......................................."),
        (1, "...now...I want you to notice...how heavy your head is starting to feel..."),
        (1, "how heavy your head feels..."),
        (3, "... pause......................................."),
        (2, "really noticing the weight... of your head..."),
        (3,
         "and how much more ...comfortable...it will feel when you let your neck relaxes ...and your head begins to fall forward ...into a much more comfortable"),
    ]

    scriptlist = [{'priority': j[0], 'text': j[1], 'length': len(j[1]), 'index': i} for i, j in
                  enumerate(priorities_and_sentences)]

    print(as_text(truncate(500, scriptlist)))
    print(as_text(truncate(300, scriptlist)))
    print(as_text(truncate(200, scriptlist)))


# पासा रोल के लिए एक पायथन फ़ंक्शन लिखें जो उपयोगकर्ता को इनपुट जारी रखने के लिए कह रहा है और यादृच्छिक रूप से आउटपुट देता है
def dice():
    import random
    min = 1
    max = 6
    roll_again = 'y'

    while roll_again == "yes" or roll_again == "y":
        print("Rolling the dice...")
        print(random.randint(min, max))
        roll_again = input("Roll the dices again?")


from cryptography.fernet import Fernet


# क्रिप्टोग्राफी मॉड्यूल का उपयोग करके, कुंजी पीढ़ी के साथ 'सुरक्षित' वर्ग के भीतर सुविधाओं को एन्क्रिप्ट और डिक्रिप्ट करने के लिए एक पायथन प्रोग्राम लिखें
class Secure:
    def __init__(self):
        """
           Generates a key and save it into a file
        """
        key = Fernet.generate_key()
        with open("secret.key", "wb") as key_file:
            key_file.write(key)

    @staticmethod
    def load_key():
        """
        Load the previously generated key
        """
        return open("secret.key", "rb").read()

    def encrypt_message(self, message):
        """
        Encrypts a message
        """
        key = self.load_key()
        encoded_message = message.encode()
        f = Fernet(key)
        encrypted_message = f.encrypt(encoded_message)
        print("\nMessage has been encrypted: ", encrypted_message)
        return encrypted_message

    def decrypt_message(self, encrypted_message):
        """
        Decrypts an encrypted message
        """
        key = self.load_key()
        f = Fernet(key)
        decrypted_message = f.decrypt(encrypted_message)
        print("\nDecrypted message:", decrypted_message.decode())


s = Secure()
encrypted = s.encrypt_message("My deepest secret!")
s.decrypt_message(encrypted)


# दिए गए पाठ के लिए SHA256 उत्पन्न करने के लिए एक पायथन फ़ंक्शन लिखें
def get_sha256(text):
    import hashlib
    return hashlib.sha256(text).hexdigest()


# SHA256 हैशेड मान दिए गए डेटा के लिए मान्य है या नहीं, यह जांचने के लिए एक पायथन फ़ंक्शन लिखें
def check_sha256_hash(hashed, data):
    import hashlib
    return True if hashed == hashlib.sha256(data.encode()).hexdigest() else False


# किसी दिए गए यूआरएल के लिए एचटीएमएल कोड प्राप्त करने के लिए एक पायथन फ़ंक्शन लिखें
def get_html(url="http://www.python.org"):
    import urllib.request

    fp = urllib.request.urlopen(url)
    mybytes = fp.read()
    mystr = mybytes.decode("utf8")
    fp.close()
    print(mystr)


# प्रत्येक दिए गए 'अंतराल' सेकंड के बाद बिटकॉइन की कीमतें प्राप्त करने के लिए एक पायथन फ़ंक्शन लिखें
def get_btc_price(interval=5):
    import requests
    import json
    from time import sleep

    def getBitcoinPrice():
        URL = "https://www.bitstamp.net/api/ticker/"
        try:
            r = requests.get(URL)
            priceFloat = float(json.loads(r.text)["last"])
            return priceFloat
        except requests.ConnectionError:
            print("Error querying Bitstamp API")

    while True:
        print("Bitstamp last price: US $ " + str(getBitcoinPrice()) + "/BTC")
        sleep(interval)


# 2015 से 2020-12 तक किसी कंपनी के लिए स्टॉक मूल्य प्राप्त करने के लिए एक पायथन फ़ंक्शन लिखें
def get_stock_prices(tickerSymbol='TSLA'):
    import yfinance as yf

    # get data on this ticker
    tickerData = yf.Ticker(tickerSymbol)

    # get the historical prices for this ticker
    tickerDf = tickerData.history(period='1d', start='2015-1-1', end='2020-12-20')

    # see your data
    print(tickerDf)


# ऐप्पल आईट्यून्स पर 10 सर्वश्रेष्ठ कलाकारों को खेलने के लिए एक पायथन फ़ंक्शन लिखें
def get_artists():
    import requests
    url = 'https://itunes.apple.com/us/rss/topsongs/limit=10/json'
    response = requests.get(url)
    data = response.json()
    for artist_dict in data['feed']['entry']:
        artist_name = artist_dict['im:artist']['label']
        print(artist_name)


# TFIDF वेक्टराइज़र का उपयोग करके उपयोगकर्ता परीक्षण कॉर्पस से प्रमुख शब्द प्राप्त करने के लिए एक पायथन फ़ंक्शन लिखें
def get_words(corpus, new_doc, top=2):
    import numpy as np
    from sklearn.feature_extraction.text import TfidfVectorizer

    tfidf = TfidfVectorizer(stop_words='english')
    if not corpus:
        corpus = [
            'I would like to check this document',
            'How about one more document',
            'Aim is to capture the key words from the corpus',
            'frequency of words in a document is called term frequency'
        ]

    X = tfidf.fit_transform(corpus)
    feature_names = np.array(tfidf.get_feature_names())

    if not new_doc:
        new_doc = ['can key words in this new document be identified?',
                   'idf is the inverse document frequency calculated for each of the words']
    responses = tfidf.transform(new_doc)

    def get_top_tf_idf_words(response, top_n=top):
        sorted_nzs = np.argsort(response.data)[:-(top_n + 1):-1]
        return feature_names[response.indices[sorted_nzs]]

    print([get_top_tf_idf_words(response, 2) for response in responses])


# दिए गए पाठ या फ़ाइल पर वर्डक्लाउड उत्पन्न करने के लिए एक पायथन फ़ंक्शन लिखें
import os


def get_word(data):
    if not (isinstance(data, str) or os.path.isfile(data)):
        raise TypeError("Text must be string or a File object.")
    from wordcloud import WordCloud, STOPWORDS
    import matplotlib.pyplot as plt
    stopwords = set(STOPWORDS)
    if os.path.isfile(data):
        with open(data, 'r') as f:
            data = f.read()

    data = ' '.join(data.lower().split(' '))
    wordcloud = WordCloud(width=400, height=400,
                          background_color='white',
                          stopwords=stopwords,
                          min_font_size=15).generate(data)

    # plot the WordCloud image
    plt.figure(figsize=(8, 8), facecolor=None)
    plt.imshow(wordcloud)
    plt.axis("off")
    plt.tight_layout(pad=0)

    plt.show()


# कुंजी में से किसी एक पर डेटा संरचना में प्रत्येक आइटम को सॉर्ट करने के लिए एक पायथन फ़ंक्शन लिखें
def sort_list_with_key():
    animals = [
        {'type': 'lion', 'name': 'Mr. T', 'age': 7},
        {'type': 'tiger', 'name': 'scarface', 'age': 3},
        {'type': 'puma', 'name': 'Joe', 'age': 4}]
    print(sorted(animals, key=lambda animal: -animal['age']))


# एक अनंत अनुक्रम के लिए जनरेटर के साथ एक पायथन फ़ंक्शन लिखें
def infinite_sequence():
    n = 0
    while True:
        yield n
        n += 1


# क्रिप्टोग्राफिक रूप से मजबूत छद्म-यादृच्छिक डेटा उत्पन्न करने के लिए एक पायथन फ़ंक्शन लिखें
def get_cryptographically_secure_data(n=101):
    return secrets.token_bytes(n), secrets.token_hex(n)


# बाइट को यूटीएफ -8 में बदलने के लिए एक पायथन फ़ंक्शन लिखें
def byte_to_utf8(data):
    return data.decode("utf-8")
print(byte_to_utf8(data=b'r\xc3\xa9sum\xc3\xa9'))

# एक पायथन फ़ंक्शन लिखें जो उपयोगकर्ता इनपुट के रूप में लंबाई, चौड़ाई लेता है और आयत का क्षेत्र देता है
def rectangle_area(length, breadth):
    area = length * breadth    
    return area

# एक पायथन फ़ंक्शन लिखें जो उपयोगकर्ता इनपुट और प्रिंट वर्ग और संख्या के घन के रूप में एक संख्या लेता है
def square_cube(number):
    print(number ** 2)  
    print(number ** 3)  
    
# एक पायथन प्रोग्राम लिखें जो उपयोगकर्ता इनपुट के रूप में सेंटीमीटर में ऊंचाई लेता है और पैरों और इंच में ऊंचाई लौटाता है
cm=int(input("Enter the height in centimeters:"))
inches=0.394*cm
feet=0.0328*cm
print("The length in inches",round(inches,2))
print("The length in feet",round(feet,2))

# सूची से डुप्लीकेट हटाने और परिणाम प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
l = [1,2,3,4,5,5,5,5,5,5,5,7,8,8,0]
result = set(l)
print("Result : ",result)

# एक पायथन फ़ंक्शन लिखें जो त्रिभुज के क्षेत्र की गणना करने और वापस करने के लिए उपयोगकर्ता इनपुट के रूप में पक्षों की लंबाई लेता है

def triangle_area(a,b,c):
    s = (a+b+c)/2
    area = (s(s-a)*(s-b)*(s-c)) ** 0.5
    return(area)

# दो नंबर स्वैप करने के लिए एक पायथन प्रोग्राम लिखें
num1 = 130
num2 = 34
num1,num2 = num2,num1
 
# साधारण ब्याज को प्रिंट करने के लिए उपयोगकर्ता से मूल राशि, ब्याज की दर और समय प्राप्त करने के लिए एक पायथन प्रोग्राम लिखें
principal = float(input("Enter principal : "))
rate= float(input("Enter rate : "))
time = float(input("Enter time : "))
simple_interest = print(f"Simple Interest : {(principal*rate*time/100)}")

# किसी संख्या को उल्टा करने के लिए जबकि लूप का उपयोग करके एक अजगर प्रोग्राम लिखें और उलटी संख्या को प्रिंट करें
Number = int(input("Please Enter any Number: "))    
Reverse = 0    
while(Number > 0):    
    Reminder = Number %10    
    Reverse = (Reverse *10) + Reminder    
    Number = Number //10    
     
print("\n Reverse of entered number is = %d" %Reverse)  

# इनपुट के रूप में वर्ष लेने के लिए एक पायथन प्रोग्राम लिखें और जांचें कि यह एक लीप वर्ष है या नहीं

year = int(input("Enter a year: "))  
if (year % 4) == 0:  
   if (year % 100) == 0:  
       if (year % 400) == 0:  
           print(f"{year} is a leap year")  
       else:  
           print(f"{year} is not a leap year")  
   else:  
       print(f"{year} is a leap year")  
else:  
   print(f"{year} is not a leap year")
   
# परीक्षण करने के लिए एक संख्या इनपुट करने के लिए एक पायथन प्रोग्राम लिखें और यदि यह एक अभाज्य संख्या है तो प्रिंट करें

num = int(input("Enter number :"))
lim = int(num/2) + 1
for i in range(2,lim):
    rem = num % i
    if rem == 0 :
        print(num,"is not a prime number")
        break
else:
    print(num,"is a prime number")
    
# उपयोगकर्ता से स्ट्रिंग इनपुट करने के लिए एक पायथन प्रोग्राम लिखें और इनपुट स्ट्रिंग को सभी अपर केस में कनवर्ट करें और परिणाम प्रिंट करें
string = input("Please Enter your Own String : ")

string1 = string.upper()
 
print("\nOriginal String in Lowercase  =  ", string)
print("The Given String in Uppercase =  ", string1)

# उपयोगकर्ता से एक स्ट्रिंग इनपुट करने के लिए एक पायथन प्रोग्राम लिखें और एक स्ट्रिंग में स्वरों की गिनती करें और आउटपुट प्रिंट करें

str1 = input("Please Enter Your Own String : ")
vowels = 0
 
for i in str1:
    if(i == 'a' or i == 'e' or i == 'i' or i == 'o' or i == 'u' or i == 'A'
       or i == 'E' or i == 'I' or i == 'O' or i == 'U'):
        vowels = vowels + 1
 
print("Total Number of Vowels in this String = ", vowels)

# उपयोगकर्ता से संख्या एन इनपुट करने के लिए एक पायथन प्रोग्राम लिखें और विषम संख्या को 1 से N तक प्रिंट करें

maximum = int(input(" Please Enter any Maximum Value : "))

for number in range(1, maximum + 1):
    if(number % 2 != 0):
        print("{0}".format(number))
        
# उपयोगकर्ता से संख्या एन इनपुट करने के लिए एक पायथन प्रोग्राम लिखें और 1 से N तक भी संख्याएं प्रिंट करें

maximum = int(input(" Please Enter the Maximum Value : "))

for number in range(1, maximum+1):
    if(number % 2 == 0):
        print("{0}".format(number))
        
# उपयोगकर्ता से दो नंबर इनपुट करने के लिए एक पायथन प्रोग्राम लिखें और दो नंबर जोड़ें और परिणाम प्रिंट करें

number1 = input(" Please Enter the First Number: ")
number2 = input(" Please Enter the second number: ")

sum = float(number1) + float(number2)
print('The sum of {0} and {1} is {2}'.format(number1, number2, sum))

# एक अजगर प्रोग्राम लिखें जो इनपुट के रूप में दो पूर्णांक लेता है और जांचें कि क्या पहला नंबर दूसरे से विभाज्य है

num1 = int(input("Enter first number :"))
num2 = int(input("Enter second number :"))
remainder  = num1 % num2
if remainder == 0:
    print(num1 ," is divisible by ",num2)
else :
    print(num1 ," is not divisible by ",num2)
    
# इनपुट पूर्णांक की तालिका को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

num = int(input("Please enter a number "))
for a in range(1,11):
    print(num , 'x' , a , '=' ,num*a)
    
# संख्या के भाज्य को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
num = int(input("Please enter a number "))
fact = 1
a = 1
while a <= num :
    fact *= a
    a += 1
print("The factorial of ",num, " is ",fact)

# एक पायथन प्रोग्राम लिखें जो इनपुट के रूप में 3 नंबर लेता है और एलिफ स्टेटमेंट का उपयोग करके तीन नंबरों में से सबसे बड़ा प्रिंट करता है

a = float(input("Please Enter the First value: "))
b = float(input("Please Enter the First value: "))
c = float(input("Please Enter the First value: "))

if (a > b and a > c):
          print("{0} is Greater Than both {1} and {2}". format(a, b, c))
elif (b > a and b > c):
          print("{0} is Greater Than both {1} and {2}". format(b, a, c))
elif (c > a and c > b):
          print("{0} is Greater Than both {1} and {2}". format(c, a, b))
else:
          print("Either any two values or all the three values are equal")
          
# एक पायथन प्रोग्राम लिखें जो इनपुट संख्या एन लेता है और फिबोनैकी श्रृंखला के पहले एन तत्वों को प्रिंट करता है

N = int(input("Please enter a number "))
first = 0
second = 1
print(first)
print(second)
for a in range(1,N-1):
    third = first + second
    print(third)
    first,second = second , third
    
# एक पूर्णांक के विभाजक को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
num = int(input("Please enter a integer "))
mid = int(num / 2)
print("The divisiors of ",num," are :" )
for a in range(2,mid + 1):
    if num % a == 0:
        print(a, end = ' ')
else :
    print()
    print("-End-")
    
# उपयोगकर्ता द्वारा इनपुट के रूप में प्रदान की गई संख्याओं की सूची का औसत खोजने के लिए एक पायथन प्रोग्राम लिखें
n=int(input("Enter the number of elements to be inserted: "))
a=[]
for i in range(0,n):
    elem=int(input("Enter element: "))
    a.append(elem)
avg=sum(a)/n
print("Average of elements in the list",round(avg,2))

# एक अजगर प्रोग्राम लिखें जो एक पूर्णांक N को इनपुट के रूप में लेता है और विषम संख्याओं को N तक जोड़ता है और परिणाम को प्रिंट करता है

N = int(input("Enter Number : "))
sum = 0
i = 1
while i <= N:
    sum = sum + i
    i = i + 2
print(sum)

# एक पायथन फ़ंक्शन लिखें जो एक स्ट्रिंग इनपुट लेता है और रिटर्न करता है कि पैलिंड्रोम है या नहीं

def isPalindrome(s):
    return s == s[::-1]
 
# एक पायथन प्रोग्राम लिखें जो सूची को एक इनपुट के रूप में लेता है और संख्याओं की दी गई सूची के माध्य की गणना करता है
lst = eval(input("Enter list : "))
mean = 0
sum = 0
for i in lst:
    sum  = sum + i
mean = sum / len(lst)
print(" The mean of given list is :", mean)

# एक पायथन प्रोग्राम लिखें जो इनपुट के रूप में सूची लेता है और संख्याओं की दी गई सूची के योग की गणना करता है
lst = eval(input("Enter list : "))
mean = 0
sum = 0
for i in lst:
    sum  = sum + i
print(" The mean of given list is :", sum)

# एक पायथन प्रोग्राम लिखें जो इनपुट के रूप में सूची लेता है और सूची में सभी तत्वों की आवृत्ति पाता है
lst = eval(input("Enter list : "))
mean = 0
sum = 0
for i in lst:
    sum  = sum + i
print(" The mean of given list is :", sum)

# एक पायथन फ़ंक्शन लिखें जो दो सूचियों को इनपुट के रूप में दो सूचियों में सामान्य तत्वों को प्रिंट आउट करता है

def common_member(a, b): 
    a_set = set(a) 
    b_set = set(b) 
  
    if (a_set & b_set): 
        print(a_set & b_set) 
    else: 
        print("No common elements")  
        
# एक अजगर फ़ंक्शन लिखें जो दो सूचियाँ लेता है और पहली सूची के बाद दूसरी सूची जोड़ता है
lst1 = eval(input("Enter list : "))
lst2 = eval(input("Enter list : "))
print(lst1 + lst2)


# 0 से 100 तक की संख्याओं के वर्गमूल की गणना और प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
i = 0
while i<= 100:
 print(i, "\t\t" , i**0.5)
 i = i + 1

# एक अजगर प्रोग्राम लिखें उपयोगकर्ता को "हैलो" के साथ बधाई देता है, उपयोगकर्ता द्वारा अपना नाम दर्ज करने के बाद:
name = input ("Input your name: ")
print("HELLO ", name)

# एक पायथन प्रोग्राम लिखें जो एक स्ट्रिंग इनपुट लेता है और रिवर्स स्ट्रिंग प्रिंट करता है
name = input("Enter String")
print(name[::-1]) 

# एक पायथन प्रोग्राम लिखें जो इनपुट को एक सूची लेता है और रिवर्स आउटपुट प्रिंट करता है
lst = eval(input("Enter list"))
print(lst[::-1]) 

# एक पायथन फ़ंक्शन लिखें जो वाक्य को इनपुट के रूप में लेता है और एक वाक्य से स्वरों को हटा देता है

sentence = input("Enter a sentence : ")

def fn(sentence):
    vowels = 'aeiou'
    return ''.join([ l for l in sentence if l not in vowels])

# एक पायथन फ़ंक्शन लिखें जो इनपुट के रूप में समान लंबाई की दो सूची लेता है और एक शब्दकोश को कुंजी के रूप में और अन्य को मान के रूप में वापस करता है।

keys = eval(input("Enter key list : "))
values = eval(input("Enter value list : "))
def fn(keys, values):
    return { keys[i] : values[i] for i in range(len(keys)) }

# एक पायथन फ़ंक्शन लिखें जो एक पूर्णांक को इनपुट के रूप में लेता है और उस संख्या का भाज्य लौटाता है

def factorial(n): 
      
    # single line to find factorial 
    return 1 if (n==1 or n==0) else n * factorial(n - 1); 

# एक अजगर फ़ंक्शन लिखें जो इनपुट त्रिज्या और सर्कल का रिटर्न क्षेत्र लेता है
def findArea(r): 
    PI = 3.142
    return PI * (r*r);

# एक पायथन फ़ंक्शन लिखें जो इनपुट सिद्धांत, दर, समय लेता है और चक्रवृद्धि ब्याज की गणना करता है

def compound_interest(principle, rate, time):
    # Calculates compound interest  
    Amount = principle * (pow((1 + rate / 100), time)) 
    CI = Amount - principle 
    print("Compound interest is", CI) 
    
# इनपुट वर्ण के एएससीआई मूल्य को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

character = input(" Enter Character :")
print(f"Ascii value of character {character} is : " , ord(character))

# एक पायथन प्रोग्राम लिखें जो एक पूर्णांक इनपुट लेता है और सूची समझ का उपयोग करके पहले एन प्राकृतिक संख्याओं के क्यूब्स के साथ श्रृंखला का योग ढूंढता है जो टा
N = int(input("Enter Integer "))
lst = [i**3 for i in range(1, N + 1)]
print(sum(lst)) 

# एक पायथन फ़ंक्शन लिखें जो इनपुट के रूप में सूची लेता है और इसे टपल में परिवर्तित करता है
def convert(list): 
    return tuple(list)

# एक सूची प्राप्त करने के लिए एक पायथन प्रोग्राम लिखें, गैर-रिक्त टुपल्स की दी गई सूची से प्रत्येक टपल में अंतिम तत्व द्वारा बढ़ते क्रम में क्रमबद्ध करें

def last(n): return n[-1]

def sort_list_last(tuples):
  return sorted(tuples, key=last)

print(sort_list_last([(2, 5), (1, 2), (4, 4), (2, 3), (2, 1)]))

# दो शब्दकोशों को जोड़ने के लिए एक पायथन प्रोग्राम लिखें

d1 = {'a' : 1 ,'b' : 2}
d2 = {'c' : 1 ,'d' : 2}
d3 = {**d1,**d2}
print(d3)

# एक सेट की लंबाई प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें

# एक सेट बनाएँ
seta = set([5, 10, 3, 15, 2, 20])
#Find the length use len()
print(len(seta))

# एक अजगर प्रोग्राम लिखें जो इनपुट के रूप में दो सेट लेता है और सामान्य तत्वों को प्रिंट करता है
s1 = eval(input("Enter set 1 "))
s2 = eval(input("Enter set 2 "))
print(s1.intersection(s2))

# एक पायथन प्रोग्राम लिखें जो एक सूची इनपुट लेता है और सूची के भीतर तत्वों का मतलब प्रिंट करता है
s1 = eval(input("Enter list "))
mean = sum(s1) / len(s1) 
print("Mean of sample is : " + str(mean)) 


# एक पायथन प्रोग्राम लिखें जो एक सूची इनपुट लेता है और सूची के भीतर तत्वों के मानक विचलन को प्रिंट करता है
mean = sum(s1) / len(s1) 
variance = sum([((x - mean) ** 2) for x in s1]) / len(s1) 
res = variance ** 0.5
print("Standard deviation of sample is : " + str(res)) 

# एक अजगर प्रोग्राम लिखें जो एक यादृच्छिक संख्या प्रिंट करता है
import random
n = random.random()
print(n) 

# एक पायथन फ़ंक्शन लिखें जो इनपुट को एक स्ट्रिंग लेता है और उसी से डुप्लिकेट को हटा देता है
foo = input("Enter String : ")
print("Duplicates Removed","".join(set(foo)))

# दिए गए स्ट्रिंग के अंत में 'आईएनजी' जोड़ने के लिए एक पायथन प्रोग्राम लिखें (लंबाई कम से कम 3 होनी चाहिए)। यदि दी गई स्ट्रिंग पहले से ही 'ing' से समाप्त होती है तो इसके बजाय 'ly' जोड़ें। यदि दिए गए तार की लंबाई 3 से कम है, तो इसे अपरिवर्तित छोड़ दें
def add_string(str1):
  length = len(str1)

  if length > 2:
    if str1[-3:] == 'ing':
      str1 += 'ly'
    else:
      str1 += 'ing'

  return str1

# दिए गए स्ट्रिंग से सबस्ट्रिंग 'नहीं' और 'खराब' की पहली उपस्थिति खोजने के लिए एक पायथन प्रोग्राम लिखें, यदि 'नहीं' 'खराब' का अनुसरण करता है, तो पूरे 'नहीं' ... 'खराब' सबस्ट्रिंग को 'अच्छा' से बदलें '। परिणामी स्ट्रिंग वापस करें
def not_poor(str1):
  snot = str1.find('not')
  spoor = str1.find('poor')
  

  if spoor > snot and snot>0 and spoor>0:
    str1 = str1.replace(str1[snot:(spoor+4)], 'good')
    return str1
  else:
    return str1

# दिए गए वाक्य में प्रत्येक शब्द की उपस्थिति की गणना करने के लिए एक पायथन प्रोग्राम लिखें।
def word_count(str):
    counts = dict()
    words = str.split()

    for word in words:
        if word in counts:
            counts[word] += 1
        else:
            counts[word] = 1

    return counts


# शब्दों के चारों ओर टैग के साथ HTML स्ट्रिंग बनाने के लिए एक पायथन फ़ंक्शन लिखें
def add_tags(tag, word):
	return "<%s>%s</%s>" % (tag, word, tag)

# संख्याओं की एक श्रृंखला से सम और विषम संख्याओं की संख्या गिनने के लिए एक पायथन प्रोग्राम लिखें

numbers = (1, 2, 3, 4, 5, 6, 7, 8, 9) # Declaring the tuple
count_odd = 0
count_even = 0
for x in numbers:
        if not x % 2:
    	     count_even+=1
        else:
    	     count_odd+=1
             
# एक पायथन प्रोग्राम लिखें जो प्रत्येक आइटम और उसके संबंधित प्रकार को निम्न सूची से प्रिंट करता है

datalist = [1452, 11.23, 1+2j, True, 'w3resource', (0, -1), [5, 12],
{"class":'V', "section":'A'}]
for item in datalist:
   print ("Type of ",item, " is ", type(item))


# एक डिक्शनरी को वैल्यू के अनुसार सॉर्ट (आरोही) करने के लिए एक पायथन प्रोग्राम लिखें
d = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}

print({k :v for k,v in sorted(d.items(),key = lambda x : x[1])})

# डिक्शनरी को वैल्यू के हिसाब से सॉर्ट (अवरोही) करने के लिए पाइथन प्रोग्राम लिखें
d = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}

print({k :v for k,v in sorted(d.items(),key = lambda x : x[1],reverse = True)})

# सूची को क्रमबद्ध करने के लिए एक पायथन प्रोग्राम लिखें
numbers = [1, 3, 4, 2] 
numbers.sort()  
print(numbers) 

# दूसरे आइटम द्वारा टुपल्स की सूची को सॉर्ट करने के लिए एक पायथन प्रोग्राम लिखें
def Sort_Tuple(tup):  

    return(sorted(tup, key = lambda x: x[1]))   
  
tup = [('rishav', 10), ('akash', 5), ('ram', 20), ('gaurav', 15)]  

print(Sort_Tuple(tup)) 

# एक पायथन प्रोग्राम लिखें जो उपयोगकर्ता से दो इनपुट लेता है और जांचें कि वे बराबर हैं या नहीं
print("Enter first number")
first = input()
print("Enter second number")
second = input()
print(first == second)

# एक पायथन प्रोग्राम लिखें जो एक सूची इनपुट लेता है और सूची समझ का उपयोग करके प्रत्येक शब्द को वर्ग करता है
s1 = eval(input("Enter list "))
print([i**2 for i in s1])

# एक पायथन प्रोग्राम लिखें जो इनपुट सूची लेता है और सूची समझ का उपयोग करके प्रत्येक शब्द को घन करता है

s1 = eval(input("Enter list "))
print([i**3 for i in s1])

# एक पायथन प्रोग्राम लिखें जो सूची समझ का उपयोग करके हर शब्द में एक सूची और वर्गमूल इनपुट करता है

s1 = eval(input("Enter list "))
print([i**0.5 for i in s1])

# एक पायथन फ़ंक्शन लिखें जो इनपुट को स्ट्रिंग की सूची लेता है और सबसे बड़ी स्ट्रिंग प्रिंट करता है
def find_longest_word(words_list):
    word_len = []
    for n in words_list:
        word_len.append((len(n), n))
    word_len.sort()
    return word_len[-1][0], word_len[-1][1]

# एक पायथन प्रोग्राम लिखें जो एक स्ट्रिंग इनपुट लेता है और शब्दों की गिनती प्रिंट करता है

s1 = input("Enter string ")
print("Count of words",len(s1.split()))

# एक पायथन फ़ंक्शन लिखें जो इनपुट के रूप में टुपल्स की सूची लेता है और उन्हें वर्णानुक्रम में क्रमबद्ध करता है
def SortTuple(tup): 
      
    n = len(tup) 
      
    for i in range(n): 
        for j in range(n-i-1): 
              
            if tup[j][0] > tup[j + 1][0]: 
                tup[j], tup[j + 1] = tup[j + 1], tup[j] 
                  
    return tup 

# एक अजगर प्रोग्राम लिखें जो एक सूची लेता है और सूची के पहले और अंतिम मूल्य को स्वैप करता है
a=[]
n= int(input("Enter the number of elements in list:"))
for x in range(0,n):
    element=int(input("Enter element" + str(x+1) + ":"))
    a.append(element)
temp=a[0]
a[0]=a[n-1]
a[n-1]=temp
print("New list is:")
print(a)

# एक अजगर प्रोग्राम लिखें जो आज की तारीख को प्रिंट करे
from datetime import date
print(date.today()) 

# एक पायथन प्रोग्राम लिखें जो लाइनों की इनपुट संख्या लेता है और चौराहे की संभावित संख्या पाता है
def countMaxIntersect(n): 
    return int(n*(n - 1)/2) 

# एक नंबर एन इनपुट करने के लिए एक पायथन प्रोग्राम लिखें और वांछित आकार के एक उल्टे स्टार पैटर्न को प्रिंट करें
n=int(input("Enter number of rows: "))
for i in range (n,0,-1):
    print((n-i) * ' ' + i * '*')
    
# एक नंबर इनपुट करने के लिए एक पायथन प्रोग्राम लिखें और जांचें कि क्या दी गई संख्या पैलिंड्रोम है

n=int(input("Enter number:"))
temp=n
rev=0
while(n>0):
    dig=n%10
    rev=rev*10+dig
    n=n//10
if(temp==rev):
    print("The number is a palindrome!")
else:
    print("The number isn't a palindrome!")
    
# एक संख्या इनपुट करने के लिए एक पायथन प्रोग्राम लिखें और एक पूर्णांक का सबसे छोटा विभाजक खोजें
 
n=int(input("Enter an integer:"))
a=[]
for i in range(2,n+1):
    if(n%i==0):
        a.append(i)
a.sort()
print("Smallest divisor is:",a[0])

# तीन अलग-अलग अंकों को स्वीकार करने के लिए एक पायथन प्रोग्राम लिखें और अंकों से सभी संभावित संयोजनों को प्रिंट करें

a=int(input("Enter first number:"))
b=int(input("Enter second number:"))
c=int(input("Enter third number:"))
d=[]
d.append(a)
d.append(b)
d.append(c)
for i in range(0,3):
    for j in range(0,3):
        for k in range(0,3):
            if(i!=j&j!=k&k!=i):
                print(d[i],d[j],d[k])

# क्रमबद्ध पायथन सूची में तत्व डालने के लिए एक पायथन फ़ंक्शन लिखें

def insert(list, n): 
      
    for i in range(len(list)): 
        if list[i] > n: 
            index = i 
            break
      
 
    list = list[:i] + [n] + list[i:] 
    return list

# दो नंबर जोड़ने के लिए एक पायथन प्रोग्राम लिखें
num1 = 1.5
num2 = 6.3
sum = num1 + num2
print(f'Sum: {sum}')

# उपयोगकर्ता द्वारा प्रदान की गई दो संख्याओं को जोड़ने और योग वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def add_two_numbers(num1, num2):
    sum = num1 + num2
    return sum

# तीन संख्याओं में से सबसे बड़ी संख्या को खोजने और प्रिंट करने के लिए एक प्रोग्राम लिखें
snum1 = 10
num2 = 12
num3 = 14 
if (num1 >= num2) and (num1 >= num3): 
   largest = num1
elif (num2 >= num1) and (num2 >= num3):   
    largest = num2
else:   largest = num3
print(f'largest:{largest}')

# उपयोगकर्ता द्वारा प्रदान की गई दो संख्याओं को घटाने और परिणाम वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def sub_two_numbers(num1, num2):
    sub = num1 - num2
    return sub

# उपयोगकर्ता द्वारा प्रदान की गई दो संख्याओं को गुणा करने और परिणाम वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def mul_two_numbers(num1, num2):
    mul = num1 * num2
    return mul

# एलिमेंट फॉर्म डिक्शनरी पॉप करने के लिए एक पायथन प्रोग्राम लिखें
squares = {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
print(squares.pop(4))

# एक अजगर प्रोग्राम लिखें जो टपल की लंबाई को प्रिंट करता है
thistuple = ("apple", "banana", "cherry")
print(len(thistuple))

# संख्या प्राप्त करने के लिए एक प्रोग्राम लिखें = 1,3,11,42,12,4001
from collections import Iterable
highestnumber = -999
for i in numbers:
  if i > highestnumber:
    highestnumber = i
print(numbers.index(highestnumber))

# संख्या प्राप्त करने के लिए एक प्रोग्राम लिखें = 1,3,11,42,12,4001
highestnumber = -999
for i in numbers:
  if i > highestnumber:
    highestnumber = i
print(numbers.index(highestnumber))

# सूची पायथन में सभी तत्वों में 1 जोड़ें
lst = [1,2,3]
list(map(lambda x:x+1, lst))

# सूची पायथन के प्रत्येक तत्व में एक स्ट्रिंग जोड़ें
my_list = ['foo', 'fob', 'faz', 'funk']
string = 'bar'
list2 = list(map(lambda orig_string: orig_string + string, my_list))

# तीसरा आयाम मैट्रिक्स डेटासेट अजगर जोड़ें
x = [2D_matrix] # To convert from a 2-D to 3-D
# or 
x = [[[value1]]] # To convert from a 1-D to 3-D

# python add all values of another list
a = [1, 2, 3]
b = [4, 5, 6]
a += b

# सूची पायथन की शुरुआत में एक मान जोड़ें
var=7
array = [1,2,3,4,5,6]
array.insert(0,var)

# पायथन में एक अपरकेस वाक्य को लोअरकेस में प्रिंट करें
s = "Kilometer"
print(s.lower())

# एक शब्दकोश क्रमबद्ध करें
mydictionary : {1: 1, 7: 2, 4: 2, 3: 1, 8: 1}
sortedDictionary = sorted(mydictionary.keys())

# पायथन में दशमलव को केवल दो दशमलव तक सीमित करें
answer = str(round(answer, 2))

# डिक्शनरी पायथन में कितनी कुंजियाँ प्रिंट करें
a = {'foo':42, 'bar':69}
print(len(a))

# एक स्ट्रिंग पायथन में एक वर्ण का एक्सेस इंडेक्स
foo = 'Hello'
foo.find('lo')

# अजगर सूची के अंतिम तत्व को प्रिंट करता है
mylist = [0, 1, 2]
print(myList[-1]) 

# पायथन में एक खाली रेखा कैसे जोड़ें
print("")

# कैसे सरणी अजगर में पहली स्थिति में तत्व जोड़ने के लिए
x = [1,3,4]
a = 2
x.insert(1,a)

# पायथन में दशमलव के बाद अतिरिक्त शून्य कैसे जोड़ें I
format(2.0, '.6f')
'2.000000'

# पायथन में सूची संख्या कैसे जोड़ें
numbers = [1,2,3,4,5,1,4,5] 
Sum = sum(numbers) 

# समान लंबाई वाले अजगर की सूचियों में विभाजित सूची
[lst[i:i + n] for i in range(0, len(lst), n)]

# नेस्टेड लूप्स पायथन से कैसे बाहर निकलें
x_loop_must_break = False

for x in [1, 2, 3]:
    print(f"x is {x}")
    for y in [1, 2, 3]:
        print(f"y is {y}")
        if y == 2:
            x_loop_must_break = True
            break
    if x_loop_must_break: break

# सूची में पायथन में पहला अक्षर कैपिटलाइज़ करें
my_list = ['apple pie', 'orange jam']
my_list[0].capitalize()

# कैसे जांचें कि कोई सूची किसी अन्य सूची का सबसेट है या नहीं
if(all(x in test_list for x in sub_list)): 
    flag = True

# 09 अगस्त 2020 को ब्रेकेबल बफ़ेलो द्वारा स्ट्रिंग कैमलकेस पाइथॉनपीथॉन है या नहीं, यह जाँचने के लिए एक फंक्शन लिखें।
def is_camel_case(s):
    return s != s.lower() and s != s.upper() and "_" not in s

# कैसे जांचें कि स्ट्रिंग बाइट फॉर्मेट पाइथिन में है या नहीं
isinstance(string, bytes)

# पायथन में एनटीएच प्राइम कैसे जांचें
x=int(input())
n,c=1,0
while(c<x):
    n+=1
    for i in range(2,n+1):
        if(n%i==0):
            break
    if(i==n):
        c=c+1

# पायथन में फ़ारेनहाइट को सेल्सियस में कैसे बदलें
Celsius = (Fahrenheit - 32) * 5.0/9.0

# एक दशमलव संख्या का बाइनरी प्रिंट करें
a=6
print(bin(a))

# 06 नवंबर 2020 को TheRubberDucky द्वारा pythonpython में बेस 2 से बेस 10 में बदलने के लिए एक पायथन फंक्शन लिखें
def getBaseTen(binaryVal):
    count = 0

    binaryVal = binaryVal[::-1]

	for i in range(0, len(binaryVal)):
    	if(binaryVal[i] == "1"):
            count += 2**i
    
    return count

# बैश कमांड निष्पादित करने के लिए एक पायथन फ़ंक्शन लिखें
import subprocess
subprocess.call(["sudo", "apt", "update"])

# 0 और 22 के बीच एक यादृच्छिक संख्या उत्पन्न करने और प्रिंट करने के लिए एक फ़ंक्शन लिखें
import random
n = random.randint(0,22)
print(n)

# अजगर में एक सरणी से एक यादृच्छिक तत्व प्राप्त करने के लिए
import random
list_ = [1,2,3,4]
random.choice(list_)

# पायथन में वर्तमान दिन प्रिंट करें
from datetime import date
today = date.today()
print("Today's date:", today)

# उपलब्ध सीपीयू कोर की संख्या गिनने के लिए कार्यक्रम
import os
os.cpu_count()

# सरणी पायथन में सभी शून्य मानों से छुटकारा पाएं
mylist = [1, 2, 3, '', 4]
mylist = [i for i in mylist if i]

# पायथन में सबसे आम संख्या प्राप्त करें
from statistics import mode
mode((1, 2, 4, 4, 5, 4, 4, 2, 3, 8, 4, 4, 4))

# पायथन का वर्तमान संस्करण प्रिंट करें
import sys
print(sys.version)

# नेस्टेड सूचियों को समतल करने के लिए एक पायथन फ़ंक्शन लिखें
from collections import Iterable
def flatten(lis):
    for item in lis:
        if isinstance(item, Iterable) and not isinstance(item, str):
            for x in flatten(item):
                yield x
        else:
            yield item

# एक स्ट्रिंग को एक्सएमएल में बदलने के लिए एक पायथन फ़ंक्शन लिखें
import xml.etree.ElementTree as ET

root = ET.fromstring(country_data_as_string)

# कैसे एक्सएमएल फ़ाइल तत्व पेड़ खोलने के लिए
import xml.etree.ElementTree as ET

tree = ET.parse('filename.xml') 
tree_root = tree.getroot() 

# स्ट्रिंग से अजगर पार्स डेटाटाइम
from datetime import datetime

datetime_object = datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')

# कैसे अजगर में एक पाठ फ़ाइल से एक विशिष्ट पंक्ति को पढ़ने के लिए
line = open("file.txt", "r").readlines()[7]

# पायथन में स्ट्रिंग से पूर्णांक कैसे निकालें
s = '12abcd405'
result = ''.join([i for i in s if not i.isdigit()])

# पायथन में nth फाइबोनैचि वापस करने के लिए एक फ़ंक्शन लिखें
def Fibonacci(n): 
    if n<0: 
        print("Incorrect input")
    elif n==1: 
        return 0
    elif n==2: 
        return 1
    else: 
        return Fibonacci(n-1)+Fibonacci(n-2) 

# कैसे लैम्ब्डा का उपयोग कर अजगर में एक सूची सॉर्ट करने के लिए
data = [("Apples", 5, "20"), ("Pears", 1, "5"), ("Oranges", 6, "10")]

data.sort(key=lambda x:x[0])

# पायथन में दो मैट्रिक्स घटाने के लिए एक फ़ंक्शन लिखें
matrix1 = [[0, 1, 2], 
           [3, 5, 5], 
           [6, 7, 8]]

matrix2 = [[1, 2, 3], 
           [4, 5, 6], 
           [7, 8, 9]]

def subtractTheMatrix(matrix1, matrix2):
    matrix1Rows = len(matrix1)
    matrix2Rows = len(matrix2)
    matrix1Col = len(matrix1[0])
    matrix2Col = len(matrix2[0])

    #base case
    if(matrix1Rows != matrix2Rows or matrix1Col != matrix2Col):
        return "ERROR: dimensions of the two arrays must be the same"

    matrix = []
    rows = []

    for i in range(0, matrix1Rows):
        for j in range(0, matrix2Col):
            rows.append(0)
        matrix.append(rows.copy())
        rows = []

    for i in range(0, matrix1Rows):
        for j in range(0, matrix2Col):
            matrix[i][j] = matrix1[i][j] - matrix2[i][j]
            
    return matrix

# समय-समय पर एक पायथन लिपि लिखें
from datetime import datetime
start = datetime.now()
do_something():...
print(datetime.now() - start)

# दो क्रमबद्ध सरणियों के प्रतिच्छेदन को खोजने के लिए एक पायथन फ़ंक्शन लिखें
def printIntersection(arr1, arr2, m, n): 
    i, j = 0, 0
    while i < m and j < n: 
        if arr1[i] < arr2[j]: 
            i += 1
        elif arr2[j] < arr1[i]: 
            j+= 1
        else: 
            print(arr2[j]) 
            j += 1
            i += 1

arr1 = [1, 2, 4, 5, 6] 
arr2 = [2, 3, 5, 7] 
m = len(arr1) 
n = len(arr2) 
printIntersection(arr1, arr2, m, n) 

# सरणी में नेताओं को प्रिंट करने के लिए पायथन फ़ंक्शन लिखें
def printLeaders(arr,size):
         
    for i in range(0, size):
        for j in range(i+1, size):
            if arr[i]<arr[j]:
                break
        if j == size-1:  
            print(arr[i])

arr=[16, 17, 4, 3, 5, 2] 
printLeaders(arr, len(arr))

# एन नंबर पायथन के एलसीएम को प्रिंट करने के लिए एक पायथन फ़ंक्शन लिखें
import math

def LCMofArray(a):
  lcm = a[0]
  for i in range(1,len(a)):
    lcm = lcm*a[i]//math.gcd(lcm, a[i])
  return lcm

arr1 = [1,2,3]
print("LCM of arr1 elements:", LCMofArray(arr1))

# दो मैट्रिसेस को गुणा करने और परिणाम को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
X = [[12,7,3],
    [4 ,5,6],
    [7 ,8,9]]
Y = [[5,8,1,2],
    [6,7,3,0],
    [4,5,9,1]]
result = [[0,0,0,0],
         [0,0,0,0],
         [0,0,0,0]]

for i in range(len(X)):
   for j in range(len(Y[0])):
       for k in range(len(Y)):
           result[i][j] += X[i][k] * Y[k][j]

for r in result:
   print(r)
   
# शब्दकोशों की सूची मर्ज करने के लिए एक पायथन प्रोग्राम लिखें
result = {}
for d in L:
    result.update(d)

# अजगर में मर्ज सॉर्ट एल्गोरिथ्म को प्रिंट करने के लिए एक अजगर funvtion लिखें
def mergeSort(myList):
    if len(myList) > 1:
        mid = len(myList) // 2
        left = myList[:mid]
        right = myList[mid:]

        # Recursive call on each half
        mergeSort(left)
        mergeSort(right)

        # Two iterators for traversing the two halves
        i = 0
        j = 0
        
        # Iterator for the main list
        k = 0
        
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
              # The value from the left half has been used
              myList[k] = left[i]
              # Move the iterator forward
              i += 1
            else:
                myList[k] = right[j]
                j += 1
            # Move to the next slot
            k += 1

        # For all the remaining values
        while i < len(left):
            myList[k] = left[i]
            i += 1
            k += 1

        while j < len(right):
            myList[k]=right[j]
            j += 1
            k += 1

myList = [54,26,93,17,77,31,44,55,20]
mergeSort(myList)

# संख्याओं की एक सरणी पर माध्यिका खोजने के लिए एक पायथन फ़ंक्शन लिखें
def median(arr):
  
  if len(arr) == 1:
    return arr[0]
    
  else:
    arr = sorted(arr)
    a = arr[0:round(len(arr)/2)]
    b = arr[len(a):len(arr)]
    if len(arr)%2 == 0:
      return (a[len(a)-1]+b[0])/2
    else:
      return a[len(a)-1]

# लगातार प्राकृतिक संख्याओं की सूची में लापता संख्या खोजने के लिए एक पायथन फ़ंक्शन लिखें
def getMissingNo(A): 
    n = len(A) 
    total = (n + 1)*(n + 2)/2
    sum_of_A = sum(A) 
    return total - sum_of_A 

# संख्याओं की सूची को सामान्य करने और परिणाम को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
a = [2,4,10,6,8,4]
amin, amax = min(a), max(a)
for i, val in enumerate(a):
    a[i] = (val-amin) / (amax-amin)
print(a)

# पायथन में दिए गए स्ट्रिंग के क्रमपरिवर्तन के लिए एक पायथन प्रोग्राम लिखें और परिणाम प्रिंट करें
from itertools import permutations 
import string 
s = "GEEK"
a = string.ascii_letters 
p = permutations(s) 

d = [] 
for i in list(p): 
    if (i not in d): 
        d.append(i) 
        print(''.join(i)) 

# कोई संख्या एक पूर्ण वर्ग है या नहीं यह जांचने के लिए एक पायथन फ़ंक्शन लिखें
def is_perfect_square(n):
    x = n // 2
    y = set([x])
    while x * x != n:
        x = (x + (n // x)) // 2
        if x in y: return False
        y.add(x)
    return True

# एक संख्या किसी दिए गए आधार की शक्ति है या नहीं, यह जांचने के लिए एक पायथन फ़ंक्शन लिखें
import math

def isPower (n, base):
    if base == 1 and n != 1:
        return False
    if base == 1 and n == 1:
        return True
    if base == 0 and n != 1:
        return False
    power = int (math.log(n, base) + 0.5)
    return base ** power == n

# एक सरणी से तीन संख्याएँ खोजने के लिए एक पायथन फ़ंक्शन लिखें जैसे कि तीन संख्याओं का योग शून्य के बराबर हो
def three_Sum(num):
    if len(num)<3: return []
    num.sort()
    result=[]
    for i in range(len(num)-2):
        left=i+1
        right=len(num)-1
        if i!=0 and num[i]==num[i-1]:continue
        while left<right:
            if num[left]+num[right]==-num[i]:
                result.append([num[i],num[left],num[right]])
                left=left+1
                right=right-1
                while num[left]==num[left-1] and left<right:left=left+1
                while num[right]==num[right+1] and left<right: right=right-1
            elif num[left]+num[right]<-num[i]:
                left=left+1
            else:
                right=right-1
    return result

# एक सूची में एक संख्या खोजने के लिए एक पायथन फ़ंक्शन लिखें जो दो बार नहीं होता है
def single_number(arr):
    result = 0
    for i in arr:
        result ^= i
    return result

# एक सूची में एकल तत्व खोजने के लिए एक पायथन फ़ंक्शन लिखें जहां प्रत्येक तत्व एक को छोड़कर तीन बार प्रकट होता है
def single_number(arr):
    ones, twos = 0, 0
    for x in arr:
        ones, twos = (ones ^ x) & ~twos, (ones & x) | (twos & ~x)
    assert twos == 0
    return ones

# एक सकारात्मक पूर्णांक के अंकों को बार-बार जोड़ने के लिए एक फ़ंक्शन प्रोग्राम लिखें जब तक कि परिणाम एक अंक न हो
def add_digits(num):
        return (num - 1) % 9 + 1 if num > 0 else 0
    
# एक पूर्णांक के अंकों को उलटने के लिए एक फंक्शन प्रोग्राम लिखें।
def reverse_integer(x):
        sign = -1 if x < 0 else 1
        x *= sign

        # Remove leading zero in the reversed integer
        while x:
            if x % 10 == 0:
                x /= 10
            else:
                break

        # string manipulation
        x = str(x)
        lst = list(x)  # list('234') returns ['2', '3', '4']
        lst.reverse()
        x = "".join(lst)
        x = int(x)
        return sign*x

# एक पूर्णांक के बिट्स को उलटने के लिए एक पायथन फ़ंक्शन लिखें (32 बिट्स अहस्ताक्षरित)
def reverse_Bits(n):
        result = 0
        for i in range(32):
            result <<= 1
            result |= n & 1
            n >>= 1
        return result
    
# संख्याओं के अनुक्रम की जांच करने के लिए एक पायथन फ़ंक्शन लिखें अंकगणितीय प्रगति है या नहीं
def is_arithmetic(l):
    delta = l[1] - l[0]
    for index in range(len(l) - 1):
        if not (l[index + 1] - l[index] == delta):
             return False
    return True

# पायथन चुनौतियाँ: संख्याओं के अनुक्रम की जाँच करना एक ज्यामितीय प्रगति है या नहीं
def is_geometric(li):
    if len(li) <= 1:
        return True
    # Calculate ratio
    ratio = li[1]/float(li[0])
    # Check the ratio of the remaining
    for i in range(1, len(li)):
        if li[i]/float(li[i-1]) != ratio: 
            return False
    return True 

# दो उलटी संख्याओं के योग की गणना करने के लिए एक पायथन फ़ंक्शन लिखें और योग को उलटे रूप में प्रदर्शित करें
def reverse_sum(n1, n2):
    return int(str(int(str(n1)[::-1]) + int(str(n2)[::-1]))[::-1])

# एक पायथन फ़ंक्शन लिखें जहां आप कोई सकारात्मक पूर्णांक n लेते हैं, यदि n सम है, तो n / 2 प्राप्त करने के लिए इसे 2 से विभाजित करें। यदि n विषम है, तो इसे 3 से गुणा करें और 3n + 1 प्राप्त करने के लिए 1 जोड़ें। इस प्रक्रिया को तब तक दोहराएं जब तक आप 1 पहुंचें
def collatz_sequence(x):
    num_seq = [x]
    if x < 1:
       return []
    while x > 1:
       if x % 2 == 0:
         x = x / 2
       else:
         x = 3 * x + 1
       num_seq.append(x)    
    return num_seq

# यह जांचने के लिए एक पायथन फ़ंक्शन लिखें कि क्या दिया गया स्ट्रिंग किसी अन्य दिए गए स्ट्रिंग का विपर्यय है
def is_anagram(str1, str2):
    list_str1 = list(str1)
    list_str1.sort()
    list_str2 = list(str2)
    list_str2.sort()

    return (list_str1 == list_str2)

# किसी सूची के अंत में सभी शून्यों को पुश करने के लिए एक पायथन फ़ंक्शन लिखें
def move_zero(num_list):
    a = [0 for i in range(num_list.count(0))]
    x = [ i for i in num_list if i != 0]
    x.extend(a)
    return(x)

# सूची के अंत में पहली संख्या को पुश करने के लिए एक पायथन फ़ंक्शन लिखें
def move_last(num_list):
    a = [num_list[0] for i in range(num_list.count(num_list[0]))]
    x = [ i for i in num_list if i != num_list[0]]
    x.extend(a)
    return(x)

# अंतिम शब्द की लंबाई ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें
def length_of_last_word(s):
        words = s.split()
        if len(words) == 0:
            return 0
        return len(words[-1])

# दो बाइनरी नंबरों को जोड़ने के लिए एक पायथन फंक्शन लिखें
def add_binary_nums(x,y):
        max_len = max(len(x), len(y))

        x = x.zfill(max_len)
        y = y.zfill(max_len)

        result = ''
        carry = 0

        for i in range(max_len-1, -1, -1):
            r = carry
            r += 1 if x[i] == '1' else 0
            r += 1 if y[i] == '1' else 0
            result = ('1' if r % 2 == 1 else '0') + result
            carry = 0 if r < 2 else 1       

        if carry !=0 : result = '1' + result

        return result.zfill(max_len)

# एक एकल संख्या ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें जो विषम संख्याएँ होती हैं और अन्य संख्याएँ सम संख्याएँ होती हैं
def odd_occurrence(arr):
 
    # Initialize result
    result = 0
     
    # Traverse the array
    for element in arr:
        # XOR
        result = result ^ element
 
    return result

# एक पायथन फ़ंक्शन लिखें जो एक स्ट्रिंग लेता है और इसे एन्कोड करता है कि प्रतीकों की मात्रा पूर्णांक और प्रतीक द्वारा दर्शायी जाएगी
For example, the string "AAAABBBCCDAAA" would be encoded as "4A3B2C1D3A"
def encode_string(str1):
    encoded = ""
    ctr = 1
    last_char = str1[0]

    for i in range(1, len(str1)):

        if last_char == str1[i]:
            ctr += 1
         
        else:
            encoded += str(ctr) + last_char
            ctr = 0
            last_char = str1[i]
            ctr += 1
    encoded += str(ctr) + last_char
    return encoded

# एक नया सरणी बनाने के लिए एक पायथन फ़ंक्शन लिखें जैसे कि नई सरणी के सूचकांक i पर प्रत्येक तत्व पूर्णांक के दिए गए सरणी के सभी नंबरों का उत्पाद है, एक को छोड़कर
def product(nums):
    new_nums = []

    for i in nums:
        nums_product = 1

        for j in nums:     
            if j != i:
                nums_product = nums_product * j
        new_nums.append(nums_product)

    return new_nums

# पहले दो सौ प्राकृतिक संख्याओं के वर्गों के योग और योग के वर्ग के बीच का अंतर ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें
r = range(1, 201)
a = sum(r)
print (a * a - sum(i*i for i in r))

# संख्या 2 के अंकों के योग की शक्ति 20 की गणना करने के लिए एक पायथन फ़ंक्शन लिखें
def digits_sum():
	n = 2**20
	ans = sum(int(c) for c in str(n))
	return str(ans)

# 500 से नीचे 3 या 5 के सभी गुणकों के योग की गणना करने के लिए एक पायथन प्रोग्राम लिखें
n = 0
for i in range(1,500):
     if not i % 5 or not i % 3:
         n = n + i
print(n)

# किसी भी आधार में एक पूर्णांक को एक स्ट्रिंग में परिवर्तित करने के लिए एक पायथन फ़ंक्शन लिखें
def to_string(n,base):
   conver_tString = "0123456789ABCDEF"
   if n < base:
      return conver_tString[n]
   else:
      return to_string(n//base,base) + conver_tString[n % base

# N-1 के ज्यामितीय योग की गणना करने के लिए एक पायथन फ़ंक्शन लिखें
def geometric_sum(n):
  if n < 0:
    return 0
  else:
    return 1 / (pow(2, n)) + geometric_sum(n - 1)

# दो पूर्णांकों का महत्तम समापवर्तक (gcd) ज्ञात करने के लिए एक Python फलन लिखिए
def Recurgcd(a, b):
	low = min(a, b)
	high = max(a, b)

	if low == 0:
		return high
	elif low == 1:
		return 1
	else:
		return Recurgcd(low, high%low)

# प्रिंट करने के लिए एक प्रोग्राम लिखें जो ऐसी सभी संख्याओं को खोजेगा जो 7 से विभाज्य हैं लेकिन 5 के गुणक नहीं हैं
between 2000 and 3200 (both included).  
l=[]
for i in range(2000, 3201):
    if (i%7==0) and (i%5!=0):
        l.append(str(i))

print ','.join(l)


# प्रिंट करने के लिए एक प्रोग्राम लिखें जो ऐसी सभी संख्याओं को खोजेगा जो 7 से विभाज्य हैं लेकिन 5 के गुणक नहीं हैं,
import math
a = float(input("Enter the first coefficient: "))
b = float(input("Enter the second coefficient: "))
c = float(input("Enter the third coefficient: "))
if (a!=0.0):
    d = (bb)-(4ac) 
    if (d==0.0):
        print("The roots are real and equal.") 
        r = -b/(2a)
        print("The roots are ", r,"and", r)
    elif(d>0.0):
        print("The roots are real and distinct.")
        r1 = (-b+(math.sqrt(d)))/(2a) 
        r2 = (-b-(math.sqrt(d)))/(2a)
        print("The root1 is: ", r1)
        print("The root2 is: ", r2)
    else:
        print("The roots are imaginary.")
        rp = -b/(2a) ip = math.sqrt(-d)/(2a)
        print("The root1 is: ", rp, "+ i",ip)
        print("The root2 is: ", rp, "- i",ip)
else:
    print("Not a quadratic equation."

# दिए गए बायटेरेरे को हेक्साडेसिमल स्ट्रिंग में बदलने के लिए एक पायथन प्रोग्राम लिखें
def bytearray_to_hexadecimal(list_val):
     result = ''.join('{:02x}'.format(x) for x in list_val)  
     return(result)
     

# किसी दिए गए स्ट्रिंग के समान पहले और अंतिम वर्णों वाले सबस्ट्रिंग की संख्या गिनने के लिए एक पायथन प्रोग्राम लिखें
def no_of_substring_with_equalEnds(str1): 
	result = 0; 
	n = len(str1); 
	for i in range(n): 
		for j in range(i, n): 
			if (str1[i] == str1[j]): 
				result = result + 1
	return result
 
# सिंगल ट्रैवर्सल में दिए गए स्ट्रिंग के सामने सभी जगहों को स्थानांतरित करने के लिए एक पायथन प्रोग्राम लिखें।
def moveSpaces(str1): 
    no_spaces = [char for char in str1 if char!=' ']   
    space= len(str1) - len(no_spaces)
    result = ' '*space    
    return result + ''.join(no_spaces)

# किसी दिए गए बाइनरी स्ट्रिंग में लगातार 0 की अधिकतम लंबाई खोजने के लिए एक पायथन प्रोग्राम लिखें
def max_consecutive_0(input_str): 
     return  max(map(len,input_str.split('1')))
str1 = '111000010000110'
print("Original string:" + str1)
print("Maximum length of consecutive 0’s:")

# एक पायथन प्रोग्राम लिखें जो प्रत्येक तत्व को उसकी गिनती के रूप में कई बार दोहराता है
from collections import Counter
c = Counter(p=4, q=2, r=0, s=-2)
print(list(c.elements()))

# सूची में दूसरी सबसे छोटी संख्या खोजने के लिए एक पायथन प्रोग्राम लिखें
def second_smallest(numbers):
  if (len(numbers)<2):
    return
  if ((len(numbers)==2)  and (numbers[0] == numbers[1]) ):
    return
  dup_items = set()
  uniq_items = []
  for x in numbers:
    if x not in dup_items:
      uniq_items.append(x)
      dup_items.add(x)
  uniq_items.sort()    
  return  uniq_items[1]
  
  
# किसी सूची में एक सबलिस्ट शामिल है या नहीं, यह जांचने के लिए एक पायथन फ़ंक्शन लिखें
def is_Sublist(l, s):
	sub_set = False
	if s == []:
		sub_set = True
	elif s == l:
		sub_set = True
	elif len(s) > len(l):
		sub_set = False

	else:
		for i in range(len(l)):
			if l[i] == s[0]:
				n = 1
				while (n < len(s)) and (l[i+n] == s[n]):
					n += 1
				
				if n == len(s):
					sub_set = True

	return sub_set
 
 
# किसी सूची में लगातार पाँच संख्याओं के समूह उत्पन्न करने के लिए एक पायथन प्रोग्राम लिखे
l = [[5*i + j for j in range(1,6)] for i in range(5)]
print(l)

# उन सूचियों की सूची में सूची को मुद्रित करने के लिए एक पायथन प्रोग्राम लिखें जिनके तत्वों का योग उच्चतम है
print(max(num, key=sum))

# एक शब्दकोश की गहराई को प्रिंट करने के लिए एक पायथन फक्शन लिखें
def dict_depth(d):
    if isinstance(d, dict):
        return 1 + (max(map(dict_depth, d.values())) if d else 0)
    return 0
dic = {'a':1, 'b': {'c': {'d': {}}}}
print(dict_depth(dic))

# किसी दिए गए सूची तत्वों के लगातार डुप्लिकेट को सबलिस्ट में पैक करने और आउटपुट प्रिंट करने के लिए एक पायथन फ़ंक्शन लिखें
from itertools import groupby
def pack_consecutive_duplicates(l_nums):
    return [list(group) for key, group in groupby(l_nums)]
n_list = [0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4 ]
print("Original list:") 
print(n_list)
print("\nAfter packing consecutive duplicates of the said list elements into sublists:")
print(pack_consecutive_duplicates(n_list)) 

# पूर्णांकों की दी गई सूची या वर्णों की दी गई सूची से संशोधित रन-लेंथ एन्कोडिंग को दर्शाने वाली सूची बनाने के लिए एक पायथन फ़ंक्शन लिखें और आउटपुट प्रिंट करें
from itertools import groupby
def modified_encode(alist):
        def ctr_ele(el):
            if len(el)>1: return [len(el), el[0]]
            else: return el[0]
        return [ctr_ele(list(group)) for key, group in groupby(alist)]

n_list = [1,1,2,3,4,4,5, 1]
print("Original list:") 
print(n_list)
print("\nList reflecting the modified run-length encoding from the said list:")
print(modified_encode(n_list))

# शून्य के साथ एक बहुआयामी सूची (सूचियों की सूची) बनाने के लिए एक पायथन फ़ंक्शन लिखें और आउटपुट प्रिंट करें
nums = []

for i in range(3):

    nums.append([])

    for j in range(2):

        nums[i].append(0)
print("Multidimensional list:")
print(nums)

# कंसोल से एक वर्ग मैट्रिक्स को पढ़ने के लिए एक पायथन फ़ंक्शन लिखें और मैट्रिक्स प्राथमिक विकर्ण के योग को प्रिंट करें। उपयोगकर्ता से इनपुट के रूप में (प्रत्येक पंक्ति के लिए) एक स्थान के साथ अलग किए गए प्रत्येक स्तंभ के लिए वर्ग मैट्रिक्स के आकार और तत्वों को स्वीकार करें और आउटपुट प्रिंट करें

size = int(input("Input the size of the matrix: "))
matrix = [[0] * size for row in range(0, size)]
for x in range(0, size):

    line = list(map(int, input().split()))

    for y in range(0, size):
        matrix[x][y] = line[y]

matrix_sum_diagonal = sum(matrix[size - i - 1][size - i - 1] for i in range(size))

# एक नेस्टेड सूची किसी अन्य नेस्टेड सूची का सबसेट है या नहीं यह जांचने के लिए एक पायथन फ़ंक्शन लिखें और आउटपुट प्रिंट करें
def checkSubset(input_list1, input_list2): 
    return all(map(input_list1.__contains__, input_list2)) 
      

list1 = [[1, 3], [5, 7], [9, 11], [13, 15, 17]] 
list2 = [[1, 3],[13,15,17]]   
print("Original list:")
print(list1)
print(list2)
print("\nIf the one of the said list is a subset of another.:")
print(checkSubset(list1, list2))

# किसी दिए गए स्ट्रिंग के वर्णों की पुनरावृत्ति संख्या के साथ सभी क्रमपरिवर्तन प्रिंट करने के लिए एक पायथन फ़ंक्शन लिखें और आउटपुट प्रिंट करें
from itertools import product
def all_repeat(str1, rno):
  chars = list(str1)
  results = []
  for c in product(chars, repeat = rno):
    results.append(c)
  return results
print(all_repeat('xyz', 3))

# किसी दिए गए स्ट्रिंग की अनुक्रमणिका खोजने के लिए एक पायथन फ़ंक्शन लिखें जिस पर एक दिया गया सबस्ट्रिंग शुरू होता है। यदि दिए गए स्ट्रिंग रिटर्न में सबस्ट्रिंग नहीं मिला है तो 'नहीं मिला' और आउटपुट प्रिंट करें
def find_Index(str1, pos):
    if len(pos) > len(str1):
        return 'Not found'

    for i in range(len(str1)):

        for j in range(len(pos)):

            if str1[i + j] == pos[j] and j == len(pos) - 1:
                return i
                
            elif str1[i + j] != pos[j]:
                break

    return 'Not found

# प्रथम n संख्याओं का सबसे छोटा गुणज ज्ञात करने के लिए एक Python प्रोग्राम लिखिए। कारकों को भी प्रदर्शित कीजिए
def smallest_multiple(n):
    if (n<=2):
      return n
    i = n * 2
    factors = [number  for number in range(n, 1, -1) if number * 2 > n]
    print(factors)

    while True:
        for a in factors:
            if i % a != 0:
                i += n
                break
            if (a == factors[-1] and i % a == 0):
                return i
                
# किसी दिए गए स्ट्रिंग (डुप्लिकेट सहित) के सभी क्रमपरिवर्तनों को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
def permute_string(str):
    if len(str) == 0:
        return ['']
    prev_list = permute_string(str[1:len(str)])
    next_list = []
    for i in range(0,len(prev_list)):
        for j in range(0,len(str)):
            new_str = prev_list[i][0:j]+str[0]+prev_list[i][j:len(str)-1]
            if new_str not in next_list:
                next_list.append(new_str)
    return next_lis
    
# पायथन में '*' ऑपरेटर का उपयोग किए बिना दो पूर्णांकों को गुणा करने के लिए एक पायथन प्रोग्राम लिखें
def multiply(x, y):
    if y < 0:
        return -multiply(x, -y)
    elif y == 0:
        return 0
    elif y == 1:
        return x
    else:
        return x + multiply(x, y - 1)

# अक्षांश और देशांतर का उपयोग करके दो बिंदुओं के बीच की दूरी की गणना करने के लिए एक पायथन प्रोग्राम लिखें
from math import radians, sin, cos, acos

print("Input coordinates of two points:")
slat = radians(float(input("Starting latitude: ")))
slon = radians(float(input("Ending longitude: ")))
elat = radians(float(input("Starting latitude: ")))
elon = radians(float(input("Ending longitude: ")))

dist = 6371.01 * acos(sin(slat)*sin(elat) + cos(slat)*cos(elat)*cos(slon - elon))
print("The distance is %.2fkm." % dist)

# रोमन अंक को पूर्णांक में बदलने के लिए पायथन क्लास लिखें
class Solution:
    def roman_to_int(self, s):
        rom_val = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
        int_val = 0
        for i in range(len(s)):
            if i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]:
                int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]
            else:
                int_val += rom_val[s[i]]
        return int_val

# एक पूर्णांक को रोमन अंक में बदलने के लिए एक पायथन क्लास लिखें
class Solution:
    def int_to_Roman(self, num):
        val = [
            1000, 900, 500, 400,
            100, 90, 50, 40,
            10, 9, 5, 4,
            1
            ]
        syb = [
            "M", "CM", "D", "CD",
            "C", "XC", "L", "XL",
            "X", "IX", "V", "IV",
            "I"
            ]
        roman_num = ''
        i = 0
        while  num > 0:
            for _ in range(num // val[i]):
                roman_num += syb[i]
                num -= val[i]
            i += 1
        return roman_num

# दो पायथन डिक्शनरी को मर्ज करने और मर्ज किए गए डिक्शनरी को प्रिंट करने के लिए एक प्रोग्राम लिखें
d1 = {'a': 100, 'b': 200}
d2 = {'x': 300, 'y': 200}
d = d1.copy()
d.update(d2)
print(d)


# स्ट्रिंग संघनन जैसे दो पूर्णांकों को जोड़ने के लिए एक पायथन फ़ंक्शन लिखें और समेकित संख्या को पूर्णांक के रूप में वापस करें
def concat_two_numbers(num1, num2):
    combined_num = str(num1) + str(num2)
    return int(combined_num)


# दिए गए इंटीग्रल नंबर n के साथ, एक डिक्शनरी जनरेट करने के लिए एक प्रोग्राम लिखें जिसमें (i, i*i*i) ऐसा हो जो 1 और n (दोनों शामिल) के बीच का इंटीग्रल नंबर हो। और फिर प्रोग्राम को डिक्शनरी प्रिंट करनी चाहिए
n = 8
d = dict()
for i in range(1,n+1):
    d[i] = i*i*i
print(d)

# एक प्रोग्राम लिखें जो कंसोल से अल्पविराम से अलग संख्याओं के अनुक्रम को स्वीकार करता है और एक सूची और एक टपल उत्पन्न करता है जिसमें प्रत्येक संख्या होती है
values=input()
l=values.split(",")
t=tuple(l)
print(l)
print(t)

# एक पायथन फ़ंक्शन लिखें जो संख्याओं का एक क्रम लेता है और यह निर्धारित करता है कि क्या सभी संख्याएँ एक दूसरे से भिन्न हैं
def test_distinct(data):
  if len(data) == len(set(data)):
    return True
  else:
    return False

# दी गई राशि के विरुद्ध नोटों की संख्या (नोट्स का नमूना: 10, 20, 50, 100, 200 और 500) खोजने के लिए एक पायथन फ़ंक्शन लिखें।
def no_notes(a):
  Q = [500, 200, 100, 50, 20, 10, 5, 2, 1]
  x = 0
  for i in range(9):
    q = Q[i]
    x += int(a / q)
    a = int(a % q)
  if a > 0:
    x = -1
  return x


# किसी दिए गए धनात्मक संख्या के भाज्य के अंत में शून्य की संख्या ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।
def factendzero(n):
  x = n // 5
  y = x 
  while x > 0:
    x /= 5
    y += int(x)
  return y


# किसी दिए गए धनात्मक संख्या के भाज्य के अंत में शून्य की संख्या ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें
def binary_search(l, num_find):
    '''
    This function is used to search any number.
    Whether the given number is present in the
    list or not. If the number is present in list
    the list it will return TRUE and FALSE otherwise.
    '''
    start = 0
    end = len(l) - 1
    mid = (start + end) // 2
    found = False
    position = -1
    while start <= end:
        if l[mid] == num_find:
            found = True
            position = mid
            break
        if num_find > l[mid]:
            start = mid + 1
            mid = (start + end) // 2
        else:
            end = mid - 1
            mid = (start + end) // 2
    return (found, position)


# आईपी ​​​​पते से अग्रणी शून्य को हटाने के लिए एक पायथन फ़ंक्शन लिखें
import re
regex = '\.[0]*'
def remove_leading_zeros(ip):
    modified_ip = re.sub(regex, '.', ip)
    return modified_ip


# किसी दिए गए पूर्णांक के बाइनरी मान को वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def int_to_bin(a):
  return bin(a)


# किसी दिए गए पूर्णांक का ऑक्टल मान वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def int_to_oct(a):
  return oct(a)


# किसी दिए गए पूर्णांक के हेक्साडेसिमल मान को वापस करने के लिए एक पायथन फ़ंक्शन लिखें
def int_to_hex(a):
  return hex(a)


# पूर्णांक में दिए गए इनपुट को टाइपकास्ट करने के लिए एक पायथन प्रोग्राम लिखें
num = int(input("Input a value: "))
print(num)


# फ्लोट करने के लिए दिए गए इनपुट को टाइपकास्ट करने के लिए एक पायथन प्रोग्राम लिखें
num = float(input("Input a value: "))
print(num)


# एक मूल्य के विरुद्ध कई चरों की जाँच/परीक्षण करने के लिए एक पायथन प्रोग्राम लिखें
a = 10
b = 20
c = 30
if 10 in {a, b, c}:
  print("True")
else:
  print("False")  


# एक पायथन वर्ग लिखें जो एक संख्या आरंभ करेगा, एक संख्या दर्ज करेगा और संख्या को प्रिंट करेगा
class Number:
	def __init__(self, num):
		self.num = num

	def inputNum(self):
		self.num = int(input("Enter an integer number: "))

	def printNum(self):
		print(self.num)


# जब सिद्धांत राशि, ब्याज दर और समय दिया गया हो, तो पायथन में साधारण ब्याज खोजने के लिए एक पायथन फ़ंक्शन लिखें
def simple_interest(p,r,t):
    si = (p*r*t)/100
    return si


# जब सिद्धांत राशि, ब्याज दर और समय दिया गया हो, तो पायथन में चक्रवृद्धि ब्याज का पता लगाने के लिए एक पायथन फ़ंक्शन लिखें
def compound_interest(p,r,t):
    ci = p * (pow((1 + r / 100), t)) 
    return ci


# कोई व्यक्ति अपनी उम्र के आधार पर मतदान के योग्य है या नहीं, यह जांचने के लिए एक पायथन फ़ंक्शन लिखें
def vote_eligibility(age):
	if age>=18:
	    status="Eligible"
	else:
	    status="Not Eligible"
	return status


# किसी व्यक्ति के दिए गए वजन और ऊंचाई के लिए बीएमआई खोजने के लिए एक पायथन फ़ंक्शन लिखें
def bmi_calculator(height, weight):
	bmi = weight/(height**2)
	return bmi

# दी गई संख्या पूर्ण संख्या है या नहीं, यह जांचने के लिए एक पायथन फ़ंक्शन लिखें
def perfect_number_checker(num):
    i = 2
    sum = 1
    while(i <= num//2 ) :
        if (num % i == 0) :
            sum += i
        i += 1
    if sum == num :
        return f'{num} is a perfect number'

    else :
        return f'{num} is not a perfect number'

# किसी दी गई सूची से अधिकतम ODD संख्या ज्ञात करने के लिए एक Python फंक्शन लिखें
def odd_max_checker(list1):
	maxnum = 0
	for num in list1:
	    if num%2 != 0:
	        if num > maxnum:
	            maxnum = num
	return maxnum


# किसी दी गई सूची से अधिकतम EVEN संख्या ज्ञात करने के लिए एक Python फ़ंक्शन लिखें
def even_max_checker(list1):
	maxnum = 0
	for num in list1:
	    if num%2 == 0:
	        if num > maxnum:
	            maxnum = num
	return maxnum


# द्विघात समीकरण की जड़ को प्रिंट करने के लिए एक पायथन फ़ंक्शन लिखें
def quadratic_root(A,B,C):
	import math
	d=((B**2)-4*A*C)

	if d>=0:
	    s=(-B+(d)**0.5)/(2*A)
	    p=(-B-(d)**0.5)/(2*A)
	    print(math.floor(s),math.floor(p))
	else:
	    print('The roots are imaginary')


# किसी दिए गए वर्ष के कैलेंडर को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
import calendar
year=2020
print(calendar.calendar(year))


# दी गई तारीख मान्य है या नहीं, यह प्रिंट करने के लिए एक पायथन फ़ंक्शन लिखें
def date_validator(d,m,y):
	import datetime 
	try:
		s=datetime.date(y,m,d)
		print("Date is valid.")
	except ValueError: 
		print("Date is invalid.")


# एन-वें नंबर को खोजने के लिए एक पायथन फ़ंक्शन लिखें जो वर्ग और घन दोनों है
def nth_sq_and_cube(N):
	R = N**6
	return R


# एक संख्या दूसरी संख्या की शक्ति है या नहीं यह जांचने के लिए एक पायथन फ़ंक्शन लिखें
def power_checker(a,b):
	import math
	s=math.log(a,b)
	p=round(s)
	if (b**p)==a:
	    return f'{a} is the power of {b}.'
	else:
	    return f'{a} is NOT the power of {b}.'

# सभी खोजशब्दों की सूची मुद्रित करने के लिए एक पायथन प्रोग्राम लिखें
import keyword
print("Python keywords are...")
print(keyword.kwlist)


# दो सरणियों के प्रतिच्छेदन को खोजने के लिए एक पायथन फ़ंक्शन लिखें
def array_intersection(A,B):
	inter=list(set(A)&set(B))
	return inter


# दो सरणियों के मिलन को खोजने के लिए एक पायथन फ़ंक्शन लिखें
def array_union(A,B):
	union=list(set(A)|set(B))
	return union


# एक पायथन प्रोग्राम लिखें जो डुप्लिकेट को हटाकर दोनों सेटों के सभी आइटमों के साथ एक नया सेट प्रिंट करता है

set1 = {10, 20, 30, 40, 50}
set2 = {30, 40, 50, 60, 70}
print(set1.union(set2))


# एक पायथन प्रोग्राम लिखें जो दो पायथन सेट को देखते हुए, पहले सेट को उन आइटम्स के साथ अपडेट करें जो केवल पहले सेट में मौजूद हैं और दूसरे सेट में नहीं

set1 = {10, 20, 30}
set2 = {20, 40, 50}
print(set1.difference_update(set2))


# एक पायथन प्रोग्राम लिखें जो A या B में सभी तत्वों का एक सेट प्रिंट करता है, लेकिन दोनों नहीं

set1 = {10, 20, 30, 40, 50}
set2 = {30, 40, 50, 60, 70}
print(set1.symmetric_difference(set2))


# एक पायथन प्रोग्राम लिखें जो यह निर्धारित करता है कि निम्नलिखित दो सेटों में कोई तत्व समान है या नहीं। यदि हाँ, तो सामान्य तत्वों को प्रदर्शित करें

set1 = {10, 20, 30, 40, 50}
set2 = {60, 70, 80, 90, 10}
if set1.isdisjoint(set2):
  print("Two sets have no items in common")
else:
  print("Two sets have items in common")
  print(set1.intersection(set2))

# हजारों विभाजक के रूप में अल्पविराम के साथ संख्या को प्रिंट करने के लिए एक पायथन फ़ंक्शन लिखें
def formattedNumber(n):
  return ("{:,}".format(n))


# किसी दिए गए स्ट्रिंग में अपरकेस और लोअरकेस अक्षरों की कुल संख्या ज्ञात करने के लिए एक पायथन प्रोग्राम लिखें
str1='TestStringInCamelCase'
no_of_ucase, no_of_lcase = 0,0
for c in str1:
    if c>='A' and c<='Z':
        no_of_ucase += 1
    if c>='a' and c<='z':
        no_of_lcase += 1

print(no_of_lcase)
print(no_of_ucase)


# दिए गए स्ट्रिंग में अक्षरों और अंकों की कुल संख्या ज्ञात करने के लिए एक पायथन प्रोग्राम लिखें
str1='TestStringwith123456789'
no_of_letters, no_of_digits = 0,0
for c in str1:
  no_of_letters += c.isalpha()
  no_of_digits += c.isnumeric()

print(no_of_letters)
print(no_of_digits)


# दिए गए पाठ में किसी शब्द की उपस्थिति की गणना करने के लिए एक पायथन फ़ंक्शन लिखें
def text_searcher(text, word):
    count = 0
    for w in text.split():
        if w == word:
            count = count + 1
    return count


# एक स्ट्रिंग में प्रत्येक शब्द के पहले अक्षर को कैपिटलाइज़ करने के लिए एक पायथन फ़ंक्शन लिखें
def capitalize(text):
  return text.title()


# किसी सूची से मिथ्या मानों को हटाने के लिए एक पाइथॉन फंक्शन लिखिए
def newlist(lst):
  return list(filter(None, lst))


# दिए गए पूर्णांक के सभी अंकों का योग ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें
def sum_of_digits(num):
  if num == 0:
    return 0
  else:
    return num % 10 + sum_of_digits(int(num / 10))


# सूची के सभी तत्व समान हैं या नहीं, यह जांचने के लिए एक पायथन फ़ंक्शन लिखें
def check_equal(a):
  return a[1:] == a[:-1]


# स्ट्रिंग को डेटाइम ऑब्जेक्ट में बदलने के लिए एक पायथन प्रोग्राम लिखें
from datetime import datetime
date_string = "Mar 26 2021  4:20PM"
datetime_object = datetime.strptime(date_string, '%b %d %Y %I:%M%p')
print(datetime_object)


# एक पायथन फ़ंक्शन लिखें जो दिए गए पूर्णांक के अंकों को उलट कर प्राप्त पूर्णांक देता है
def reverse(n):
    s=str(n) 
    p=s[::-1]
    return p 


# एक पायथन प्रोग्राम लिखें जो सामान्य वस्तुओं को छोड़कर, सेट 2 से आइटम जोड़कर सेट 1 को अपडेट करता है
set1 = {10, 20, 30, 40, 50}
set2 = {30, 40, 50, 60, 70}
set1.symmetric_difference_update(set2)
print(set1)


# एक पायथन प्रोग्राम लिखें जो सेट 1 से उन आइटम्स को हटा देता है जो सेट 1 और सेट 2 दोनों के लिए सामान्य नहीं हैं
set1 = {10, 20, 30, 40, 50}
set2 = {30, 40, 50, 60, 70}
set1.intersection_update(set2)
print(set1)


# एक टपल को उलटने के लिए एक पायथन प्रोग्राम लिखें
aTuple = (10, 20, 30, 40, 50)
aTuple = aTuple[::-1]
print(aTuple)


# दो टुपल्स को स्वैप करने के लिए एक पायथन प्रोग्राम लिखें
tuple1 = (11, 22)
tuple2 = (99, 88)
tuple1, tuple2 = tuple2, tuple1
print(tuple2)
print(tuple1)


# निम्नलिखित टपल के अंदर सूची के दूसरे आइटम (33) को 333 में संशोधित करने के लिए एक पायथन प्रोग्राम लिखें
tuple1 = (11, [22, 33], 44, 55)
tuple1[1][1] = 333
print(tuple1)


# टुपल्स के टुपल्स को दूसरे आइटम द्वारा सॉर्ट करने के लिए एक पायथन प्रोग्राम लिखें
tuple1 = (('a', 23),('b', 37),('c', 11), ('d',29))
tuple1 = tuple(sorted(list(tuple1), key=lambda x: x[1]))
print(tuple1)


# निम्नलिखित टपल में सभी आइटम समान हैं या नहीं, यह जांचने के लिए एक पायथन फ़ंक्शन लिखें
def check_tuple_same(sampleTuple):
    return all(i == sampleTuple[0] for i in sampleTuple)


# मिलीसेकंड में वर्तमान समय को प्रिंट करने के लिए एक पायथन प्रोग्राम लिखें
import time
milliseconds = int(round(time.time() * 1000))
print(milliseconds)


# एक पायथन फ़ंक्शन func1 () लिखें, जैसे कि यह तर्क की एक चर लंबाई को स्वीकार कर सकता है और सभी तर्क मान प्रिंट कर सकता है
def func1(*args):
    for i in args:
        print(i)

# एक पायथन प्रोग्राम लिखें जिसमें दो पायथन सूची दी गई हो। दोनों सूचियों को एक साथ पुनरावृत्त करें जैसे कि सूची 1 को आइटम को मूल क्रम में और सूची 2 को उल्टे क्रम में प्रदर्शित करना चाहिए
list1 = [10, 20, 30, 40]
list2 = [100, 200, 300, 400]

for x, y in zip(list1, list2[::-1]):
    print(x, y)

# एक पायथन फ़ंक्शन लिखें जो एक स्ट्रिंग को देखते हुए, केवल उन वर्णों को प्रदर्शित करता है जो एक सम अनुक्रमणिका संख्या पर मौजूद हैं
def printEveIndexChar(str):
  for i in range(0, len(str)-1, 2):
    print("index[",i,"]", str[i] )


# एक पायथन फ़ंक्शन लिखें जिसमें एक स्ट्रिंग और एक पूर्णांक संख्या n दी गई हो, शून्य से n तक शुरू होने वाली स्ट्रिंग से वर्णों को हटा दें और एक नया स्ट्रिंग लौटाएं
def removeChars(str, n):
  return str[n:]


# एक पायथन फ़ंक्शन लिखें जो संख्याओं की एक सूची को देखते हुए, यदि किसी सूची की पहली और अंतिम संख्या समान है, तो True लौटाएं
def isFirst_And_Last_Same(numberList):
    firstElement = numberList[0]
    lastElement = numberList[-1]
    if (firstElement == lastElement):
        return True
    else:
        return False

# एक पायथन फ़ंक्शन लिखें जो संख्याओं की एक सूची दी गई है, इसे पुनरावृत्त करें और केवल उन संख्याओं को प्रिंट करें जो 5 से विभाज्य हैं
def findDivisible(numberList):
    for num in numberList:
        if (num % 5 == 0):
            print(num)


# एक पायथन फ़ंक्शन लिखें जो संख्याओं की दो सूची को देखते हुए एक नई सूची बनाता है जैसे कि नई सूची में पहली सूची से केवल विषम संख्याएँ और दूसरी सूची से संख्याएँ भी होनी चाहिए
def mergeList(list1, list2):
    thirdList = []
    for num in list1:
        if (num % 2 != 0):
            thirdList.append(num)
    for num in list2:
        if (num % 2 == 0):
            thirdList.append(num)
    return thirdList


# ए या बी में सभी तत्वों का एक सेट वापस करने के लिए एक पायथन प्रोग्राम लिखें, लेकिन दोनों नहीं
set1 = {10, 20, 30, 40, 50}
set2 = {30, 40, 50, 60, 70}
print(set1.symmetric_difference(set2))


# पायथन में दी गई तारीख से एक सप्ताह (7 दिन) घटाने के लिए एक पायथन प्रोग्राम लिखें
from datetime import datetime, timedelta
given_date = datetime(2020, 2, 25)
days_to_subtract = 7
res_date = given_date - timedelta(days=days_to_subtract)
print(res_date)


# किसी दिए गए दिनांक के सप्ताह का दिन खोजने के लिए एक पायथन प्रोग्राम लिखें
from datetime import datetime
given_date = datetime(2020, 7, 26)
print(given_date.strftime('%A'))


# निम्नलिखित डेटाटाइम उदाहरण को स्ट्रिंग प्रारूप में बदलने के लिए एक पायथन प्रोग्राम लिखें
from datetime import datetime
given_date = datetime(2020, 2, 25)
string_date = given_date.strftime("%Y-%m-%d %H:%M:%S")
print(string_date)


# दो समान लंबाई के सेट को डिक्शनरी में बदलने के लिए एक पायथन प्रोग्राम लिखें
keys = {'Ten', 'Twenty', 'Thirty'}
values = {10, 20, 30}
sampleDict = dict(zip(keys, values))
print(sampleDict)



# एक प्रोग्राम लिखें जो ऐसी सभी संख्याओं को खोजेगा जो 7 से विभाज्य हैं लेकिन 2000 और 3200 (दोनों शामिल) के बीच 5 के गुणक नहीं हैं

l=[]
for i in range(2000, 3201):
    if (i%7==0) and (i%5!=0):
        l.append(str(i))


# एक प्रोग्राम लिखें जो ऑब्जेक्ट के प्रकार को निर्धारित करेगा

def typeIdentifier(object):
  return f'object type : {type(object)}'

# एक पायथन वर्ग लिखें जिसमें कम से कम दो विधियाँ हों: getString: कंसोल इनपुट से एक स्ट्रिंग प्राप्त करने के लिए PrintString: ऊपरी मामले में स्ट्रिंग को प्रिंट करने के लिए

class IOString(object):
    def __init__(self):
        self.s = ""

    def getString(self):
        self.s = input()
    
    def printString(self):
        print(self.s.upper())

strObj = IOString()
strObj.getString()
strObj.printString()


# एक प्रोग्राम लिखें जो पायथन प्रक्रिया द्वारा मेमोरी उपयोग का निर्धारण करेगा
import os, psutil
print(psutil.Process(os.getpid()).memory_info().rss / 1024 ** 2)

# एक ऐसा फंक्शन लिखिए जो किसी कैरेक्टर का एससीआई मान प्रदान करे

def charToASCII(chr):
  return f'ASCII value of {chr} is: {ord(chr)}'
  
# एक स्ट्रिंग को उल्टा करने के लिए एक फंक्शन लिखें

def revStr(inp):
  inp = inp[::-1]
  return inp

# किसी भी संख्या द्वारा उपयोग किए जाने वाले बिट्स को निर्धारित करने के लिए एक फ़ंक्शन लिखें

def totalBits(n):
	return f'total number of bits used in {n} is : {len(bin(n)[2: ])}'

# एक सूची को देखते हुए इसे 3 बराबर भागों में विभाजित करें और प्रत्येक सूची को वापस करें
sampleList = [11, 45, 8, 23, 14, 12, 78, 45, 89]

length = len(sampleList)
chunkSize  = int(length/3)
start = 0
end = chunkSize
for i in range(1, 4, 1):
  indexes = slice(start, end, 1)
  listChunk = sampleList[indexes]
  mylist = [i for i in listChunk]
  print("After reversing it ", mylist)
  start = end
  if(i != 2):
    end +=chunkSize
  else:
    end += length - chunkSize

# एक इनपुट के घातांक की गणना करने के लिए एक प्रोग्राम लिखें
input = 9
exponent = 2
final = pow(input, exponent)
print(f'Exponent Value is:{final}')

# दो मैट्रिक्स को गुणा करने के लिए एक प्रोग्राम लिखें

X = [[12,7,3],
    [4 ,5,6],
    [7 ,8,9]]

Y = [[5,8,1,2],
    [6,7,3,0],
    [4,5,9,1]]

result = [[0,0,0,0],
         [0,0,0,0],
         [0,0,0,0]]

for i in range(len(X)):
   for j in range(len(Y[0])):
       for k in range(len(Y)):
           result[i][j] += X[i][k] * Y[k][j]
print(f"Final Result is{result}")

# शेष दो संख्याओं को खोजने और प्रिंट करने के लिए एक प्रोग्राम लिखें

num1 = 12
num2 = 10

ratio = num1 % num2
print(f'remainder:{ratio}')

# पायथन में एक संख्या को उल्टा करें
number = 1367891
revs_number = 0  
while (number > 0):
  remainder = number % 10
  revs_number = (revs_number * 10) + remainder
  number = number // 10
print("The reverse number is : {}".format(revs_number))

# संख्या में अंकों के योग की गणना करने के लिए पायथन प्रोग्राम
def sumDigits(no):  
    return 0 if no == 0 else int(no % 10) + sumDigits(int(no / 10))   
n = 1234511
print(sumDigits(n))

# एक यादृच्छिक संख्या सूची के मध्य तत्व का पता लगाएं
my_list = [4,3,2,9,10,44,1]
print("mid value is ",my_list[int(len(my_list)/2)])

# सूची को आरोही क्रम में क्रमबद्ध करें
my_list = [4,3,2,9,10,44,1]
my_list.sort()
print(f"Ascending Order list:,{my_list}")

# सूची को अवरोही क्रम में क्रमबद्ध करें
my_list = [4,3,2,9,10,44,1]
my_list.sort(reverse=True)
print(f"Descending Order list:,{my_list}")

# दो सूची का संयोजन
my_list1 = [4,3,2,9,10,44,1]
my_list2 = [5,6,2,8,15,14,12]
print(f"Sum of two list:,{my_list1+my_list2}")

# दिए गए इंडेक्स पर आइटम को सूची से हटाता है और हटाए गए आइटम को वापस करता है
my_list1 = [4,3,2,9,10,44,1,9,12]
index = 4
print(f"Sum of two list:,{my_list1.pop(index)}")

# सूची में तत्व जोड़ना
animals = ['cat', 'dog', 'rabbit']
animals.append('guinea pig')
print('Updated animals list: ', animals)

# सूची में निर्दिष्ट तत्व के प्रकट होने की संख्या लौटाता है
vowels = ['a', 'e', 'i', 'o', 'i', 'u']
count = vowels.count('i')
print('The count of i is:', count)

# सूची के अंदर टपल तत्वों की गणना करें
random = ['a', ('a', 'b'), ('a', 'b'), [3, 4]]
count = random.count(('a', 'b'))
print("The count of ('a', 'b') is:", count)

# सूची से सभी आइटम निकालता है
list = [{1, 2}, ('a'), ['1.1', '2.2']]
list.clear()
print('List:', list)

# एक स्ट्रिंग में पहले वर्णों तक पहुँचें
word = "Hello World"
letter=word[0]
print(f"First Charecter in String:{letter}")

# एक स्ट्रिंग में अंतिम वर्णों तक पहुँचें
word = "Hello World"
letter=word[-1]
print(f"First Charecter in String:{letter}")

# सूची समझ से एक सूची उत्पन्न करें
list = [x for x in range(10)]
print(f"List Generated by list comprehension:{list}")

# नई सूची में मानों को अपरकेस में सेट करें
list = "AMITKAYAL"
newlist = [x.upper() for x in list]
print(f"New list to upper case:{newlist}")

# स्ट्रिंग सूची को वर्णानुक्रम में क्रमबद्ध करें

thislist = ["orange", "mango", "kiwi", "pineapple", "banana"]
thislist.sort()
print(f"Sorted List:{thislist}")

# दो सेट में शामिल हों
set1 = {"a", "b" , "c"}
set2 = {1, 2, 3}
set3 = set2.union(set1)
print(f"Joined Set:{set3}")

# केवल वही आइटम रखें जो दोनों सेट में मौजूद हों
x = {"apple", "banana", "cherry"}
y = {"google", "microsoft", "apple"}

x.intersection_update(y)
print(f"Duplicate Value in Two set:{x}")

# सूची से सभी आइटम रखें लेकिन डुप्लीकेट नहीं
x = {"apple", "banana", "cherry"}
y = {"google", "microsoft", "apple"}

x.symmetric_difference_update(y)
print(f"Duplicate Value in Two set:{x}")

# एक शब्दकोश बनाएं और प्रिंट करें
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
print(f"Sample Dictionary:{thisdict}")

# शब्दकोश की लंबाई की गणना करें
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

print(f"Length of Dictionary:{len(thisdict)}")

# एक स्ट्रिंग और एक संख्या का मूल्यांकन करें
print(bool("Hello"))
print(bool(15))

# एक स्ट्रिंग की लंबाई की गणना करें
word = "Hello World"
print(f"Length of string: {len(word)}")

# एक स्ट्रिंग में रिक्त स्थान की संख्या गिनें
s = "Count, the number of spaces"
lenx = s.count(' ')
print(f"number of spaces in sring: {lenx}")

# स्प्लिट स्ट्रिंग्स
word = "Hello World"
ksplit = word.split(' ') 
print(f"Splited Strings: {ksplit}")

# दस डॉट्स प्रिंट करता है
ten = "." * 10
print(f"Ten dots: {ten}")

# एक स्ट्रिंग को दूसरे स्ट्रिंग से बदलना
word = "Hello World"
replace = "Bye"
input = "Hello"
after_replace = word.replace(input, replace)
print(f"String ater replacement: {after_replace}")

# प्रमुख पात्रों को हटा देता है
word = " xyz "
lstrip = word.lstrip()
print(f"String ater removal of leading characters:{lstrip}")

# अनुगामी वर्णों को हटाता है
word = " xyz "
rstrip = word.rstrip()
print(f"String ater removal of trailing characters:{rstrip}")

# जांचें कि क्या सभी वर्ण अल्फ़ान्यूमेरिक हैं
word = "Hello World"
check = word.isalnum()
print(f"All char are alphanumeric?:{check}")

# जांचें कि स्ट्रिंग में सभी वर्ण वर्णानुक्रम में हैं या नहीं
word = "Hello World"
check = word.isalpha()
print(f"All char are alphabetic?:{check}")

# यदि स्ट्रिंग में अंक हैं तो परीक्षण करें
word = "Hello World"
check = word.isdigit()
print(f"String contains digits?:{check}")

# परीक्षण करें यदि स्ट्रिंग में अपरकेस है
word = "Hello World"
check = word.isupper()
print(f"String contains upper case?:{check}")

# परीक्षण करें यदि स्ट्रिंग H से शुरू होती है
word = "Hello World"
check = word.startswith('H')
print(f"String starts with H?:{check}")

# दिए गए वर्ण के लिए एक पूर्णांक मान लौटाता है
str = "A"
val = ord(str)
print(f"Integer value for the given character?:{val}")

# फाइबोनैचि श्रृंखला 100 तक
n = 100
result = []
a, b = 0 , 1
while b < n:
  result. append( b)
  a, b = b, a + b
final = result
print(f"Fibonacci series up to 100:{final}")

# एक स्ट्रिंग में कुल अंक गिनना
str1 = "abc4234AFde"
digitCount = 0
for i in range(0,len(str1)):
  char = str1[i]
  if(char.isdigit()):
    digitCount += 1
print('Number of digits: ',digitCount)

# एक स्ट्रिंग में कुल अल्फ़ान्यूमेरिक की गिनती
str1 = "abc4234AFde"
digitCount = 0
for i in range(0,len(str1)):
  char = str1[i]
  if(char.isalpha()):
    digitCount += 1
print('Number of alphanumeric: ',digitCount)

# एक स्ट्रिंग में कुल अपर केस की गिनती करना
str1 = "abc4234AFde"
digitCount = 0
for i in range(0,len(str1)):
  char = str1[i]
  if(char.upper()):
    digitCount += 1
print('Number total Upper Case: ',digitCount)

# एक स्ट्रिंग में कुल लोअर केस की गिनती करना
str1 = "abc4234AFdeaa"
digitCount = 0
for i in range(0,len(str1)):
  char = str1[i]
  if(char.lower()):
    digitCount += 1
print('Number total lower Case: ',digitCount)

# पायथन में बबल सॉर्ट
list1 = [1, 5, 3, 4]

for i in range(len(list1)-1):
  for j in range(i+1,len(list1)):
    if(list1[i] > list1[j]):
      temp = list1[i]
      list1[i] = list1[j]
      list1[j] = temp
print("Bubble Sorted list: ",list1)

# दो सूचियों से संख्याओं के प्रत्येक जोड़े के गुणनफल की गणना करें
list1 = [1, 2, 3]
list2 = [5, 6, 7] 
final = [a*b for a in list1 for b in list2]
print(f"Product of every pair of numbers from two lists:{final}")

# दो सूचियों से संख्याओं के प्रत्येक जोड़े के योग की गणना करें
list1 = [1, 2, 3]
list2 = [5, 6, 7] 
final = [a+b for a in list1 for b in list2]
print(f"sum of every pair of numbers from two lists:{final}")

# दो सूचियों के जोड़ीवार उत्पाद की गणना करें
list1 = [1, 2, 3]
list2 = [5, 6, 7] 
final = [list1[i]*list2[i] for i in range(len(list1))]
print(f"pair-wise product of two lists:{final}")

# स्टैक से अंतिम तत्व निकालें
s = [1,2,3,4]
print(f"last element from the stack:{s.pop()}")

# कतार की शुरुआत में एक नंबर डालें
q = [1,2,3,4]
q.insert(0,5)
print(f"Revised List:{q}")

# दो वेक्टर का जोड़
v1 = [1,2,3]
v2 = [1,2,3]
s1 = [0,0,0]

for i in range(len(v1)):
  s1[i] = v1[i] + v2[i]
print(f"New Vector:{s1}")

# नकारात्मक कीमतों को 0 से बदलें और सूची में सकारात्मक मानों को अपरिवर्तित छोड़ दें
original_prices = [1.25, -9.45, 10.22, 3.78, -5.92, 1.16]
prices = [i if i > 0 else 0 for i in original_prices]
print(f"Final List:{prices}")

# शब्दकोश को JSON में कनवर्ट करें
import json
person_dict = {'name': 'Bob',
'age': 12,
'children': None
}
person_json = json.dumps(person_dict)
print(person_json)

# फ़ाइल में JSON लिखना
import json
person_dict = {"name": "Bob",
"languages": ["English", "Fench"],
"married": True,
"age": 32
}
with open('person.txt', 'w') as json_file:
  json.dump(person_dict, json_file)

# JSON कि सुंदर प्रिंट
import json
person_string = '{"name": "Bob", "languages": "English", "numbers": [2, 1.6, null]}'
person_dict = json.loads(person_string)
print(json.dumps(person_dict, indent = 4, sort_keys=True))

# जांचें कि JSON में कुंजी मौजूद है या नहीं
import json

studentJson ="""{
   "id": 1,
   "name": "john wick",
   "class": 8,
   "percentage": 75,
   "email": "jhon@pynative.com"
}"""

print("Checking if percentage key exists in JSON")
student = json.loads(studentJson)
if "percentage" in student:
    print("Key exist in JSON data")
    print(student["name"], "marks is: ", student["percentage"])
else:
    print("Key doesn't exist in JSON data")

# जांचें कि JSON में कुंजी के लिए कोई मान है या नहीं
import json

studentJson ="""{
   "id": 1,
   "name": "Ishwar Venugopal",
   "class": null,
   "percentage": 35,
   "email": "ishwarraja@gmail.com"
}"""
student = json.loads(studentJson)
if not (student.get('email') is None):
     print("value is present for given JSON key")
     print(student.get('email'))
else:
    print("value is not present for given JSON key")

# पायथन में JSON कुंजियों को क्रमबद्ध करें और इसे एक फ़ाइल में लिखें
import json
sampleJson = {"id" : 1, "name" : "value2", "age" : 29}

with open("sampleJson.json", "w") as write_file:
    json.dump(sampleJson, write_file, indent=4, sort_keys=True)
print("Done writing JSON data into a file")

# एक पायथन सूची दी गई। किसी सूची के प्रत्येक आइटम को उसके वर्ग में बदलें
aList = [1, 2, 3, 4, 5, 6, 7]
aList =  [x * x for x in aList]
print(aList)

# स्ट्रिंग्स की सूची से खाली स्ट्रिंग्स निकालें
list1 = ["Mike", "", "Emma", "Kelly", "", "Brad"]
resList = [i for i in (filter(None, list1))]
print(resList)

# एक प्रोग्राम लिखें जो दी गई पायथन सूची को प्राप्त करेगा, सूची से इनपुट की सभी घटनाओं को हटा दें
list1 = [5, 20, 15, 20, 25, 50, 20]

def removeValue(sampleList, val):
   return [value for value in sampleList if value != val]
   
resList = removeValue(list1, 20)
print(resList)

# 100 और 999 के बीच 3 यादृच्छिक पूर्णांक उत्पन्न करें जो 5 से विभाज्य है
import random

print("Generating 3 random integer number between 100 and 999 divisible by 5")
for num in range(3):
    print(random.randrange(100, 999, 5), end=', ')

# किसी दिए गए स्ट्रिंग से यादृच्छिक वर्ण चुनें
import random

name = 'pynative'
char = random.choice(name)
print("random char is ", char)

# लंबाई 5 की यादृच्छिक स्ट्रिंग उत्पन्न करें
import random
import string

def randomString(stringLength):
    """Generate a random string of 5 charcters"""
    letters = string.ascii_letters
    return ''.join(random.choice(letters) for i in range(stringLength))

print ("Random String is ", randomString(5) )

# दी गई प्रारंभ और समाप्ति तिथियों के बीच एक यादृच्छिक तिथि उत्पन्न करें
import random
import time

def getRandomDate(startDate, endDate ):
    print("Printing random date between", startDate, " and ", endDate)
    randomGenerator = random.random()
    dateFormat = '%m/%d/%Y'

    startTime = time.mktime(time.strptime(startDate, dateFormat))
    endTime = time.mktime(time.strptime(endDate, dateFormat))

    randomTime = startTime + randomGenerator * (endTime - startTime)
    randomDate = time.strftime(dateFormat, time.localtime(randomTime))
    return randomDate

print ("Random Date = ", getRandomDate("1/1/2016", "12/12/2018"))

# एक प्रोग्राम लिखें जो दो स्ट्रिंग्स, s1 और s2 दिए गए s1 के बीच में s2 जोड़कर एक नया स्ट्रिंग बनाएगा
def appendMiddle(s1, s2):
  middleIndex = int(len(s1) /2)
  middleThree = s1[:middleIndex:]+ s2 +s1[middleIndex:]
  print("After appending new string in middle", middleThree)
  
appendMiddle("Ault", "Kelly")

# स्ट्रिंग वर्णों को ऐसे व्यवस्थित करें कि छोटे अक्षर पहले आएं
str1 = "PyNaTive"
lower = []
upper = []
for char in str1:
    if char.islower():
        lower.append(char)
    else:
        upper.append(char)
sorted_string = ''.join(lower + upper)
print(sorted_string)

# एक स्ट्रिंग को देखते हुए, अन्य सभी वर्णों को अनदेखा करते हुए, स्ट्रिंग में दिखाई देने वाले अंकों का योग और औसत लौटाएं
import re

inputStr = "English = 78 Science = 83 Math = 68 History = 65"
markList = [int(num) for num in re.findall(r'\b\d+\b', inputStr)]
totalMarks = 0
for mark in markList:
  totalMarks+=mark

percentage = totalMarks/len(markList)  
print("Total Marks is:", totalMarks, "Percentage is ", percentage)

# एक इनपुट स्ट्रिंग को देखते हुए, एक स्ट्रिंग के भीतर सभी वर्णों की घटनाओं को गिनें
str1 = "Apple"
countDict = dict()
for char in str1:
  count = str1.count(char)
  countDict[char]=count
print(countDict)

# किसी दिए गए स्ट्रिंग को उल्टा करें
str1 = "PYnative"
print("Original String is:", str1)

str1 = str1[::-1]
print("Reversed String is:", str1)

# किसी दिए गए स्ट्रिंग से विशेष प्रतीक/विराम चिह्न हटाएं
import string

str1 = "/*Jon is @developer & musician"
new_str = str1.translate(str.maketrans('', '', string.punctuation))
print("New string is ", new_str)

# स्ट्रिंग से पूर्णांकों के अलावा अन्य सभी वर्णों को हटा दें
str1 = 'I am 25 years and 10 months old'
res = "".join([item for item in str1 if item.isdigit()])
print(res)

# दी गई स्ट्रिंग से प्रत्येक विराम चिह्न को # से बदलें
from string import punctuation

str1 = '/*Jon is @developer & musician!!'
replace_char = '#'
for char in punctuation:
    str1 = str1.replace(char, replace_char)

print("The strings after replacement : ", str1)

# एक सूची को देखते हुए इसे पुनरावृत्त करें और प्रत्येक तत्व की घटना की गणना करें और प्रत्येक तत्व की गिनती दिखाने के लिए एक शब्दकोश बनाएं
sampleList = [11, 45, 8, 11, 23, 45, 23, 45, 89]
countDict = dict()
for item in sampleList:
  if(item in countDict):
    countDict[item] += 1
  else:
    countDict[item] = 1
  
print("Printing count of each item  ",countDict)

# समान आकार की दो सूची को देखते हुए एक सेट बनाएं जैसे कि यह जोड़ी में दोनों सूचियों के तत्व को दिखाता है
firstList = [2, 3, 4, 5, 6, 7, 8]
secondList = [4, 9, 16, 25, 36, 49, 64]
result = zip(firstList, secondList)
resultSet = set(result)
print(resultSet)

# दो सेटों को देखते हुए प्रतिच्छेदन खोजें और उन तत्वों को पहले सेट से हटा दें
firstSet  = {23, 42, 65, 57, 78, 83, 29}
secondSet = {57, 83, 29, 67, 73, 43, 48}

intersection = firstSet.intersection(secondSet)
for item in intersection:
  firstSet.remove(item)
print("First Set after removing common element ", firstSet)

# एक शब्दकोश दिया गया है, शब्दकोश से सभी मान प्राप्त करें और इसे एक सूची में जोड़ें, लेकिन डुप्लिकेट न जोड़ें
speed  ={'jan':47, 'feb':52, 'march':47, 'April':44, 'May':52, 'June':53,
          'july':54, 'Aug':44, 'Sept':54} 

speedList = []
for item in speed.values():
  if item not in speedList:
    speedList.append(item)
print("unique list", speedList)

# दशमलव संख्या को अष्टक में बदलें
print('%o,' % (8))

# स्ट्रिंग को डेटाटाइम ऑब्जेक्ट में कनवर्ट करें
from datetime import datetime
date_string = "Feb 25 2020  4:20PM"
datetime_object = datetime.strptime(date_string, '%b %d %Y %I:%M%p')
print(datetime_object)

# दी गई तारीख से एक सप्ताह घटाएं
from datetime import datetime, timedelta
given_date = datetime(2020, 2, 25)
days_to_subtract = 7
res_date = given_date - timedelta(days=days_to_subtract)
print(res_date)

# किसी दी गई तारीख के सप्ताह का दिन ज्ञात करें?
from datetime import datetime
given_date = datetime(2020, 7, 26)
print(given_date.strftime('%A'))

# दी गई तारीख में सप्ताह (7 दिन) और 12 घंटे जोड़ें
from datetime import datetime, timedelta
given_date = datetime(2020, 3, 22, 10, 00, 00)
days_to_add = 7
res_date = given_date + timedelta(days=days_to_add, hours=12)
print(res_date)

# दो दी गई तिथियों के बीच दिनों की संख्या की गणना करें
from datetime import datetime

date_1 = datetime(2020, 2, 25).date()
date_2 = datetime(2020, 9, 17).date()
delta = None
if date_1 > date_2:
    delta = date_1 - date_2
else:
    delta = date_2 - date_1
print("Difference is", delta.days, "days")

# 0 से 10 तक की संख्याओं का योग निकालने के लिए एक पुनरावर्ती फलन लिखिए
def calculateSum(num):
    if num:
        return num + calculateSum(num-1)
    else:
        return 0
res = calculateSum(10)
print(res)

# दो दी गई संख्याओं के बीच सभी सम संख्याओं की Python सूची तैयार करें
num1 = 4
num2 = 30
myval = [i for i in range(num1, num2, 2)]
print(myval)

# दी गई सूची में से सबसे बड़ा आइटम लौटाएं
aList = [4, 6, 8, 24, 12, 2]
print(max(aList))

# एक पूर्णांक से प्रत्येक अंक को उल्टे क्रम में निकालने के लिए एक प्रोग्राम लिखें
number = 7536
while (number > 0):
    digit = number % 10
    number = number // 10
    print(digit, end=" ")

# पायथन सूची को देखते हुए, सूची से दी गई संख्या की सभी घटनाओं को हटा दें
num1 = 20
list1 = [5, 20, 15, 20, 25, 50, 20]

def removeValue(sampleList, val):
   return [value for value in sampleList if value != val]
resList = removeValue(list1, num1)
print(resList)

# किसी सूची को बेतरतीब ढंग से शफ़ल करें
import random
list = [2,5,8,9,12]
random.shuffle(list)
print ("Printing shuffled list ", list)

# फ्लोट नंबरों का एक यादृच्छिक n-आयामी सरणी उत्पन्न करें
import numpy
random_float_array = numpy.random.rand(2, 2)
print("2 X 2 random float array in [0.0, 1.0] \n", random_float_array,"\n")

# यादृच्छिक सार्वभौमिक अद्वितीय आईडी उत्पन्न करें
import uuid
safeId = uuid.uuid4()
print("safe unique id is ", safeId)

# अलग-अलग संभावना वाले सूची से दिए गए तत्वों की संख्या चुनें
import random
num1 =5
numberList = [111, 222, 333, 444, 555]
print(random.choices(numberList, weights=(10, 20, 30, 40, 50), k=num1))

# भारित यादृच्छिक संख्या उत्पन्न करें
import random
randomList = random.choices(range(10, 40, 5), cum_weights=(5, 15, 10, 25, 40, 65), k=6)
print(randomList)

# एक विश्वसनीय सुरक्षित यादृच्छिक संख्या उत्पन्न करना
import secrets
print("Random integer number generated using secrets module is ")
number = secrets.randbelow(30)
print(number)

# पायथन में एक सूची द्वारा गणना की जाने वाली मेमोरी का उपयोग किया जा रहा है
import sys
list1 = ['Scott', 'Eric', 'Kelly', 'Emma', 'Smith']
print("size of list = ",sys.getsizeof(list1))

# खोजें कि सूची में सभी तत्व समान हैं या नहीं
listOne = [20, 20, 20, 20]
print("All element are duplicate in listOne:", listOne.count(listOne[0]) == len(listOne))

# एक अभिव्यक्ति में दो शब्दकोशों को मर्ज करें
currentEmployee = {1: 'Scott', 2: "Eric", 3:"Kelly"}
formerEmployee  = {2: 'Eric', 4: "Emma"}
allEmployee = {**currentEmployee, **formerEmployee}
print(allEmployee)

# दो सूचियों को शब्दकोश में बदलें
ItemId = [54, 65, 76]
names = ["Hard Disk", "Laptop", "RAM"]
itemDictionary = dict(zip(ItemId, names))
print(itemDictionary)

# स्ट्रिंग में वैकल्पिक मामले
test_str = "geeksforgeeks"
res = "" 
for idx in range(len(test_str)): 
    if not idx % 2 : 
       res = res + test_str[idx].upper() 
    else: 
       res = res + test_str[idx].lower() 
print(res)

# ईमेल को मान्य करने के लिए एक पायथन प्रोग्राम लिखें
import re 
regex = '^[a-z0-9]+[\._]?[a-z0-9]+[@]\w+[.]\w{2,3}$'
def check(email):
  if(re.search(regex,email)):
    print("Valid Email")
  else:
    print("Invalid Email")

email = "ishwarraja@gmail.com"
check(email)

# पासवर्ड के सत्यापन को लागू करने के लिए एक प्रोग्राम लिखें
class Password:
    def __init__(self, password):
        self.password = password

    def validate(self):        
        vals = {
        'Password must contain an uppercase letter.': lambda s: any(x.isupper() for x in s),
        'Password must contain a lowercase letter.': lambda s: any(x.islower() for x in s),
        'Password must contain a digit.': lambda s: any(x.isdigit() for x in s),
        'Password must be at least 8 characters.': lambda s: len(s) >= 8,
        'Password cannot contain white spaces.': lambda s: not any(x.isspace() for x in s)            
        } 
        valid = True  
        for n, val in vals.items():                         
           if not val(self.password):                   
               valid = False
               return n
        return valid                


input_password = "Ishwar@12Su@ 1'"
p = Password(input_password)
if p.validate() is True:
  print('Password Valid')
else:
  print(p.validate())

# nth फिबोनैकी संख्या वापस करने के लिए पायथन फ़ंक्शन
def fib(n):
   if n <= 1:
      return n
   else:
      return (fib(n-1) + fib(n-2))

# पायथन फ़ंक्शन किसी संख्या के भाज्य को वापस करने के लिए
def fact(n):
   if n == 1:
      return n
   else:
      return n * fact(n-1)

# पायथन फ़ंक्शन संख्याओं की सूची के वर्गों को वापस करने के लिए
def sq(n):
   return [i**2 for i in range(n)]

# पायथन फ़ंक्शन संख्याओं की सूची का वर्गमूल वापस करने के लिए
def sqrt(n):
   return [i**0.5 for i in range(n)]

# पायथन फ़ंक्शन पहली सूची से सम संख्या और दूसरी सूची से विषम संख्या जोड़ने के लिए
def even_odd(l1, l2):
    return[x + y for x, y in zip(l1, l2) if x % 2 ==0 and y % 2 != 0]

# पायथन एक स्ट्रिंग से स्वरों को निकालने का कार्य करता है
def strip_vowel_str(str):
    vowels = ['a', 'e', 'i', 'o', 'u']
    return "".join([x for x in str if x not in vowels])

# पायथन ReLu फ़ंक्शन
def relu_like_activation(l):
    return[0 if x < 0 else x for x in l]

# पायथन sigmoid फ़ंक्शन
def sigmoid_activation(l):
    return[round(1/(1+math.exp(-x)),2) for x in l]

# पायथन फ़ंक्शन अपवित्र शब्दों की पहचान करने के लिए
def profane_filter(str):
    profane_word_url = "https://raw.githubusercontent.com/RobertJGabriel/Google-profanity-words/master/list.txt"
    file = urllib.request.urlopen(profane_word_url)
    for line in file:
        decoded_line = line.decode("utf-8")
    return decoded_line
    str = re.findall(r'\w+', str)
    return [i for i in str if i in decoded_line]

# पायथन फ़ंक्शन किसी सूची में सम संख्याएँ जोड़ने के लिए
def add_even_num(l):
    sum = reduce(lambda a, b: a + b, filter(lambda a: (a % 2 == 0), l))
    return sum

# पायथन फ़ंक्शन एक वृत्त का क्षेत्र को खोजने के लिए
def circle_area(r):
    return 22/7 * r**2

# पायथन प्रोग्राम यह पता लगाने के लिए कि कोई संख्या अभाज्य है या नहीं
def test_prime(n):
    if (n==1):
        return False
    elif (n==2):
        return True;
    else:
        for x in range(2,n):
            if(n % x==0):
                return False
        return True             

# पायथन फ़ंक्शन संख्याओं की सूची के क्यूब्स को वापस करने के लिए
def cube(n):
   return [i*i*i for i in range(n)]

# पायथन फ़ंक्शन दी गई संख्याओं का औसत खोजने के लिए
def average():
    numbers = []
    def add(number):
        numbers.append(number)
        total = sum(numbers)
        count = len(numbers)
        return total/count
    return add
a = average()
a(10)
a(20)
a(45)

# पायथन फ़ंक्शन योजक बनाने के लिए
def create_adders():
    adders = []
    for n in range(1, 4):
        adders.append(lambda x, y=n: x + y)
    return adders
adders = create_adders()

# डेटाटाइम के लिए पायथन फ़ंक्शन
from datetime import datetime
datetime.utcnow()
def log(msg, *, dt = datetime.utcnow()):
    print(f'Message at {dt} was {msg}')

# पता संदर्भ की गिनती के लिए पायथन फ़ंक्शन
import ctypes
def ref_count(address : int): #what is int doing here? Annotations
    return ctypes.c_long.from_address(address).value

# टपल को संशोधित करने के लिए पायथन फ़ंक्शन
def modify_tuple(t):
    print(f'Initial t mem-add = {id(t)}')
    t[0].append(100)
    print(f'Final t mem-add = {id(t)}')

# पायथन फ़ंक्शन दो स्ट्रिंग की तुलना करने के लिए
def compare_using_equals(n):
    a = 'a long string that is not intered' * 200
    b = 'a long string that is not intered' * 200
    for i in range(n):
        if a == b:
            pass

# इंटर्निंग का उपयोग करके स्ट्रिंग की तुलना करने के लिए पायथन प्रोग्राम
import sys
def compare_using_interning(n):
    a = sys.intern('a long string that is not intered' * 200)
    b = sys.intern('a long string that is not intered' * 200)
    for i in range(n):
        if a is b:
            pass

# पायथन फ़ंक्शन फ्लोट और दशमलव बनाने के लिए लगने वाले समय की गणना करने के लिए
import time
def run_float(n = 1):
    for i in range(n):
        a = 3.1415

def run_decimal(n = 1):
    for i in range(n):
        a = Decimal('3.1415')
n = 10000000
start = time.perf_counter()
run_float(n)
end = time.perf_counter()

print ('float: ', end - start)

start = time.perf_counter()
run_decimal(n)
end = time.perf_counter()

print ('decimal: ', end - start)

# reduce का उपयोग करके फैक्टोरियल के लिए पायथन फ़ंक्शन
def fact(n):
    from operator import mul
    from functools import reduce
    return reduce(mul, range(1, n+1))
fact(10)

# पायथन फ़ंक्शन यह पता लगाने के लिए कि क्या दिए गए निर्देशांक सर्कल के अंदर हैं
from random import uniform
from math import sqrt
def random_shot(rad):
    r_x = uniform(-rad, rad)
    r_y = uniform(-rad, rad)

    if sqrt(r_x**2 + r_y**2) <= rad:
        is_in_circle = True
    else:
        is_in_circle = False
    
    return r_x, r_y, is_in_circle

# पायथन फ़ंक्शन एक वर्ग के क्षेत्र को खोजने के लिए
def square_area(x):
    return x ** 2

# पहले n नंबरों के योग के लिए पायथन प्रोग्राम।
def sum_n_num(n):
    return n * (n + 1)/2

# पायथन प्रोग्राम दो सूचियाँ जोड़ने के लिए
 
NumList1 = []
NumList2 = []
total = []

Number = int(input("Please enter the Total Number of List Elements: "))
print("Please enter the Items of a First and Second List   ")
for i in range(1, Number + 1):
    List1value = int(input("Please enter the %d Element of List1 : " %i))
    NumList1.append(List1value)

    List2value = int(input("Please enter the %d Element of List2 : " %i))
    NumList2.append(List2value)
    
for j in range(Number):
    total.append( NumList1[j] + NumList2[j])
 
print("\nThe total Sum of Two Lists =  ", total)

# सूची में सबसे बड़ी और सबसे छोटी संख्या खोजने के लिए पायथन प्रोग्राम

NumList = []
Number = int(input("Please enter the Total Number of List Elements: "))
for i in range(1, Number + 1):
    value = int(input("Please enter the Value of %d Element : " %i))
    NumList.append(value)

smallest = largest = NumList[0]

for j in range(1, Number):
    if(smallest > NumList[j]):
        smallest = NumList[j]
        min_position = j
    if(largest < NumList[j]):
        largest = NumList[j]
        max_position = j

print("The Smallest Element in this List is : ", smallest)
print("The Index position of Smallest Element in this List is : ", min_position)
print("The Largest Element in this List is : ", largest)
print("The Index position of Largest Element in this List is : ", max_position)

# पायथन पैलिंड्रोम प्रोग्राम फंक्शंस का उपयोग करके
 
reverse = 0
def integer_reverse(number):
    global reverse
    
    if(number > 0):
        Reminder = number % 10
        reverse = (reverse * 10) + Reminder
        integer_reverse(number // 10)
    return reverse


number = int(input("Please Enter any Number: "))

rev = integer_reverse(number)
print("Reverse of a Given number is = %d" %rev)

if(number == rev):
    print("%d is a Palindrome Number" %number)
else:
    print("%d is not a Palindrome Number" %number)

# पायथन प्रोग्राम दो नंबर स्वैप करने के लिए
 
a = float(input(" Please Enter the First Value a: "))
b = float(input(" Please Enter the Second Value b: "))

print("Before Swapping two Number: a = {0} and b = {1}".format(a, b))

temp = a
a = b
b = temp

print("After Swapping two Number: a = {0} and b = {1}".format(a, b))

# स्ट्रिंग्स को जोड़ने के लिए पायथन प्रोग्राम

str1 = input("Please Enter the First  String : ")
str2 = input("Please Enter the Second String : ")

concat1 = str1 + str2
print("The Final String After Python String Concatenation = ", concat1)

concat2 = str1 + ' ' + str2
print("The Final After String Concatenation with Space = ", concat2)

# तीन नंबरों में से सबसे बड़ी संख्या खोजने के लिए पायथन प्रोग्राम

a = float(input("Please Enter the First value: "))
b = float(input("Please Enter the First value: "))
c = float(input("Please Enter the First value: "))

if (a > b and a > c):
          print("{0} is Greater Than both {1} and {2}". format(a, b, c))
elif (b > a and b > c):
          print("{0} is Greater Than both {1} and {2}". format(b, a, c))
elif (c > a and c > b):
          print("{0} is Greater Than both {1} and {2}". format(c, a, b))
else:
          print("Either any two values or all the three values are equal")

# एक वृत्त का व्यास, परिधि और क्षेत्रफल खोजने के लिए पायथन प्रोग्राम
import math

def find_Diameter(radius):
    return 2 * radius

def find_Circumference(radius):
    return 2 * math.pi * radius

def find_Area(radius):
    return math.pi * radius * radius

r = float(input(' Please Enter the radius of a circle: '))

diameter = find_Diameter(r)
circumference = find_Circumference(r)
area = find_Area(r)

print("\n Diameter Of a Circle = %.2f" %diameter)
print(" Circumference Of a Circle = %.2f" %circumference)
print(" Area Of a Circle = %.2f" %area)

# पायथन प्रोग्राम स्ट्रिंग को अपरकेस में कनवर्ट करने के लिए
 
string = input("Please Enter your Own String : ")

string1 = string.upper()
 
print("\nOriginal String in Lowercase  =  ", string)
print("The Given String in Uppercase =  ", string1)

# साधारण ब्याज की गणना करने के लिए पायथन प्रोग्राम

princ_amount = float(input(" Please Enter the Principal Amount : "))
rate_of_int = float(input(" Please Enter the Rate Of Interest   : "))
time_period = float(input(" Please Enter Time period in Years   : "))

simple_interest = (princ_amount * rate_of_int * time_period) / 100

print("\nSimple Interest for Principal Amount {0} = {1}".format(princ_amount, simple_interest))

# पायथन प्रोग्राम दो सूचियों को एक शब्दकोश में मैप करने के लिए

keys = ['name', 'age', 'job']
values = ['John', 25, 'Developer']

myDict = {k: v for k, v in zip(keys, values)}
print("Dictionary Items  :  ",  myDict)

# सिलेंडर की मात्रा की गणना करने के लिए एक पायथन फ़ंक्शन लिखें
def volume(r, h): 
    vol = 22/7 * r * r * h 
    return vol

# हनोई के टावर को हल करने के लिए रिकर्सिव पायथन फ़ंक्शन
def TowerOfHanoi(n , source, destination, auxiliary): 
    if n==1: 
        print "Move disk 1 from source",source,"to destination",destination 
        return
    TowerOfHanoi(n-1, source, auxiliary, destination) 
    print "Move disk",n,"from source",source,"to destination",destination 
    TowerOfHanoi(n-1, auxiliary, destination, source) 

n = 4
TowerOfHanoi(n,'A','B','C') 
  
# घंटे की सुई और मिनट की सुई के बीच का कोण खोजने के लिए पायथन फ़ंक्शन
def calcAngle(hh, mm): 
  
    # Calculate the angles moved by 
    # hour and minute hands with  
    # reference to 12:00 
    hour_angle = 0.5 * (hh * 60 + mm) 
    minute_angle = 6 * mm 
  
    # Find the difference between 
    # two angles 
    angle = abs(hour_angle - minute_angle) 
  
    # Return the smaller angle of two 
    # possible angles 
    angle = min(360 - angle, angle) 
  
    return angle 
  
# पायथन फ़ंक्शन हर समय प्रिंट करने के लिए जब घंटे हाथ और मिनट हाथ के बीच का कोण थीटा है
def printTime(theta): 
  
    for hh in range(0, 12): 
        for mm in range(0, 60): 
            if (calcAngle(hh, mm)==theta): 
                print(hh, ":", mm, sep = "") 
                return
              
    print("Input angle not valid.") 
    return

# एक लिंक की गई सूची को उलटने के लिए एक पायथन प्रोग्राम लिखें

class Node: 

    def __init__(self, data): 
        self.data = data 
        self.next = None

class LinkedList: 

    def __init__(self): 
        self.head = None

    def reverse(self): 
        prev = None
        current = self.head 
        while(current is not None): 
            next = current.next
            current.next = prev 
            prev = current 
            current = next
        self.head = prev 
        
    def push(self, new_data): 
        new_node = Node(new_data) 
        new_node.next = self.head 
        self.head = new_node 

    def printList(self): 
        temp = self.head 
        while(temp): 
            print(temp.data)
            temp = temp.next


llist = LinkedList() 
llist.push(20) 
llist.push(4) 
llist.push(15) 
llist.push(85) 

print("Given Linked List")
llist.printList() 
llist.reverse() 
print("\nReversed Linked List")
llist.printList() 

# किसी दिए गए स्ट्रिंग से सभी डुप्लीकेट को हटाने के लिए एक पायथन फ़ंक्शन लिखें
def removeDuplicate(str): 
    s=set(str) 
    s="".join(s) 
    print("Without Order:",s) 
    t="" 
    for i in str: 
        if(i in t): 
            pass
        else: 
            t=t+i 
    print("With Order:",t) 
    
str1="conondrum"
removeDuplicate(str1) 

from .sin import sine
from .cos import cosine
from .tan import tangent
from .softmax import softmax
from .sigmoid import sigmoid
from .tanh import tanh
from .relu import ReLU
from .log import log
from .exp import exp

from .sin import dsine
from .cos import dcosine
from .tan import dtangent
from .sigmoid import dsigmoid
from .tanh import dtanh
from .log import dlog
from .exp import dexp

import math

# कोसाइन कोण खोजने के लिए पायथन फ़ंक्शन
def cosine(angle):

    """ returns the cosine value for an angle mentioned in radians"""

    return math.cos(angle)

# कोसाइन कोण के व्युत्पन्न को खोजने के लिए पायथन फ़ंक्शन
def dcosine(angle):

    """ returns the cosine value for an angle mentioned in radians"""

    return -math.sin(angle)

# साइन कोण खोजने के लिए पायथन फ़ंक्शन
def sine(angle):

    """ returns the sine value for an angle mentioned in radians"""

    return math.sin(angle)

# साइन कोण के व्युत्पन्न को खोजने के लिए पायथन फ़ंक्शन
def dsine(angle):

    """ returns the sine value for an angle mentioned in radians"""

    return math.cos(angle)

# स्पर्शरेखा कोण खोजने के लिए पायथन फ़ंक्शन 
def tangent(angle):

  """ returns the tangent value for an angle mentioned in radians"""

  return math.tan(angle)

# स्पर्शरेखा कोण के व्युत्पन्न खोजने के लिए पायथन फ़ंक्शन
def dtangent(angle):

  """ returns the tangent value for an angle mentioned in radians"""

  return 1/(math.cos(angle)**2)

# किसी संख्या के प्रतिपादक को खोजने के लिए पायथन फ़ंक्शन
def exp(x):

  """returns e^x of a number"""

  return math.exp(x)

# एक संख्या के प्रतिपादक के व्युत्पन्न को खोजने के लिए पायथन फ़ंक्शन
def dexp(x):

    return math.exp(x)

# किसी संख्या के लॉगरिदमिक मान को खोजने के लिए पायथन फ़ंक्शन
def log(x):

  """returns the logarithmic value of a number"""

  return math.log(x)

# किसी संख्या के लघुगणकीय मान का व्युत्पन्न ज्ञात करने के लिए पायथन फ़ंक्शन
def dlog(x):

    return 1/x

# वेक्टर के सॉफ्टमैक्स आउटपुट को खोजने के लिए पायथन फ़ंक्शन

def softmax(x):

  """returns the softmax output of a vector"""

  if(type(x) == int or type(x) == float):

    return 1

  denom = 0

  for i in x:

    denom+=math.exp(i)

  new_vec = []

  for i in x:

    new_vec.append(math.exp(i)/denom)

  return new_vec
  
# एक संख्या के अतिशयोक्तिपूर्ण स्पर्शरेखा मूल्य को खोजने के लिए पायथन फ़ंक्शन
def tanh(x):

  """ returns the hyperbolic tangent value of a number"""

  return math.tanh(x)

# एक संख्या के अतिशयोक्तिपूर्ण स्पर्शरेखा मान के व्युत्पन्न को खोजने के लिए पायथन फ़ंक्शन
def dtanh(x):

  """ returns the hyperbolic tangent value of a number"""

  return 1 - (math.tanh(x)**2)